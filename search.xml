<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前缀和&amp;差分</title>
    <url>/2020/12/19/%E5%89%8D%E7%BC%80%E5%92%8C&amp;%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一维前缀和 初始化</span></span><br><span class="line"><span class="keyword">int</span> a[N]=&#123;<span class="number">0</span>&#125;,dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    dp[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//性质</span></span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + a[i];</span><br><span class="line">dp[L,R] = dp[R] - dp[L<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维前缀和 初始化</span></span><br><span class="line"><span class="keyword">int</span> a[N][M]=&#123;<span class="number">0</span>&#125;,dp[N][M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">        dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]-dp[x<span class="number">-1</span>][y<span class="number">-1</span>]+a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//性质</span></span><br><span class="line">dp[a,b][c,d]=dp[c][d]-dp[a][d]-dp[c][b]+sum[a][b];</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="/2020/12/19/%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/2.png" alt="image-20201219113830487" style="zoom:67%;">

<hr>
<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一维差分 初始化</span></span><br><span class="line"><span class="keyword">int</span> a[N]=&#123;<span class="number">0</span>&#125;,dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    dp[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//差分数组前缀和 = a[]元素值</span></span><br><span class="line">dp[<span class="number">1</span>]+dp[<span class="number">2</span>]+...+dp[i]=a[i];</span><br><span class="line"><span class="comment">//差分数组单点修改 = a[]区间整体+-</span></span><br><span class="line">      dp[L] += c,dp[R+<span class="number">1</span>] -= c;</span><br><span class="line">等价于a[L]+=c,a[L+<span class="number">1</span>]+=c,...,a[R]+=c;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><img src="/2020/12/19/%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/3.png"></p>
<blockquote>
<p>分析: 暴力做法O(q*n),超时</p>
<ol>
<li>将原数组A—&gt;差分数组B,将区间操作—&gt;单点修改</li>
<li>B数组前缀和即为A数组最终数值.0(n+q)</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,q,a[N],b[N];<span class="comment">//防止q次操作导致int溢出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        b[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l,r,c;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        b[l]+=c; b[r+<span class="number">1</span>]-=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) </span><br><span class="line">            tmp=b[i],<span class="built_in">cout</span>&lt;&lt;tmp;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">1</span>)</span><br><span class="line">            tmp+=b[i],<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>前缀和&amp;差分</tag>
      </tags>
  </entry>
  <entry>
    <title>尺取法</title>
    <url>/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="经典例题-求长度最小的连续区间-使之-sum-gt-给定整数S"><a href="#经典例题-求长度最小的连续区间-使之-sum-gt-给定整数S" class="headerlink" title="经典例题-求长度最小的连续区间 使之 sum&gt;=给定整数S"></a>经典例题-求长度最小的连续区间 使之 sum&gt;=给定整数S</h1><p><img src="/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/2.png" alt="image-20201217162325484"></p>
<img src="/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/3.png" alt="image-20201217154139876" style="zoom: 50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n &amp;&amp; sum &lt; s)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += a[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; s) <span class="keyword">break</span>;</span><br><span class="line">        ans = min(ans, r - l);</span><br><span class="line">        sum -= a[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="平衡字符串问题"><a href="#平衡字符串问题" class="headerlink" title="平衡字符串问题"></a>平衡字符串问题</h1><p><img src="/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/4.png" alt="image-20201217163402959"></p>
<blockquote>
<p>why用 尺取法?</p>
<ol>
<li>所求答案为一个连续的区间.</li>
<li>区间左右端点移动有着明确的方向.—&gt;当前[L,R]满足要求,则L++.当前[L,R]不满足要求,则R++.</li>
</ol>
</blockquote>
<blockquote>
<p>给定[L,R],如何判断是否满足要求呢?</p>
<ol>
<li><p>用sum1,sum2,sum3,sum4分别记录不包括区间[L,R]这一段时,字符’A’’B’’C’’D’</p>
</li>
<li><p>先通过替换使4类字符数量一致,再判断剩余空闲位置是否是4的倍数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MAX = max(sum1,sum2,sum3,sum4);</span><br><span class="line"><span class="built_in">free</span> = 区间元素个数-[(MAX-sum1)+(MAX-sum2)+(MAX-sum3)+(MAX-sum4)]</span><br><span class="line"><span class="comment">//若free&gt;=0且为4的倍数,则满足要求;否则不满足.</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">100000</span>, sum1, sum2, sum3, sum4;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            sum1++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">            sum2++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            sum3++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">            sum4++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum1 == sum2 &amp;&amp; sum2 == sum3 &amp;&amp; sum3 == sum4)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxx = max(max(sum1, sum2), max(sum3, sum4));</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span> = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; !(<span class="built_in">free</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">free</span> % <span class="number">4</span> == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// [l,r] 不符合条件 - r++</span></span><br><span class="line">            <span class="keyword">if</span> (s[r] == <span class="string">&#x27;Q&#x27;</span>) sum1--;</span><br><span class="line">            <span class="keyword">if</span> (s[r] == <span class="string">&#x27;W&#x27;</span>) sum2--;</span><br><span class="line">            <span class="keyword">if</span> (s[r] == <span class="string">&#x27;E&#x27;</span>) sum3--;</span><br><span class="line">            <span class="keyword">if</span> (s[r] == <span class="string">&#x27;R&#x27;</span>) sum4--;</span><br><span class="line">            r++;</span><br><span class="line">            maxx = max(max(sum1, sum2), max(sum3, sum4));</span><br><span class="line">            <span class="built_in">free</span> = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">free</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">free</span> % <span class="number">4</span> == <span class="number">0</span>)) <span class="keyword">break</span>;</span><br><span class="line">        ans = min(ans, r-l);</span><br><span class="line">        <span class="comment">// [l,r] 符合条件 - l++</span></span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;Q&#x27;</span>) sum1++;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;W&#x27;</span>) sum2++;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;E&#x27;</span>) sum3++;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;R&#x27;</span>) sum4++;</span><br><span class="line">        l++;</span><br><span class="line">        maxx = max(max(sum1, sum2), max(sum3, sum4));</span><br><span class="line">        <span class="built_in">free</span> = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>线性数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈和单调队列</title>
    <url>/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h1><p><img src="/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/1.png" alt="image-20201217095745201"></p>
<h2 id="伪码实现"><a href="#伪码实现" class="headerlink" title="伪码实现"></a>伪码实现</h2><blockquote>
<ol>
<li><p><strong>单增栈</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈顶---&gt;栈底,单调增  (只维护一端:栈顶)</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> a[n+<span class="number">1</span>];<span class="comment">//a[1]~a[n]源数据</span></span><br><span class="line">a[n+<span class="number">1</span>]=INT_MAX; <span class="comment">//为了将栈内元素全部弹出</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(st.size()&gt;<span class="number">0</span>&amp;&amp;a[i]&gt;st.top())</span><br><span class="line">    &#123;<span class="comment">//谁的加入(即a[i])把你弹出去了,谁就是你往→第一个比你 big 的数    </span></span><br><span class="line">!!! 即<span class="keyword">while</span>循环里 a[i]就是st.top() 往→第一个big的数</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    st.push(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>单增队列</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队首---&gt;队尾,单调增 (维护两端:队首和队尾)</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> a[n+<span class="number">1</span>];<span class="comment">//a[1]~a[n]源数据</span></span><br><span class="line"><span class="keyword">int</span> k=<span class="number">3</span>;<span class="comment">//窗口大小</span></span><br><span class="line"><span class="comment">//初始化队列大小为k-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.size()&gt;<span class="number">0</span>&amp;&amp;a[i]&lt;q.back())</span><br><span class="line">        q.pop_back();</span><br><span class="line">    q.push_back(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口从k开始向右移动,维护一个单增队列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">&#123;   <span class="comment">//维护单调性</span></span><br><span class="line">    <span class="keyword">while</span>(q.size()&gt;<span class="number">0</span>&amp;&amp;a[i]&lt;q.back())</span><br><span class="line">        q.pop_back();</span><br><span class="line">    q.push_back(a[i]);</span><br><span class="line">    <span class="comment">//再维护窗口大小,保证队列元素都落在窗口内</span></span><br><span class="line">    <span class="keyword">while</span>(q.size()&gt;<span class="number">0</span>&amp;&amp;(i-队首q.front的元素下标)&gt;=k)</span><br><span class="line">        q.pop_front();</span><br><span class="line">    </span><br><span class="line">!!! 此时窗口small值就是q.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h1 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h1><h2 id="单调栈-直方图求最大矩形面积"><a href="#单调栈-直方图求最大矩形面积" class="headerlink" title="单调栈:直方图求最大矩形面积"></a>单调栈:直方图求最大矩形面积</h2><p><img src="/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/3.png" alt="image-20201217110025171"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">int</span> a_l[N], a_r[N];<span class="comment">//必须存数组下标,因为面积计算公式要用到 区间长度</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;<span class="comment">//需配合a_l和a_r 也必须存数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">// →</span></span><br><span class="line">    a[n + <span class="number">1</span>] = <span class="number">-1</span>;<span class="comment">//保证数组中每个元素 都被 弹出一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st.size() &gt; <span class="number">0</span> &amp;&amp; a[i] &lt; a[st.top()])</span><br><span class="line">        &#123;</span><br><span class="line">            a_r[st.top()] = i;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ←</span></span><br><span class="line">    <span class="keyword">while</span> (st.size())</span><br><span class="line">        st.pop();</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//保证数组中每个元素 都被 弹出一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;=<span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st.size() &gt; <span class="number">0</span> &amp;&amp; a[i] &lt; a[st.top()])</span><br><span class="line">        &#123;</span><br><span class="line">            a_l[st.top()] = i;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = max(ans,(a_r[i]-a_l[i]<span class="number">-1</span>)*a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调队列-滑动窗口"><a href="#单调队列-滑动窗口" class="headerlink" title="单调队列:滑动窗口"></a>单调队列:滑动窗口</h2><p><img src="/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/4.png" alt="image-20201217110403393"></p>
<img src="/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/5.png" alt="image-20201217142828320" style="zoom: 67%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> a_min[N], a_max[N];<span class="comment">//里面存数组下标(直接存值亦可)</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//必须存数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">// min</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;<span class="comment">//维护单调性</span></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span> &amp;&amp; a[i] &lt; a[q.back()])</span><br><span class="line">            q.pop_back();</span><br><span class="line">        q.push_back(i);</span><br><span class="line">        <span class="comment">//再维护窗口大小,保证队列元素都落在窗口内</span></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span> &amp;&amp; (i - q.front()) &gt;= k)</span><br><span class="line">            q.pop_front();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">            a_min[i] = q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// max</span></span><br><span class="line">    q.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;<span class="comment">//维护单调性</span></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[q.back()])</span><br><span class="line">            q.pop_back();</span><br><span class="line">        q.push_back(i);</span><br><span class="line">        <span class="comment">//再维护窗口大小,保证队列元素都落在窗口内</span></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span> &amp;&amp; (i - q.front()) &gt;= k)</span><br><span class="line">            q.pop_front();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">            a_max[i] = q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[a_min[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[a_max[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>线性数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>vs2019添加c++万能头文件</title>
    <url>/2020/12/16/vs2019%E6%B7%BB%E5%8A%A0c++%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HekoStaticFile@latest/Heko/js/mouse_snow.min.js"></script>

<blockquote>
<ol>
<li><p>VS2019安装路径下找到VC文件依次进入Tools/MSVC/14.24.28314/include。然后在include内创建一个名称为bits的文件(图示为默认安装路径)<img src="/2020/12/16/vs2019%E6%B7%BB%E5%8A%A0c++%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/1.png" alt="image-20201216170231567"></p>
</li>
<li><p><img src="/2020/12/16/vs2019%E6%B7%BB%E5%8A%A0c++%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/2.png" alt="image-20201216170442154"></p>
</li>
<li><p>在bits文件夹创建一个stdc++.h并将下面代码复制进去即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ includes used for precompiling -*- C++ -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copyright (C) 2003-2015 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is part of the GNU ISO C++ Library.  This library is free</span></span><br><span class="line"><span class="comment">// software; you can redistribute it and/or modify it under the</span></span><br><span class="line"><span class="comment">// terms of the GNU General Public License as published by the</span></span><br><span class="line"><span class="comment">// Free Software Foundation; either version 3, or (at your option)</span></span><br><span class="line"><span class="comment">// any later version.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// This library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">// GNU General Public License for more details.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Under Section 7 of GPL version 3, you are granted additional</span></span><br><span class="line"><span class="comment">// permissions described in the GCC Runtime Library Exception, version</span></span><br><span class="line"><span class="comment">// 3.1, as published by the Free Software Foundation.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// You should have received a copy of the GNU General Public License and</span></span><br><span class="line"><span class="comment">// a copy of the GCC Runtime Library Exception along with this program;</span></span><br><span class="line"><span class="comment">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span></span><br><span class="line"><span class="comment">// &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** @file stdc++.h</span></span><br><span class="line"><span class="comment"> *  This is an implementation file for a precompiled header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 17.4.1.2 Headers</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GLIBCXX_NO_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ciso646&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csetjmp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ccomplex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfenv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdalign&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctgmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cwchar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cwctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;scoped_allocator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeindex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++万能头</tag>
      </tags>
  </entry>
  <entry>
    <title>解决win10蓝牙设备连接不上</title>
    <url>/2020/12/16/%E5%85%B3%E4%BA%8Ewin10%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="已配对蓝牙无法连接并且搜索不到"><a href="#已配对蓝牙无法连接并且搜索不到" class="headerlink" title="已配对蓝牙无法连接并且搜索不到"></a>已配对蓝牙无法连接并且搜索不到</h1><p><img src="/2020/12/16/%E5%85%B3%E4%BA%8Ewin10%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/1.png" alt="image-20201216144906317"></p>
<p><img src="/2020/12/16/%E5%85%B3%E4%BA%8Ewin10%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/2.png" alt="image-20201216144943264"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$Source = @<span class="string">&quot;</span></span><br><span class="line"><span class="string">   [DllImport(&quot;</span>BluetoothAPIs.dll<span class="string">&quot;, SetLastError = true, CallingConvention = CallingConvention.StdCall)]</span></span><br><span class="line"><span class="string">   [return: MarshalAs(UnmanagedType.U4)]</span></span><br><span class="line"><span class="string">   static extern UInt32 BluetoothRemoveDevice(IntPtr pAddress);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   public static UInt32 Unpair(UInt64 BTAddress) &#123;</span></span><br><span class="line"><span class="string">      GCHandle pinnedAddr = GCHandle.Alloc(BTAddress, GCHandleType.Pinned);</span></span><br><span class="line"><span class="string">      IntPtr pAddress     = pinnedAddr.AddrOfPinnedObject();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      UInt32 result       = BluetoothRemoveDevice(pAddress);</span></span><br><span class="line"><span class="string">      pinnedAddr.Free();</span></span><br><span class="line"><span class="string">      return result;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&quot;</span>@</span><br><span class="line"></span><br><span class="line">Function Get-BTDevice &#123;</span><br><span class="line">    Get-PnpDevice -class Bluetooth |</span><br><span class="line">      ?&#123;$_.HardwareID -match &#x27;DEV_&#x27;&#125; |</span><br><span class="line">         select Status, Class, FriendlyName, HardwareID,</span><br><span class="line">            # Extract device address from HardwareID</span><br><span class="line">            @&#123;N=&#x27;Address&#x27;;E=&#123;[uInt64](&#x27;0x&#123;0&#125;&#x27; -f $_.HardwareID[0].Substring(12))&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">################## Execution Begins Here ################</span><br><span class="line"></span><br><span class="line">$BTR       = Add-Type -MemberDefinition $Source -Name <span class="string">&quot;BTRemover&quot;</span>  -Namespace <span class="string">&quot;BStuff&quot;</span> -PassThru</span><br><span class="line">$BTDevices = @(Get-BTDevice) # Force <span class="built_in">array</span> <span class="keyword">if</span> null <span class="keyword">or</span> single item</span><br><span class="line">Do &#123;</span><br><span class="line">   If ($BTDevices.Count) &#123;</span><br><span class="line">      <span class="string">&quot;`n******** Bluetooth Devices ********`n&quot;</span> | Write-Host</span><br><span class="line">      For ($i=<span class="number">0</span>; $i -lt $BTDevices.Count; $i++) &#123;</span><br><span class="line">         (&#x27;&#123;0,5&#125; - &#123;1&#125;&#x27; -f ($i+1), $BTDevices[$i].FriendlyName) | Write-Host</span><br><span class="line">      &#125;</span><br><span class="line">      $selected = Read-Host <span class="string">&quot;`nSelect a device to remove (0 to Exit)&quot;</span></span><br><span class="line">      If ([<span class="keyword">int</span>]$selected -in <span class="number">1.</span>.$BTDevices.Count) &#123;</span><br><span class="line">         &#x27;Removing device: &#123;0&#125;&#x27; -f $BTDevices[$Selected-1].FriendlyName | Write-Host</span><br><span class="line">         $Result = $BTR::Unpair($BTDevices[$Selected<span class="number">-1</span>].Address)</span><br><span class="line">         If (!$Result) &#123;<span class="string">&quot;Device removed successfully.&quot;</span> | Write-Host&#125;</span><br><span class="line">         Else &#123;<span class="string">&quot;Sorry, an error occured.&quot;</span> | Write-Host&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   Else &#123;</span><br><span class="line">      <span class="string">&quot;`n********* No devices foundd ********&quot;</span> | Write-Host</span><br><span class="line">   &#125;</span><br><span class="line">&#125; While (($BTDevices = @(Get-BTDevice)) -<span class="keyword">and</span> [<span class="keyword">int</span>]$selected)</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p> <strong>将上述代码直接复制粘贴到 Windows  PowerShell 里,然后删除出问题的设备,重新搜索蓝牙设备即可.</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>win10</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>csp12-13收获</title>
    <url>/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<p><img src="/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/1.png" alt="image"></p>
<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="找到-gt-k的第一个位置"><a href="#找到-gt-k的第一个位置" class="headerlink" title="找到&gt;=k的第一个位置"></a>找到&gt;=k的第一个位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n,ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到-lt-k的最后一个位置"><a href="#找到-lt-k的最后一个位置" class="headerlink" title="找到&lt;=k的最后一个位置"></a>找到&lt;=k的最后一个位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse_lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到-k的第一个位置"><a href="#找到-k的第一个位置" class="headerlink" title="找到==k的第一个位置"></a>找到==k的第一个位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n,ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt; k)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到-k的最后一个位置"><a href="#找到-k的最后一个位置" class="headerlink" title="找到==k的最后一个位置"></a>找到==k的最后一个位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n,ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; k)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-整数二分-四个数列和为0"><a href="#例题-整数二分-四个数列和为0" class="headerlink" title="例题(整数二分):四个数列和为0"></a>例题(整数二分):四个数列和为0</h2><p><img src="/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/5.png" alt="image-20201216151559467"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先四重枚举肯定超时,所以要减少枚举的次数.</span></span><br><span class="line"><span class="comment">//先枚举a和b数组,然后将枚举结果放到一个新的数组ab,</span></span><br><span class="line"><span class="comment">//再枚举c和d数组,然后枚举的时候计算它的相反数在ab中出现几次(有序数组last位置-first位置)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N], b[N], c[N], d[N],ab[N*N];</span><br><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n*n, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ab[mid] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ab[mid] &lt; x)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n*n, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ab[mid] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ab[mid] &gt; x)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i] &gt;&gt; d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ab[(i<span class="number">-1</span>) * n + j] = a[i] + b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    sort(ab + <span class="number">1</span>, ab + <span class="number">1</span> + n * n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> key = -(c[i] + d[j]);</span><br><span class="line">            <span class="keyword">int</span> l = find_first(key), r = find_last(key);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="number">-1</span>)</span><br><span class="line">                ans += r - l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-浮点二分"><a href="#例题-浮点二分" class="headerlink" title="例题(浮点二分)"></a>例题(浮点二分)</h2><blockquote>
<p>求方程 f(x)=x^6+x-2014 在(0,+<strong>∞</strong>)的一个解,要求小数点后精确<strong>5</strong>位</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先估算一个区间 f(1)&lt;0 f(10)&gt;0 不妨l=1.0,r=10.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, <span class="number">6</span>) + x - <span class="number">2014</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">1</span>, r = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(r - l) &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(mid) * f(r) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.5lf&quot;</span>, find());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><blockquote>
<p>二分思想:只要是单调的,都可以二分!!!</p>
</blockquote>
<p><img src="/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/6.png" alt="image-20201216162837341"></p>
<blockquote>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>暴力枚举 i,j 将数列B计算出来,然后取它的中位数.时间和空间复杂度均0(n^2),无法接受<br>—&gt;转换思路  如果给定一个数p,如何判断它是不是中位数? —-&gt;计算p在数列中的排名(假定从小到大)即可</p>
<ol>
<li><p>如果p名次比中位数小,则说明  p比中位数小</p>
</li>
<li><p>如果p名次比中位数大,则说明  p比中位数大</p>
</li>
<li><p>如果p名次等于中位数,则说明  p是中位数</p>
<p>可以看出 满足单调性,可以对p进行二分.(二分答案!!!)</p>
<blockquote>
<p>如何计算p的名次?</p>
<ol>
<li><p>对于数组B={|Ai-Aj|,任意 1&lt;=i &lt; j&lt;=n} 将A数组从小到大排序,则可以去掉绝对值.即B={ Aj-Ai ,任意 1&lt;=i &lt; j&lt;=n}</p>
</li>
<li><p>那么计算Aj - Ai &lt;= p的个数即可.</p>
</li>
<li><p>移项有 Aj&lt;=p+Ai , 其中 i&lt;j</p>
<p>即对于每个P,枚举下标 i 然后计算满足条件的下标 j 的个数(整数二分!!!)</p>
</li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>
<blockquote>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li>首先确定答案区间(即p的范围),p就是新数组B中元素可能的取值,可以看出 0=&lt;Bi&lt;=A.max()-A.min()</li>
<li>然后就是对于每一个p,计算满足不等式(Aj&lt;=p+Ai )的个数.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="comment">//找到&lt;=k的最后一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">re_lower_bound</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rnk</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//计算满足 Aj&lt;=p+Ai , 其中 i&lt;j 的个数</span></span><br><span class="line"> <span class="comment">//对于每个p,枚举下标i,然后二分计算满足的j的个数. j的范围[i+1,n];</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = re_lower_bound(i + <span class="number">1</span>, n, p + a[i]);</span><br><span class="line">        <span class="keyword">if</span>(cnt!=<span class="number">-1</span>)</span><br><span class="line">            ans += cnt - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = (<span class="number">1</span> + n * (n - <span class="number">1</span>)) / <span class="number">2</span>; 	<span class="comment">//新数组的长度 </span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>, middle = (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//middle为中位数位置,下面实现 找到名次 &gt;=middle 的第一个p</span></span><br><span class="line">        <span class="comment">//思考为什么不是找 ==middle 的第一个p???</span></span><br><span class="line">        <span class="keyword">int</span> p_min = <span class="number">0</span>, p_max = a[n] - a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (p_min &lt;= p_max)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p_mid = (p_min + p_max) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = rnk(p_mid);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= middle)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = p_mid;</span><br><span class="line">                p_max = p_mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p_min = p_mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>middle为中位数位置,下面实现 找到名次 &gt;=middle 的第一个p</p>
<p>关于为什么不是找 ==middle 的第一个p?</p>
<p>===&gt; 在计算rak的时候 用到的不等式为: Aj&lt;=p+Ai </p>
<p>​          例如初始化B=1 3 3 3 5  答案p∈[1,5]   p_mid=3 然后返回的cnt=4&gt;middle=3 , 如果判 ==middle,p∈[1,2] ,就会接着找p_mid=1,返回的cnt=1,然后p∈[2,2],p_mid=2,返回cnt=1,然后p∈[3,2],就退出了</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title>sort,map,set</title>
    <url>/2020/12/09/STL%E6%8E%92%E5%BA%8F%E5%92%8Cmap/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<p><img src="/2020/12/09/STL%E6%8E%92%E5%BA%8F%E5%92%8Cmap/1.png"></p>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><h2 id="基本用法—对类型为T的数组"><a href="#基本用法—对类型为T的数组" class="headerlink" title="基本用法—对类型为T的数组"></a>基本用法—对类型为T的数组</h2><ol>
<li><p>默认从小到大排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(a,a+n);</span><br></pre></td></tr></table></figure>
</li>
<li><p>从大到小排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(a,a+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="对struct类型数组进行排序"><a href="#对struct类型数组进行排序" class="headerlink" title="对struct类型数组进行排序"></a>对struct类型数组进行排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rank</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> rank1 &amp; s) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (score!=s.score) <span class="keyword">return</span> score &gt; s.score; <span class="comment">//首先 按score从大--&gt;小</span></span><br><span class="line">		<span class="keyword">return</span> name &lt; s.name;<span class="comment">//其次 按name字典序从小--&gt;大</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">rank r[<span class="number">1000</span>];</span><br><span class="line">sort(r,r+count);</span><br></pre></td></tr></table></figure>

<h2 id="struct配合map自定义排序顺序-给元素添加一个val值-按val进行排序"><a href="#struct配合map自定义排序顺序-给元素添加一个val值-按val进行排序" class="headerlink" title="struct配合map自定义排序顺序(给元素添加一个val值,按val进行排序)"></a>struct配合map自定义排序顺序(给元素添加一个val值,按val进行排序)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; hua_val;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; name_val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> hua;<span class="comment">//卡牌的花色</span></span><br><span class="line">	<span class="keyword">char</span> name;<span class="comment">//卡牌的牌面</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> card &amp; s) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (hua!=s.hua) <span class="keyword">return</span> hua_val[hua] &lt; hua_val[s.hua];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> name_val[name] &lt; name_val[s.name];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hua_val[<span class="string">&#x27;C&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    hua_val[<span class="string">&#x27;D&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    hua_val[<span class="string">&#x27;S&#x27;</span>] = <span class="number">3</span>;	</span><br><span class="line">    hua_val[<span class="string">&#x27;H&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//用C,D,S,H分别表示梅花，方片，黑桃，红桃，即其单词首字母</span></span><br><span class="line">    <span class="comment">//规定花色（梅花）&lt;（方片）&lt;（黑桃）&lt;（红桃）</span></span><br><span class="line">    name_val[<span class="string">&#x27;2&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;3&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;4&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;5&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;6&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;7&#x27;</span>] = <span class="number">6</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;8&#x27;</span>] = <span class="number">7</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;9&#x27;</span>] = <span class="number">8</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;T&#x27;</span>] = <span class="number">9</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;J&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;Q&#x27;</span>] = <span class="number">11</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;K&#x27;</span>] = <span class="number">12</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;A&#x27;</span>] = <span class="number">13</span>;</span><br><span class="line">    <span class="comment">//规定2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; T &lt; J &lt; Q &lt; K &lt; A</span></span><br><span class="line">    card puke [<span class="number">13</span>];</span><br><span class="line">    sort(puke,puke+<span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量map声明,而不是声明一个空的map随后再赋值</span></span><br><span class="line">const map&lt;char,int&gt; hua_val(&#123;</span><br><span class="line">    &#123;<span class="string">&#x27;C&#x27;</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;D&#x27;</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;S&#x27;</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;H&#x27;</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>如果涉及到大量的insert数据,erase数据,find数据,考虑用stl中的平衡二叉树数据结构会很方便. </p>
<p>上述操作都能在 log(n)复杂度完成.</p>
<p>体现在stl中有4种容器 : <strong>multiset</strong>  <strong>set  multimap  map</strong></p>
<p>都会<strong>自动维持有序性</strong></p>
</blockquote>
<h1 id="set和multiset"><a href="#set和multiset" class="headerlink" title="set和multiset"></a>set和multiset</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="comment">//缺省排序规则 表达式&quot;a&lt;b&quot;为ture,则a排在b前面</span></span><br><span class="line"><span class="comment">//可用 st.insert() st.erase() st.find() 复杂度均log(n)</span></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">st.insert(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">if</span>(st.find(<span class="number">1</span>)!=s.end())</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the element is in set&quot;</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s.begin();it!=s.end();it++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*it);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : s)<span class="comment">//c++11 新特性</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">s.erase(val);</span><br><span class="line">s.clear();</span><br></pre></td></tr></table></figure>

<h1 id="map和multimap"><a href="#map和multimap" class="headerlink" title="map和multimap"></a>map和multimap</h1><blockquote>
<p>map中使用结构体需要重写比较方法 &lt; ,因为要维持其有序性.</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>bfs及其应用</title>
    <url>/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><blockquote>
<p>篇幅问题 只给出核心代码 省略一些不必要的声明和main()</p>
</blockquote>
<h2 id="BFS板子"><a href="#BFS板子" class="headerlink" title="BFS板子"></a>BFS板子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以输出路径的5×5迷宫为例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//省略重载point(x,y)和==</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123; <span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">5</span>][<span class="number">5</span>];<span class="comment">//-1表可以走,-2表不能走</span></span><br><span class="line">point path[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(point a, point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>, b.x, b.y);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	output(a, path[b.x][b.y]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>, b.x, b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;point&gt; q;</span><br><span class="line">	point now = a;</span><br><span class="line">	dis[now.x][now.y] = <span class="number">0</span>;</span><br><span class="line">	q.push(now);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q.size())</span><br><span class="line">	&#123;</span><br><span class="line">		now = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (now == b)</span><br><span class="line">		&#123;</span><br><span class="line">			output(a, b);</span><br><span class="line">			<span class="keyword">return</span> dis[now.x][now.y];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> new_x = now.x + dx[i],new_y = now.y + dy[i];</span><br><span class="line">			<span class="keyword">if</span> (new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;=<span class="number">4</span> &amp;&amp; new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;=<span class="number">4</span> &amp;&amp; dis[new_x][new_y]==<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				q.push(point(new_x, new_y));</span><br><span class="line">				dis[new_x][new_y] = dis[now.x][now.y] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				path[new_x][new_y] = now;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="倒水问题"><a href="#倒水问题" class="headerlink" title="倒水问题"></a>倒水问题</h2><p><img src="/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/1.png" alt="image-20201214102954955"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A, B, C;</span><br><span class="line"><span class="comment">//map中使用struct需要重载 &lt; 进行排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;<span class="comment">//省略重载state(a,b)</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> state&amp; p) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a != p.a)<span class="keyword">return</span> a &lt; p.a;</span><br><span class="line">		<span class="keyword">return</span> b &lt; p.b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;state, state&gt; from; </span><br><span class="line"><span class="built_in">map</span>&lt;state, <span class="built_in">string</span>&gt; step;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(state now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (now.a == <span class="number">0</span> &amp;&amp; now.b == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;&lt;%d,%d&gt;\n&quot;, now.a, now.b);</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	output(from[now]);</span><br><span class="line">	<span class="comment">//printf(&quot;-&gt;&lt;%d,%d&gt;&quot;, now.a, now.b);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; step[now] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;state&gt; q;</span><br><span class="line">	<span class="function">state <span class="title">now</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	q.push(now);</span><br><span class="line">	<span class="keyword">while</span> (q.size())</span><br><span class="line">	&#123;</span><br><span class="line">		now = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (now.a == C || now.b == C)</span><br><span class="line">		&#123;</span><br><span class="line">			output(now);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如何记录之前状态是否已经存在了呢? 类似迷宫 已经走过</span></span><br><span class="line">		<span class="comment">//map&lt;state, state&gt; from;</span></span><br><span class="line">		<span class="keyword">if</span> (now.a &lt; A)<span class="comment">//①fill A</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">state <span class="title">after</span><span class="params">(A, now.b)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (from.find(after) == from.end())</span><br><span class="line">			&#123;</span><br><span class="line">				q.push(after);</span><br><span class="line">				</span><br><span class="line">				from[after] = now;</span><br><span class="line">				step[after] = <span class="string">&quot;fill A&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//省略②empty A</span></span><br><span class="line">		<span class="keyword">if</span> (now.a &gt; <span class="number">0</span>)<span class="comment">//③pour A B B满orA空</span></span><br><span class="line">		&#123;</span><br><span class="line">			state after;</span><br><span class="line">			<span class="keyword">if</span> (now.a + now.b &lt;= B)</span><br><span class="line">				after.a = <span class="number">0</span>, after.b = now.a + now.b;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				after.a = now.a + now.b - B, after.b = B;</span><br><span class="line">			<span class="keyword">if</span> (from.find(after) == from.end())</span><br><span class="line">			&#123;</span><br><span class="line">				q.push(after);</span><br><span class="line"></span><br><span class="line">				from[after] = now;</span><br><span class="line">				step[after] = <span class="string">&quot;pour A B&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//省略关于B的相同操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; C)</span><br><span class="line">	&#123;</span><br><span class="line">		from.clear();</span><br><span class="line">		step.clear();</span><br><span class="line">		bfs();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="超级源点问题"><a href="#超级源点问题" class="headerlink" title="超级源点问题"></a>超级源点问题</h2><blockquote>
<p>csp 201409-4 “最佳配餐”</p>
</blockquote>
<p><img src="/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/3.png" alt="image-20201214142559692"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化queue的时候将所有分店都push进去,bfs结束条件改为cnt==n*n 即网格中除了障碍物全部都遍历到.</span></span><br><span class="line"><span class="comment">//然后每个网格点都有了最小的dis,与记录的客户数目相乘算得结果即可.</span></span><br><span class="line"><span class="comment">//注:①ans要用long long储存②由图可知下标从1~n </span></span><br><span class="line"><span class="built_in">queue</span>&lt;point&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (q.size())</span><br><span class="line">		q.pop();</span><br><span class="line">	point now;</span><br><span class="line">	<span class="keyword">int</span> cnt = d;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">	&#123;<span class="comment">//读入的时候 vector v 记录一下分店的数目</span></span><br><span class="line">		now = v[i];</span><br><span class="line">		dis[now.x][now.y] = <span class="number">0</span>;</span><br><span class="line">		q.push(now);</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q.size())</span><br><span class="line">	&#123;</span><br><span class="line">		now = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (cnt == n * n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> new_x = now.x + dx[i],new_y = now.y + dy[i];</span><br><span class="line">			<span class="keyword">if</span> (new_x&gt;=<span class="number">1</span>&amp;&amp;new_x&lt;=n &amp;&amp; new_y&gt;=<span class="number">1</span>&amp;&amp;new_y&lt;=n &amp;&amp; dis[new_x][new_y]==<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				q.push(point(new_x, new_y));</span><br><span class="line">				dis[new_x][new_y] = dis[now.x][now.y] + <span class="number">1</span>;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="有特殊点的bfs"><a href="#有特殊点的bfs" class="headerlink" title="有特殊点的bfs"></a>有特殊点的bfs</h2><blockquote>
<p>csp 201403-4 “无线网络”</p>
</blockquote>
<p><img src="/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/4.png" alt="image-20201214161355466"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> dis, k;</span><br><span class="line">	Node() &#123; x = <span class="number">-1</span>, y = <span class="number">-1</span>, dis = <span class="number">0</span>, k = <span class="number">0</span>; &#125;</span><br><span class="line">	Node(<span class="keyword">long</span> <span class="keyword">long</span> _x, <span class="keyword">long</span> <span class="keyword">long</span> _y, <span class="keyword">int</span> _s, <span class="keyword">int</span> _k)</span><br><span class="line">	&#123;	x = _x, y = _y, dis = _s, k = _k;	&#125;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (q.size())</span><br><span class="line">		q.pop();</span><br><span class="line">	Node now = node[<span class="number">1</span>];</span><br><span class="line">	vis[begin] = <span class="number">1</span>;</span><br><span class="line">	q.push(now);</span><br><span class="line">	<span class="keyword">while</span> (q.size())</span><br><span class="line">	&#123;</span><br><span class="line">		now = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (now.x == node[end].x&amp;&amp;now.y == node[end].y)</span><br><span class="line">			<span class="keyword">return</span> now.dis - <span class="number">1</span>; <span class="comment">//中转个数=距离-1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> len;<span class="comment">// 下一跳可以选择node下标范围</span></span><br><span class="line">		<span class="keyword">if</span> (now.k == k) len = n;<span class="comment">//通过下一跳的范围限制 增设的路由器至多k个</span></span><br><span class="line">		<span class="keyword">else</span> len = n + m;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[i] &amp;&amp; ((now.x - node[i].x) * (now.x - node[i].x) </span><br><span class="line">             + (now.y - node[i].y) * (now.y - node[i].y) &lt;= r * r))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp_k;</span><br><span class="line">				<span class="keyword">if</span> (i &gt; n)</span><br><span class="line">					tmp_k = now.k + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					tmp_k = now.k;</span><br><span class="line">				vis[i] = <span class="number">1</span>;</span><br><span class="line">				q.push(Node(node[i].x, node[i].y, now.dis + <span class="number">1</span>, tmp_k));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; bfs(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本题明确了有n个点,显然用一维数组struct node[N]保存更为方便.</p>
<p>回忆之前 dis[] []二维数据  vis是隐藏在了dis[] []的数值里面,即== -1 的时候认为!vis . </p>
<p>故本例中增加了vis[N]数组用来记录是否访问过.    len的界限 是解决本题的关键.</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>sstream+getline</title>
    <url>/2020/11/24/sstream+getline/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="字符串分割神器—sstream-getline"><a href="#字符串分割神器—sstream-getline" class="headerlink" title="字符串分割神器—sstream+getline"></a>字符串分割神器—sstream+getline</h1><h2 id="一些string常用的字符串处理"><a href="#一些string常用的字符串处理" class="headerlink" title="一些string常用的字符串处理"></a>一些string常用的字符串处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s.substr(pos,n);<span class="comment">//截取s中从pos开始（包括0，左边是闭区间）的n个字符的子串，并返回字符串</span></span><br><span class="line">s.find(str s1); <span class="comment">//查找s中第一次出现s1的位置,并返回(包括0)</span></span><br><span class="line">s.copy(<span class="keyword">char</span> * s,<span class="keyword">int</span> n,<span class="keyword">int</span> pos)；</span><br><span class="line"><span class="comment">//返回值为实际拷贝的字符数目；把当前串pos位置开始的n个字符拷贝到s为起始位置的数组中；</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="sstream-getline"><a href="#sstream-getline" class="headerlink" title="sstream+getline"></a>sstream+getline</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;  //头文件</span></span></span><br><span class="line"><span class="comment">//stringstream的特点是，你读入了前面的一部分字符串，对应的字符串流中就会减去那一部分</span></span><br><span class="line"><span class="comment">//(配合getline截断字符使用的话，字符流中也会减去截断字符)，</span></span><br><span class="line"><span class="comment">//所以可以使用while来一直循环读入.</span></span><br></pre></td></tr></table></figure>

<p> <strong>eg. Sample input :</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/../d<span class="comment">///c</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/24/sstream+getline/1.png" alt="img"></p>
<p> <strong>eg. Sample output :</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">..</span><br><span class="line">d</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p><strong>在插入vector的过程中,要判断当前小字符串(stemp)是否为空 ; 否则会出现很多空字符 , 如下:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">..</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关于—getline"><a href="#关于—getline" class="headerlink" title="关于—getline()"></a>关于—getline()</h2><blockquote>
<p><strong>在c++中本质有两种 getline 函数</strong></p>
<ol>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在头文件&lt;iostream&gt;中 , 是iostream类的成员函数 .</span></span><br><span class="line"><span class="function">istream&amp;  <span class="title">getline</span>  <span class="params">(<span class="keyword">char</span>* s,streamsize n)</span></span>;</span><br><span class="line"><span class="comment">//从istream中读取至多n个字符(包括结束标记符)保存在s对应的数组中.</span></span><br><span class="line"><span class="function">istream&amp;  <span class="title">getline</span>  <span class="params">(<span class="keyword">char</span>* s,streamsize n,<span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="comment">//即使还没读够n个字符，如果遇到delim 或 字数达到限制，则读取终止 . delim不会被保存进s对应的数组中</span></span><br></pre></td></tr></table></figure>
</li>
<li> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在头文件&lt;string&gt;中，是普通函数.</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(istream&amp; is,<span class="built_in">string</span>&amp; str)</span></span>;</span><br><span class="line"><span class="comment">//从输入流is中(如 cin),读一行到str里面.</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(istream&amp; is,<span class="built_in">string</span>&amp; str,<span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="comment">//从输入流is中,按照截断字符delim读到str中</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<hr>
<h2 id="关于—流和EOF-win下是ctrl-Z"><a href="#关于—流和EOF-win下是ctrl-Z" class="headerlink" title="关于—流和EOF(win下是ctrl+Z)"></a>关于—流和EOF(win下是ctrl+Z)</h2><blockquote>
<p>就while(getline(cin,line))分析一下</p>
<p>这个while语句真实的判断对象是 cin 的状态,也就是当前是否存在有效的输入流.而输入流是对象,返回的是输入流的状态.正常情况下,你是怎么输入都跳不出循环的. (如果认为输入 回车 就可以跳出,则是将 while的判断对象看成了 line(即判断line是否为空) 实际上,回车和设置的delim都是仅终止getline()的读取操作).</p>
<p>EOF是C语言中为了区分有效数据和输入结束符的。windows下是ctrl+z,linux/unix下是ctrl+d。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
      </tags>
  </entry>
</search>
