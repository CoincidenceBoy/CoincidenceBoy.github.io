<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bezier曲线</title>
    <url>/2020/12/23/Bezier%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="Bezier曲线"><a href="#Bezier曲线" class="headerlink" title="Bezier曲线"></a>Bezier曲线</h1><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p><img src="/2020/12/23/Bezier%E6%9B%B2%E7%BA%BF/2.png" alt="image-20201223175452153"></p>
<p><img src="/2020/12/23/Bezier%E6%9B%B2%E7%BA%BF/3.png" alt="image-20201223175614794"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> site_left = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> site_top = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> WinW = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> WinH = <span class="number">450</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; input;</span><br><span class="line"><span class="keyword">int</span> nowid;<span class="comment">//用于鼠标移动</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> tx, <span class="keyword">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> x = input[i].x, y = input[i].y;</span><br><span class="line">    <span class="keyword">if</span> (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">200.0</span> / <span class="number">255</span>, <span class="number">200.0</span> / <span class="number">255</span>, <span class="number">169.0</span> / <span class="number">255</span>, <span class="number">0.0</span>);		<span class="comment">//设定清理颜色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);									<span class="comment">//清理缓冲区 </span></span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawOnePoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">    glPointSize(<span class="number">4</span>);</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    glVertex2d(x, y);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">    glEnable(GL_LINE_SMOOTH);</span><br><span class="line">    glLineWidth(<span class="number">1</span>);</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    glVertex2i(x1, y1);</span><br><span class="line">    glVertex2i(x2, y2);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//缓冲区重绘</span></span><br><span class="line">    glClearColor(<span class="number">200.0</span> / <span class="number">255</span>, <span class="number">200.0</span> / <span class="number">255</span>, <span class="number">169.0</span> / <span class="number">255</span>, <span class="number">0.0</span>);		<span class="comment">//设定清理颜色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="comment">//控制点重绘</span></span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">    glPointSize(<span class="number">4</span>);</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= input.size() - <span class="number">1</span>; i++)</span><br><span class="line">        glVertex2d(input[i].x, input[i].y);</span><br><span class="line">    glEnd();</span><br><span class="line">    <span class="comment">//特征多边形重绘</span></span><br><span class="line">    glLineWidth(<span class="number">1</span>);</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= input.size() - <span class="number">1</span>; i++)</span><br><span class="line">        drawLine(input[i - <span class="number">1</span>].x, input[i - <span class="number">1</span>].y, input[i].x, input[i].y);</span><br><span class="line">    glEnd();</span><br><span class="line">    </span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Bezier</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseClick</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> nowx, <span class="keyword">int</span> nowy)</span> <span class="comment">//x,y均是以窗口左上角为（0,0）的像素表示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    x = nowx, y = WinH - nowy;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(i, x, y)) </span><br><span class="line">        &#123;</span><br><span class="line">            id = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">if</span> (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            drawOnePoint(x, y);</span><br><span class="line">            input.push_back(point(x, y));</span><br><span class="line">            nowid = input.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nowid &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                drawLine(input[nowid - <span class="number">1</span>].x, input[nowid - <span class="number">1</span>].y, input[nowid].x, input[nowid].y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> nowid = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//画出Bezier</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (button == GLUT_MIDDLE_BUTTON &amp;&amp; state == GLUT_DOWN) </span><br><span class="line">    &#123; </span><br><span class="line">        redraw();</span><br><span class="line">        Bezier();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// delete</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (button == GLUT_RIGHT_BUTTON &amp;&amp; state == GLUT_DOWN) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            nowid = id;</span><br><span class="line">            input.erase(input.begin() + nowid);</span><br><span class="line">            redraw();</span><br><span class="line">            Bezier();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMotion</span><span class="params">(<span class="keyword">int</span> nowx, <span class="keyword">int</span> nowy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = nowx, y = WinH - nowy;</span><br><span class="line">    input[nowid].x = x, input[nowid].y = y;</span><br><span class="line">    redraw();</span><br><span class="line">    Bezier();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);	<span class="comment">//显示窗口的缓存和颜色模型</span></span><br><span class="line">    glutInitWindowPosition(site_left, site_top);</span><br><span class="line">    glutInitWindowSize(WinW, WinH);</span><br><span class="line">    glutCreateWindow(<span class="string">&quot;交互贝塞尔曲线-Bezier&quot;</span>);				 	<span class="comment">//创建带标题的窗口</span></span><br><span class="line">    gluOrtho2D(<span class="number">0</span>, WinW, <span class="number">0</span>, WinH);					<span class="comment">// 区域大小定义  窗口的左下角是（0，0）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;鼠标左键点击 -----&gt; 绘制特征多边形&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  鼠标中键   -----&gt; 画出Bezier曲线&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  鼠标右键   -----&gt; 删除指向特征点&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;鼠标左键拖拽 -----&gt; 重绘Bezier曲线&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    glutDisplayFunc(&amp;display);						<span class="comment">//事件1：显示函数</span></span><br><span class="line">    glutMouseFunc(mouseClick);						<span class="comment">//事件2：鼠标点击</span></span><br><span class="line">    glutMotionFunc(mouseMotion);					<span class="comment">//事件3：鼠标移动</span></span><br><span class="line">    glutMainLoop();									<span class="comment">//让事件保持循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="struct-h"><a href="#struct-h" class="headerlink" title="struct.h"></a>struct.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;gl/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    point() &#123; x = <span class="number">-1</span>, y = <span class="number">-1</span>; &#125;</span><br><span class="line">    point(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1) &#123; x = x1, y = y1; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Bezier-cpp"><a href="#Bezier-cpp" class="headerlink" title="Bezier.cpp"></a>Bezier.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line">point p[maxn][maxn];</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;point&gt;input;</span><br><span class="line"><span class="function">point <span class="title">De_Casteljau</span><span class="params">(<span class="keyword">double</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//递推公式 p[i][0] = input[i](控制点)                   k=0</span></span><br><span class="line"><span class="comment">//	       p[i][k] = (1-t)*p[i][k-1] + t*p[i+1][k-1]	k&gt;0</span></span><br><span class="line">    <span class="keyword">int</span> n = input.size() - <span class="number">1</span>;   <span class="comment">//input n+1个控制点 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                p[i][<span class="number">0</span>].x = input[i].x,</span><br><span class="line">                p[i][<span class="number">0</span>].y = input[i].y;  <span class="comment">//初始化p[i][0]</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p[i][j].x = <span class="number">0</span>, p[i][j].y = <span class="number">0</span>;</span><br><span class="line">        &#125;		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n次Bezier 即： p[0][n] 关于t的表达式 多次传入参数t即可绘制Bezier曲线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            p[i][k].x = (<span class="number">1</span> - t) * p[i][k - <span class="number">1</span>].x + t * p[i + <span class="number">1</span>][k - <span class="number">1</span>].x;</span><br><span class="line">            p[i][k].y = (<span class="number">1</span> - t) * p[i][k - <span class="number">1</span>].y + t * p[i + <span class="number">1</span>][k - <span class="number">1</span>].y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">0</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bezier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">252.0</span> / <span class="number">255</span>, <span class="number">157.0</span> / <span class="number">255</span>, <span class="number">154.0</span> / <span class="number">255</span>);</span><br><span class="line">    glPointSize(<span class="number">2</span>);</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = De_Casteljau(t).x;</span><br><span class="line">        <span class="keyword">double</span> y = De_Casteljau(t).y;</span><br><span class="line">        glVertex2d(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>opengl图形学</category>
      </categories>
      <tags>
        <tag>Bezier曲线</tag>
      </tags>
  </entry>
  <entry>
    <title>Bresenham画线算法</title>
    <url>/2020/12/23/Bresenham%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="Bresenham画线算法"><a href="#Bresenham画线算法" class="headerlink" title="Bresenham画线算法"></a>Bresenham画线算法</h1><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p><img src="/2020/12/23/Bresenham%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/2.png" alt="image-20201223173839501"></p>
<p><img src="/2020/12/23/Bresenham%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/3.png" alt="image-20201223173746808"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Bresenham-cpp"><a href="#Bresenham-cpp" class="headerlink" title="Bresenham.cpp"></a>Bresenham.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;gl/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> site_left = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> site_top = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> WinW = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> WinH = <span class="number">450</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;v[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">249.0</span> / <span class="number">255</span>, <span class="number">205.0</span> / <span class="number">255</span>, <span class="number">173.0</span> / <span class="number">255</span>, <span class="number">0.0</span>);		<span class="comment">//设定清理颜色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);									<span class="comment">//清理缓冲区</span></span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawpixel</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    glVertex2i(x, y);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">249.0</span> / <span class="number">255</span>, <span class="number">205.0</span> / <span class="number">255</span>, <span class="number">173.0</span> / <span class="number">255</span>, <span class="number">0.0</span>);		<span class="comment">//设定清理颜色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);									<span class="comment">//清理缓冲区</span></span><br><span class="line">    </span><br><span class="line">    glColor3f(<span class="number">249.0</span> / <span class="number">255</span>, <span class="number">205.0</span> / <span class="number">255</span>, <span class="number">173.0</span> / <span class="number">255</span>);</span><br><span class="line">    glRectf(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenham</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//只需要检查一个误差项的符号，就可以确定每一列所选的像素。 </span></span><br><span class="line">    <span class="keyword">if</span> (x0 &gt; x1 &amp;&amp; y0 &gt; y1)</span><br><span class="line">        swap(x0, x1), swap(y0, y1);</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x0 &amp;&amp; y1 &lt; y0)</span><br><span class="line">        swap(x0, x1), swap(y0, y1);</span><br><span class="line">    <span class="keyword">int</span> nowx, nowy, dx, dy, e;</span><br><span class="line">    <span class="keyword">double</span> k;</span><br><span class="line">    <span class="keyword">if</span> (x1 != x0)</span><br><span class="line">        k = <span class="keyword">double</span>((y1 - y0) * <span class="number">1.0</span> / (x1 - x0));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        k = <span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(y0,y1); i &lt;= max(y0,y1); i++)</span><br><span class="line">            drawpixel(x0, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(x0, x1); i &lt;= max(x0, x1); i++)</span><br><span class="line">            drawpixel(i, y0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; k &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dx = x1 - x0, dy = y1 - y0, e = -dx;</span><br><span class="line">        nowx = x0, nowy = y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= dx; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            drawpixel(nowx, nowy);</span><br><span class="line">            nowx++, e += <span class="number">2</span> * dy;</span><br><span class="line">            <span class="keyword">if</span> (e &gt;= <span class="number">0</span>)</span><br><span class="line">                nowy++, e -= <span class="number">2</span> * dx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x0, y0), swap(x1, y1);<span class="comment">//swap</span></span><br><span class="line">        dx = x1 - x0, dy = y1 - y0, e = -dx;</span><br><span class="line">        nowx = x0, nowy = y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= dx; i++)</span><br><span class="line">        &#123; </span><br><span class="line">            drawpixel(nowy, nowx);<span class="comment">//(nowy,nowx)</span></span><br><span class="line">            nowx++, e += <span class="number">2</span> * dy;</span><br><span class="line">            <span class="keyword">if</span> (e &gt;= <span class="number">0</span>)</span><br><span class="line">                nowy++, e -= <span class="number">2</span> * dx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; k &gt;= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dx = x1 - x0, dy = y1 - y0, e = -dx;</span><br><span class="line">        nowx = x0, nowy = y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= -dx; i++) <span class="comment">//-dx</span></span><br><span class="line">        &#123;</span><br><span class="line">            drawpixel(nowx, nowy);</span><br><span class="line">            nowx--, e += <span class="number">2</span> * dy;     <span class="comment">//nowx--</span></span><br><span class="line">            <span class="keyword">if</span> (e &gt;= <span class="number">0</span>)</span><br><span class="line">                nowy++, e -= <span class="number">2</span> * (-dx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x0, y0), swap(x1, y1);<span class="comment">//swap</span></span><br><span class="line">        dx = x1 - x0, dy = y1 - y0, e = -dx;</span><br><span class="line">        nowx = x0, nowy = y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= dx; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            drawpixel(nowy, nowx);  <span class="comment">//(nowy,nowx)</span></span><br><span class="line">            nowx++, e -= <span class="number">2</span> * dy;    <span class="comment">//-=</span></span><br><span class="line">            <span class="keyword">if</span> (e &gt;= <span class="number">0</span>)</span><br><span class="line">                nowy--, e -= <span class="number">2</span> * dx;<span class="comment">//nowy--</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseClick</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">//x,y均是以窗口左上角为（0,0）的像素表示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nowx = x, nowy = WinH - y;</span><br><span class="line">    <span class="keyword">if</span> (button == GLUT_LEFT &amp;&amp; state == GLUT_DOWN) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (tot &lt;= <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            v[tot].x = nowx;</span><br><span class="line">            v[tot++].y = nowy;</span><br><span class="line">            <span class="keyword">if</span> (tot == <span class="number">2</span>) </span><br><span class="line">                Bresenham(v[<span class="number">0</span>].x, v[<span class="number">0</span>].y, v[<span class="number">1</span>].x, v[<span class="number">1</span>].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (button == GLUT_MIDDLE_BUTTON &amp;&amp; state == GLUT_DOWN) </span><br><span class="line">    &#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        redraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);	<span class="comment">//显示窗口的缓存和颜色模型</span></span><br><span class="line">    glutInitWindowPosition(site_left, site_top);</span><br><span class="line">    glutInitWindowSize(WinW, WinH);</span><br><span class="line">    glutCreateWindow(<span class="string">&quot;Bresenham算法画直线&quot;</span>);				 	<span class="comment">//创建带标题的窗口</span></span><br><span class="line">    gluOrtho2D(<span class="number">0</span>, WinW, <span class="number">0</span>, WinH);					<span class="comment">// 区域大小定义  窗口的左下角是（0，0）</span></span><br><span class="line"></span><br><span class="line">    glutDisplayFunc(&amp;display);						<span class="comment">//事件1：显示函数</span></span><br><span class="line">    glutMouseFunc(mouseClick);						<span class="comment">//事件2：鼠标点击</span></span><br><span class="line">    <span class="comment">//glutMotionFunc(mouseMotion);					//事件3：鼠标移动</span></span><br><span class="line">    glutMainLoop();									<span class="comment">//让事件保持循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>opengl图形学</category>
      </categories>
      <tags>
        <tag>Bresenham画线算法</tag>
      </tags>
  </entry>
  <entry>
    <title>B样条</title>
    <url>/2020/12/23/B%E6%A0%B7%E6%9D%A1/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="B样条"><a href="#B样条" class="headerlink" title="B样条"></a>B样条</h1><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p><img src="/2020/12/23/B%E6%A0%B7%E6%9D%A1/2.png" alt="image-20201223175754930"></p>
<p><img src="/2020/12/23/B%E6%A0%B7%E6%9D%A1/3.png" alt="image-20201223175843274"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> site_left = <span class="number">1020</span>;</span><br><span class="line"><span class="keyword">int</span> site_top = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> WinW = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> WinH = <span class="number">450</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; input;</span><br><span class="line"><span class="keyword">int</span> nowid;			<span class="comment">//用于鼠标移动</span></span><br><span class="line"><span class="keyword">int</span> k=<span class="number">3</span>;			<span class="comment">//定义阶数k=3阶  k-1次</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> tx, <span class="keyword">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> x = input[i].x, y = input[i].y;</span><br><span class="line">    <span class="keyword">if</span> (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">200.0</span> / <span class="number">255</span>, <span class="number">200.0</span> / <span class="number">255</span>, <span class="number">169.0</span> / <span class="number">255</span>, <span class="number">0.0</span>);		<span class="comment">//设定清理颜色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);									<span class="comment">//清理缓冲区 </span></span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawOnePoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">    glPointSize(<span class="number">4</span>);</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    glVertex2d(x, y);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">    glEnable(GL_LINE_SMOOTH);</span><br><span class="line">    glLineWidth(<span class="number">1</span>);</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    glVertex2i(x1, y1);</span><br><span class="line">    glVertex2i(x2, y2);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//缓冲区重绘</span></span><br><span class="line">    glClearColor(<span class="number">200.0</span> / <span class="number">255</span>, <span class="number">200.0</span> / <span class="number">255</span>, <span class="number">169.0</span> / <span class="number">255</span>, <span class="number">0.0</span>);		<span class="comment">//设定清理颜色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="comment">//控制点重绘</span></span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">    glPointSize(<span class="number">4</span>);</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= input.size() - <span class="number">1</span>; i++)</span><br><span class="line">        glVertex2d(input[i].x, input[i].y);</span><br><span class="line">    glEnd();</span><br><span class="line">    <span class="comment">//特征多边形重绘</span></span><br><span class="line">    glLineWidth(<span class="number">1</span>);</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= input.size() - <span class="number">1</span>; i++)</span><br><span class="line">        drawLine(input[i - <span class="number">1</span>].x, input[i - <span class="number">1</span>].y, input[i].x, input[i].y);</span><br><span class="line">    glEnd();</span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">de_Boor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">de_Boor_id</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseClick</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> nowx, <span class="keyword">int</span> nowy)</span> <span class="comment">//x,y均是以窗口左上角为（0,0）的像素表示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    x = nowx, y = WinH - nowy;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(i, x, y))</span><br><span class="line">        &#123;</span><br><span class="line">            id = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="keyword">if</span> (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            drawOnePoint(x, y);</span><br><span class="line">            input.push_back(point(x, y));</span><br><span class="line">            nowid = input.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nowid &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                drawLine(input[nowid - <span class="number">1</span>].x, input[nowid - <span class="number">1</span>].y, input[nowid].x, input[nowid].y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (input.size() &gt;= k) de_Boor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> nowid = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//画出B样条</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (button == GLUT_MIDDLE_BUTTON &amp;&amp; state == GLUT_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        redraw();</span><br><span class="line">        <span class="keyword">if</span> (input.size() &gt;= k) de_Boor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// delete</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (button == GLUT_RIGHT_BUTTON &amp;&amp; state == GLUT_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nowid = id;</span><br><span class="line">            input.erase(input.begin() + nowid);</span><br><span class="line">            redraw();</span><br><span class="line">            <span class="keyword">if</span> (input.size() &gt;= k) </span><br><span class="line">                de_Boor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMotion</span><span class="params">(<span class="keyword">int</span> nowx, <span class="keyword">int</span> nowy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = nowx, y = WinH - nowy;</span><br><span class="line">    input[nowid].x = x, input[nowid].y = y;</span><br><span class="line">    <span class="keyword">if</span> (input.size() &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        redraw();</span><br><span class="line">        de_Boor();</span><br><span class="line">        de_Boor_id(nowid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyBoards</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">107</span>||key == <span class="number">75</span>) <span class="comment">//k || K</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入k值:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (input.size() &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B样条已重绘&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            redraw();</span><br><span class="line">            de_Boor();</span><br><span class="line">        &#125;		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);	<span class="comment">//显示窗口的缓存和颜色模型</span></span><br><span class="line">    glutInitWindowPosition(site_left, site_top);</span><br><span class="line">    glutInitWindowSize(WinW, WinH);</span><br><span class="line">    glutCreateWindow(<span class="string">&quot;交互贝塞尔曲线-Bezier&quot;</span>);				 	<span class="comment">//创建带标题的窗口</span></span><br><span class="line">    gluOrtho2D(<span class="number">0</span>, WinW, <span class="number">0</span>, WinH);					<span class="comment">// 区域大小定义  窗口的左下角是（0，0）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 鼠标左键点击  -----&gt; 绘制特征多边形&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   鼠标中键    -----&gt; 画出B样条曲线&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   鼠标右键    -----&gt; 删除指向特征点&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 鼠标左键拖拽  -----&gt; 重绘B样条曲线&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;键盘输入k或者K -----&gt; 指定k值并重绘&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    glutDisplayFunc(&amp;display);						<span class="comment">//事件1：显示函数</span></span><br><span class="line">    glutMouseFunc(mouseClick);						<span class="comment">//事件2：鼠标点击</span></span><br><span class="line">    glutMotionFunc(mouseMotion);					<span class="comment">//事件3：鼠标移动</span></span><br><span class="line">    glutKeyboardFunc(&amp;keyBoards);					<span class="comment">//事件4：监听键盘</span></span><br><span class="line">    glutMainLoop();									<span class="comment">//让事件保持循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="struct-h"><a href="#struct-h" class="headerlink" title="struct.h"></a>struct.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;gl/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    point() &#123; x = <span class="number">-1</span>, y = <span class="number">-1</span>; &#125;</span><br><span class="line">    point(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1) &#123; x = x1, y = y1; &#125;</span><br><span class="line">    point <span class="keyword">operator</span> * (<span class="keyword">double</span> t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> point(t * x, t * y);</span><br><span class="line">    &#125;</span><br><span class="line">    point <span class="keyword">operator</span> + (point p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> point(x + p.x, y + p.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="B样条-cpp"><a href="#B样条-cpp" class="headerlink" title="B样条.cpp"></a>B样条.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;point&gt;input;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; T;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; P;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_Bline</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt; out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">252.0</span> / <span class="number">255</span>, <span class="number">157.0</span> / <span class="number">255</span>, <span class="number">154.0</span> / <span class="number">255</span>);</span><br><span class="line">    glPointSize(<span class="number">1</span>);</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; out.size(); i++)</span><br><span class="line">        glVertex2d(out[i].x, out[i].y);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">de_Boor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;point&gt; next;</span><br><span class="line">    T.clear(); ans.clear(); P.clear();</span><br><span class="line">    point tmp;</span><br><span class="line">    <span class="keyword">int</span> n = input.size()<span class="number">-1</span>; </span><br><span class="line">    <span class="comment">//所以控制点数为 n+1</span></span><br><span class="line">    <span class="comment">//区间均匀B样条</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + k; i++) </span><br><span class="line">        T.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = k - <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//枚举区间j </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> t = T[j]; t &lt; T[j + <span class="number">1</span>]; t += <span class="number">0.001</span>) <span class="comment">//先把t固定在区间[t j,t j+1]上</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//r=0时,0次Pi(t) = p[i]  并且  i= j - k + 1; i &lt;= j</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - k + <span class="number">1</span>; i &lt;= j; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push_back(input[i]);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//r= 1 到 k-1 时,即r次Pi(t)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= k - <span class="number">1</span>; r++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = j - k + r + <span class="number">1</span>; i &lt;= j; i++) </span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = P[i - (j - k + r + <span class="number">1</span>) + <span class="number">1</span>] * ((t - T[i]) / (T[i + k - r] - T[i])) + P[i - (j - k + r + <span class="number">1</span>)] * ((T[i + k - r] - t) / (T[i + k - r] - T[i])); <span class="comment">//* (p[i + 1][r - 1]);</span></span><br><span class="line">                    next.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                P = next;</span><br><span class="line">                next.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后为r次P</span></span><br><span class="line">            ans.push_back(P[<span class="number">0</span>]);</span><br><span class="line">            P.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    draw_Bline(ans);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">de_Boor_id</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;point&gt; next;</span><br><span class="line">    ans.clear();</span><br><span class="line">    point tmp;</span><br><span class="line">    <span class="keyword">int</span> n = input.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//所以控制点数为 n+1</span></span><br><span class="line">    <span class="keyword">int</span> a = max(id, k - <span class="number">1</span>), b = min(id + k - <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">//会影响到的区间数目</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = a; j &lt;= b; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> t = T[j]; t &lt; T[j + <span class="number">1</span>]; t += <span class="number">0.001</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - k + <span class="number">1</span>; i &lt;= j; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                P.push_back(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= k - <span class="number">1</span>; r++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = j - k + r + <span class="number">1</span>; i &lt;= j; i++) &#123;</span><br><span class="line">                    tmp = P[i - (j - k + r + <span class="number">1</span>) + <span class="number">1</span>] * ((t - T[i]) / (T[i + k - r] - T[i])) + P[i - (j - k + r + <span class="number">1</span>)] * ((T[i + k - r] - t) / (T[i + k - r] - T[i])); <span class="comment">//* (p[i + 1][r - 1]);</span></span><br><span class="line">                    next.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                P = next;</span><br><span class="line">                next.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(P[<span class="number">0</span>]);</span><br><span class="line">            P.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    draw_Bline(ans);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>opengl图形学</category>
      </categories>
      <tags>
        <tag>B样条</tag>
      </tags>
  </entry>
  <entry>
    <title>sort,map,set</title>
    <url>/2020/12/09/STL%E6%8E%92%E5%BA%8F%E5%92%8Cmap/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<p><img src="/2020/12/09/STL%E6%8E%92%E5%BA%8F%E5%92%8Cmap/1.png"></p>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><h2 id="基本用法—对类型为T的数组"><a href="#基本用法—对类型为T的数组" class="headerlink" title="基本用法—对类型为T的数组"></a>基本用法—对类型为T的数组</h2><ol>
<li><p>默认从小到大排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(a,a+n);</span><br></pre></td></tr></table></figure>
</li>
<li><p>从大到小排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(a,a+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="对struct类型数组进行排序"><a href="#对struct类型数组进行排序" class="headerlink" title="对struct类型数组进行排序"></a>对struct类型数组进行排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rank</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> rank1 &amp; s) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (score!=s.score) <span class="keyword">return</span> score &gt; s.score; <span class="comment">//首先 按score从大--&gt;小</span></span><br><span class="line">        <span class="keyword">return</span> name &lt; s.name;<span class="comment">//其次 按name字典序从小--&gt;大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">rank r[<span class="number">1000</span>];</span><br><span class="line">sort(r,r+count);</span><br></pre></td></tr></table></figure>

<h2 id="struct配合map自定义排序顺序-给元素添加一个val值-按val进行排序"><a href="#struct配合map自定义排序顺序-给元素添加一个val值-按val进行排序" class="headerlink" title="struct配合map自定义排序顺序(给元素添加一个val值,按val进行排序)"></a>struct配合map自定义排序顺序(给元素添加一个val值,按val进行排序)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; hua_val;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; name_val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> hua;<span class="comment">//卡牌的花色</span></span><br><span class="line">    <span class="keyword">char</span> name;<span class="comment">//卡牌的牌面</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> card &amp; s) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hua!=s.hua) <span class="keyword">return</span> hua_val[hua] &lt; hua_val[s.hua];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> name_val[name] &lt; name_val[s.name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hua_val[<span class="string">&#x27;C&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    hua_val[<span class="string">&#x27;D&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    hua_val[<span class="string">&#x27;S&#x27;</span>] = <span class="number">3</span>;	</span><br><span class="line">    hua_val[<span class="string">&#x27;H&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//用C,D,S,H分别表示梅花，方片，黑桃，红桃，即其单词首字母</span></span><br><span class="line">    <span class="comment">//规定花色（梅花）&lt;（方片）&lt;（黑桃）&lt;（红桃）</span></span><br><span class="line">    name_val[<span class="string">&#x27;2&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;3&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;4&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;5&#x27;</span>] = <span class="number">4</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;6&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;7&#x27;</span>] = <span class="number">6</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;8&#x27;</span>] = <span class="number">7</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;9&#x27;</span>] = <span class="number">8</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;T&#x27;</span>] = <span class="number">9</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;J&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;Q&#x27;</span>] = <span class="number">11</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;K&#x27;</span>] = <span class="number">12</span>;</span><br><span class="line">    name_val[<span class="string">&#x27;A&#x27;</span>] = <span class="number">13</span>;</span><br><span class="line">    <span class="comment">//规定2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; T &lt; J &lt; Q &lt; K &lt; A</span></span><br><span class="line">    card puke [<span class="number">13</span>];</span><br><span class="line">    sort(puke,puke+<span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量map声明,而不是声明一个空的map随后再赋值</span></span><br><span class="line">const map&lt;char,int&gt; hua_val(&#123;</span><br><span class="line">    &#123;<span class="string">&#x27;C&#x27;</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;D&#x27;</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;S&#x27;</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;H&#x27;</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>如果涉及到大量的insert数据,erase数据,find数据,考虑用stl中的平衡二叉树数据结构会很方便. </p>
<p>上述操作都能在 log(n)复杂度完成.</p>
<p>体现在stl中有4种容器 : <strong>multiset</strong>  <strong>set  multimap  map</strong></p>
<p>都会<strong>自动维持有序性</strong></p>
</blockquote>
<h1 id="set和multiset"><a href="#set和multiset" class="headerlink" title="set和multiset"></a>set和multiset</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="comment">//缺省排序规则 表达式&quot;a&lt;b&quot;为ture,则a排在b前面</span></span><br><span class="line"><span class="comment">//可用 st.insert() st.erase() st.find() 复杂度均log(n)</span></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">st.insert(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">if</span>(st.find(<span class="number">1</span>)!=s.end())</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the element is in set&quot;</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s.begin();it!=s.end();it++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*it);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : s)<span class="comment">//c++11 新特性</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">s.erase(val);</span><br><span class="line">s.clear();</span><br></pre></td></tr></table></figure>

<h1 id="map和multimap"><a href="#map和multimap" class="headerlink" title="map和multimap"></a>map和multimap</h1><blockquote>
<p>map中使用结构体需要重写比较方法 &lt; ,因为要维持其有序性.</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Southerland-Hodgeman 多边形裁剪</title>
    <url>/2020/12/23/Southerland-Hodgeman-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A3%81%E5%89%AA/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="Southerland-Hodgeman多边形裁剪"><a href="#Southerland-Hodgeman多边形裁剪" class="headerlink" title="Southerland-Hodgeman多边形裁剪"></a>Southerland-Hodgeman多边形裁剪</h1><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p><img src="/2020/12/23/Southerland-Hodgeman-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A3%81%E5%89%AA/2.png" alt="image-20201223174559425"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="main-cpp-vis改进-可以裁剪所有凹多边形"><a href="#main-cpp-vis改进-可以裁剪所有凹多边形" class="headerlink" title="main.cpp (vis改进,可以裁剪所有凹多边形)"></a>main.cpp (vis改进,可以裁剪所有凹多边形)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> site_left = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> site_top = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> WinW = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> WinH = <span class="number">450</span>;</span><br><span class="line"><span class="keyword">int</span> vis[WinW][WinH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">200.0</span> / <span class="number">255</span>, <span class="number">200.0</span> / <span class="number">255</span>, <span class="number">169.0</span> / <span class="number">255</span>, <span class="number">0.0</span>);		<span class="comment">//设定清理颜色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);									<span class="comment">//清理缓冲区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">    glRectf(<span class="number">100</span>, <span class="number">80</span>, <span class="number">400</span>, <span class="number">360</span>);								<span class="comment">//左下 右上（横、纵左边） </span></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;point&gt;now;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;point&gt;out;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;line&gt;ans;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Polygon_clipping</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> already = <span class="literal">false</span>;<span class="comment">//特征多边形绘制结束之后，屏蔽鼠标操作</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> cnt, nowid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> tx, <span class="keyword">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> x = now[i].x, y = now[i].y;</span><br><span class="line">    <span class="keyword">if</span> (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">double</span> x0, <span class="keyword">double</span> y0, <span class="keyword">double</span> x1, <span class="keyword">double</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">252.0</span> / <span class="number">255</span>, <span class="number">157.0</span> / <span class="number">255</span>, <span class="number">154.0</span> / <span class="number">255</span>);</span><br><span class="line">    glLineWidth(<span class="number">2</span>);</span><br><span class="line">    glEnable(GL_LINE_SMOOTH);</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    glVertex2d(x0, y0);</span><br><span class="line">    glVertex2d(x1, y1);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseClick</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> nowx, <span class="keyword">int</span> nowy)</span> <span class="comment">//x,y均是以窗口左上角为（0,0）的像素表示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = nowx, y = WinH - nowy;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">-1</span>; <span class="comment">//是否封闭，即回到起始点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(now.size()); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(i, x, y)) </span><br><span class="line">        &#123;</span><br><span class="line">            id = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//already 用来 特征多边形绘制结束之后，屏蔽鼠标操作</span></span><br><span class="line">    <span class="keyword">if</span> (button == GLUT_LEFT &amp;&amp; state == GLUT_DOWN) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">-1</span> &amp;&amp; !already) </span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            now.push_back(point(x, y));</span><br><span class="line">            nowid = now.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nowid &gt;= <span class="number">1</span>) </span><br><span class="line">                drawLine(now[nowid - <span class="number">1</span>].x, now[nowid - <span class="number">1</span>].y, now[nowid].x, now[nowid].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (id != <span class="number">-1</span> &amp;&amp; !already) </span><br><span class="line">        &#123;</span><br><span class="line">            already = <span class="literal">true</span>;</span><br><span class="line">            nowid = now.size() - <span class="number">1</span>;</span><br><span class="line">            drawLine(now[nowid].x, now[nowid].y, now[id].x, now[id].y);</span><br><span class="line">            Polygon_clipping();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);	<span class="comment">//显示窗口的缓存和颜色模型</span></span><br><span class="line">    glutInitWindowPosition(site_left, site_top);</span><br><span class="line">    glutInitWindowSize(WinW, WinH);</span><br><span class="line">    glutCreateWindow(<span class="string">&quot;Southerland多边形裁剪算法&quot;</span>);				 	<span class="comment">//创建带标题的窗口</span></span><br><span class="line">    gluOrtho2D(<span class="number">0</span>, WinW, <span class="number">0</span>, WinH);					<span class="comment">// 区域大小定义  窗口的左下角是（0，0）</span></span><br><span class="line"></span><br><span class="line">    glutDisplayFunc(&amp;display);						<span class="comment">//事件1：显示函数</span></span><br><span class="line">    glutMouseFunc(mouseClick);						<span class="comment">//事件2：鼠标点击</span></span><br><span class="line">    <span class="comment">//glutMotionFunc(mouseMotion);					//事件3：鼠标移动</span></span><br><span class="line">    glutMainLoop();									<span class="comment">//让事件保持循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="struct-h"><a href="#struct-h" class="headerlink" title="struct.h"></a>struct.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;gl/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    point() &#123; x = <span class="number">-1</span>, y = <span class="number">-1</span>; &#125;</span><br><span class="line">    point(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1) &#123; x = x1, y = y1; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    point a, b;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    line() &#123;&#125;;</span><br><span class="line">    line(point x, point y) &#123; a = x, b = y; &#125;</span><br><span class="line">    line(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2,<span class="built_in">string</span> s) &#123; a.x = x1, a.y = y1, b.x = x2, b.y = y2,name=s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Southerland-cpp"><a href="#Southerland-cpp" class="headerlink" title="Southerland.cpp"></a>Southerland.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt;now;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt;out;</span><br><span class="line"><span class="built_in">vector</span>&lt;line&gt;ans;</span><br><span class="line"><span class="function">line <span class="title">left_line</span><span class="params">(<span class="number">100</span>, <span class="number">80</span>, <span class="number">100</span>, <span class="number">360</span>,<span class="string">&quot;left&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">line <span class="title">right_line</span><span class="params">(<span class="number">400</span>, <span class="number">80</span>, <span class="number">400</span>, <span class="number">360</span>,<span class="string">&quot;right&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">line <span class="title">top_line</span><span class="params">(<span class="number">100</span>, <span class="number">360</span>, <span class="number">400</span>, <span class="number">360</span>,<span class="string">&quot;top&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">line <span class="title">bottom_line</span><span class="params">(<span class="number">100</span>, <span class="number">80</span>, <span class="number">400</span>, <span class="number">80</span>,<span class="string">&quot;bottom&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> WinW = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> WinH = <span class="number">450</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> vis[WinW][WinH];</span><br><span class="line"><span class="comment">//Bresenham画线算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawpixel</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255);</span></span><br><span class="line">    vis[x][y]++;</span><br><span class="line">    glColor3f(<span class="number">249.0</span> / <span class="number">255</span>, <span class="number">205.0</span> / <span class="number">255</span>, <span class="number">173.0</span> / <span class="number">255</span>);</span><br><span class="line">    glPointSize(<span class="number">3</span>);</span><br><span class="line">    glEnable(GL_POINT_SMOOTH);</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    glVertex2i(x, y);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenham</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x0 &gt; x1 &amp;&amp; y0 &gt; y1)</span><br><span class="line">        swap(x0, x1), swap(y0, y1);</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x0 &amp;&amp; y1 &lt; y0)</span><br><span class="line">        swap(x0, x1), swap(y0, y1);</span><br><span class="line">    <span class="keyword">int</span> nowx, nowy, dx, dy, e;</span><br><span class="line">    <span class="keyword">double</span> k;</span><br><span class="line">    <span class="keyword">if</span> (x1 != x0)</span><br><span class="line">        k = <span class="keyword">double</span>((y1 - y0) * <span class="number">1.0</span> / (x1 - x0));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        k = <span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(y0, y1); i &lt;= max(y0, y1); i++)</span><br><span class="line">            drawpixel(x0, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(x0, x1); i &lt;= max(x0, x1); i++)</span><br><span class="line">            drawpixel(i, y0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; k &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dx = x1 - x0, dy = y1 - y0, e = -dx;</span><br><span class="line">        nowx = x0, nowy = y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= dx; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            drawpixel(nowx, nowy);</span><br><span class="line">            nowx++, e += <span class="number">2</span> * dy;</span><br><span class="line">            <span class="keyword">if</span> (e &gt;= <span class="number">0</span>)</span><br><span class="line">                nowy++, e -= <span class="number">2</span> * dx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x0, y0), swap(x1, y1);<span class="comment">//swap</span></span><br><span class="line">        dx = x1 - x0, dy = y1 - y0, e = -dx;</span><br><span class="line">        nowx = x0, nowy = y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= dx; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            drawpixel(nowy, nowx);<span class="comment">//(nowy,nowx)</span></span><br><span class="line">            nowx++, e += <span class="number">2</span> * dy;</span><br><span class="line">            <span class="keyword">if</span> (e &gt;= <span class="number">0</span>)</span><br><span class="line">                nowy++, e -= <span class="number">2</span> * dx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; k &gt;= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dx = x1 - x0, dy = y1 - y0, e = -dx;</span><br><span class="line">        nowx = x0, nowy = y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= -dx; i++) <span class="comment">//-dx</span></span><br><span class="line">        &#123;</span><br><span class="line">            drawpixel(nowx, nowy);</span><br><span class="line">            nowx--, e += <span class="number">2</span> * dy;     <span class="comment">//nowx--</span></span><br><span class="line">            <span class="keyword">if</span> (e &gt;= <span class="number">0</span>)</span><br><span class="line">                nowy++, e -= <span class="number">2</span> * (-dx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x0, y0), swap(x1, y1);<span class="comment">//swap</span></span><br><span class="line">        dx = x1 - x0, dy = y1 - y0, e = -dx;</span><br><span class="line">        nowx = x0, nowy = y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= dx; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            drawpixel(nowy, nowx);  <span class="comment">//(nowy,nowx)</span></span><br><span class="line">            nowx++, e -= <span class="number">2</span> * dy;    <span class="comment">//-=</span></span><br><span class="line">            <span class="keyword">if</span> (e &gt;= <span class="number">0</span>)</span><br><span class="line">                nowy--, e -= <span class="number">2</span> * dx;<span class="comment">//nowy--</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redraw</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*glColor3f(249.0 / 255, 205.0 / 255, 173.0 / 255);//区域线段颜色</span></span><br><span class="line"><span class="comment">	glLineWidth(3);</span></span><br><span class="line"><span class="comment">	glEnable(GL_LINE_SMOOTH);</span></span><br><span class="line"><span class="comment">	glBegin(GL_LINES);</span></span><br><span class="line"><span class="comment">	glVertex2d(x1, y1);</span></span><br><span class="line"><span class="comment">	glVertex2d(x2, y2);</span></span><br><span class="line"><span class="comment">	glEnd();*/</span></span><br><span class="line">    Bresenham(x1, y1, x2, y2);</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">point <span class="title">focus</span><span class="params">(point S, point P, line wall)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求s--p与边界的交点</span></span><br><span class="line">    point p;</span><br><span class="line">    <span class="keyword">if</span> (wall.a.x == wall.b.x) </span><br><span class="line">    &#123;</span><br><span class="line">        p.x = wall.a.x;</span><br><span class="line">        p.y = S.y + (wall.a.x - S.x) * (P.y - S.y) / (P.x - S.x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        p.y = wall.a.y;</span><br><span class="line">        p.x = S.x + (wall.a.y - S.y) * (P.x - S.x) / (P.y - S.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Inside</span><span class="params">(point x, line wall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wall.name == <span class="string">&quot;left&quot;</span> &amp;&amp; x.x &gt; wall.a.x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (wall.name == <span class="string">&quot;right&quot;</span> &amp;&amp; x.x &lt; wall.b.x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (wall.name == <span class="string">&quot;top&quot;</span> &amp;&amp; x.y &lt; wall.a.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (wall.name == <span class="string">&quot;bottom&quot;</span> &amp;&amp; x.y &gt; wall.a.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sutherland_Hodgman</span><span class="params">(line wall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out.clear();</span><br><span class="line">    point S, P;</span><br><span class="line">    S = now[now.size() - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; now.size(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        P = now[i];</span><br><span class="line">        <span class="keyword">if</span> (Inside(S, wall))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Inside(P, wall)) </span><br><span class="line">            &#123; <span class="comment">//①S 内 P 内</span></span><br><span class="line">                out.push_back(P);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;<span class="comment">//②S 内 P外</span></span><br><span class="line">                out.push_back(focus(S, P, wall)); <span class="comment">// SP</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Inside(P, wall)) </span><br><span class="line">        &#123; <span class="comment">//③ P 内 S 外</span></span><br><span class="line">            out.push_back(focus(S, P, wall));</span><br><span class="line">            out.push_back(P);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//④ S 外 P 外 不输出</span></span><br><span class="line">        S = P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Polygon_clipping</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sutherland_Hodgman(left_line);</span><br><span class="line">    now = out;</span><br><span class="line">    Sutherland_Hodgman(right_line);</span><br><span class="line">    now = out;</span><br><span class="line">    Sutherland_Hodgman(top_line);</span><br><span class="line">    now = out;</span><br><span class="line">    Sutherland_Hodgman(bottom_line);</span><br><span class="line">    <span class="comment">//用Bresenham算法画线 并且记录vis【】【】数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; out.size() - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        redraw(out[i].x, out[i].y, out[i + <span class="number">1</span>].x, out[i + <span class="number">1</span>].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (out.size() &gt; <span class="number">2</span>) </span><br><span class="line">        redraw(out[<span class="number">0</span>].x, out[<span class="number">0</span>].y, out[out.size() - <span class="number">1</span>].x, out[out.size() - <span class="number">1</span>].y);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过vis数组 用边界颜色 覆盖多余的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;WinW;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; WinH; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i][j] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; vis[i][j] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">                glPointSize(<span class="number">3</span>);</span><br><span class="line">                glEnable(GL_POINT_SMOOTH);</span><br><span class="line">                glBegin(GL_POINTS);</span><br><span class="line">                glVertex2i(i, j);</span><br><span class="line">                glEnd();</span><br><span class="line">                glFlush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//描 端点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; out.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        glColor3f(<span class="number">249.0</span> / <span class="number">255</span>, <span class="number">205.0</span> / <span class="number">255</span>, <span class="number">173.0</span> / <span class="number">255</span>);</span><br><span class="line">        glPointSize(<span class="number">4</span>);</span><br><span class="line">        glEnable(GL_POINT_SMOOTH);</span><br><span class="line">        glBegin(GL_POINTS);</span><br><span class="line">        glVertex2i(out[i].x, out[i].y);</span><br><span class="line">        glEnd();</span><br><span class="line">        glFlush();	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>opengl图形学</category>
      </categories>
      <tags>
        <tag>Southerland-Hodgeman 多边形裁剪</tag>
      </tags>
  </entry>
  <entry>
    <title>bfs及其应用</title>
    <url>/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><blockquote>
<p>篇幅问题 只给出核心代码 省略一些不必要的声明和main()</p>
</blockquote>
<h2 id="BFS板子"><a href="#BFS板子" class="headerlink" title="BFS板子"></a>BFS板子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以输出路径的5×5迷宫为例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//省略重载point(x,y)和==</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123; <span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">5</span>][<span class="number">5</span>];<span class="comment">//-1表可以走,-2表不能走</span></span><br><span class="line">point path[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(point a, point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>, b.x, b.y);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    output(a, path[b.x][b.y]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>, b.x, b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;point&gt; q;</span><br><span class="line">    point now = a;</span><br><span class="line">    dis[now.x][now.y] = <span class="number">0</span>;</span><br><span class="line">    q.push(now);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        now = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span> (now == b)</span><br><span class="line">        &#123;</span><br><span class="line">            output(a, b);</span><br><span class="line">            <span class="keyword">return</span> dis[now.x][now.y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> new_x = now.x + dx[i],new_y = now.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;=<span class="number">4</span> &amp;&amp; new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;=<span class="number">4</span> &amp;&amp; dis[new_x][new_y]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(point(new_x, new_y));</span><br><span class="line">                dis[new_x][new_y] = dis[now.x][now.y] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                path[new_x][new_y] = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="倒水问题"><a href="#倒水问题" class="headerlink" title="倒水问题"></a>倒水问题</h2><p><img src="/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/1.png" alt="image-20201214102954955"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A, B, C;</span><br><span class="line"><span class="comment">//map中使用struct需要重载 &lt; 进行排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;<span class="comment">//省略重载state(a,b)</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> state&amp; p) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a != p.a)<span class="keyword">return</span> a &lt; p.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; p.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;state, state&gt; from; </span><br><span class="line"><span class="built_in">map</span>&lt;state, <span class="built_in">string</span>&gt; step;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(state now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now.a == <span class="number">0</span> &amp;&amp; now.b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;&lt;%d,%d&gt;\n&quot;, now.a, now.b);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    output(from[now]);</span><br><span class="line">    <span class="comment">//printf(&quot;-&gt;&lt;%d,%d&gt;&quot;, now.a, now.b);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; step[now] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;state&gt; q;</span><br><span class="line">    <span class="function">state <span class="title">now</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    q.push(now);</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        now = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span> (now.a == C || now.b == C)</span><br><span class="line">        &#123;</span><br><span class="line">            output(now);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如何记录之前状态是否已经存在了呢? 类似迷宫 已经走过</span></span><br><span class="line">        <span class="comment">//map&lt;state, state&gt; from;</span></span><br><span class="line">        <span class="keyword">if</span> (now.a &lt; A)<span class="comment">//①fill A</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">state <span class="title">after</span><span class="params">(A, now.b)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (from.find(after) == from.end())</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(after);</span><br><span class="line">                </span><br><span class="line">                from[after] = now;</span><br><span class="line">                step[after] = <span class="string">&quot;fill A&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略②empty A</span></span><br><span class="line">        <span class="keyword">if</span> (now.a &gt; <span class="number">0</span>)<span class="comment">//③pour A B B满orA空</span></span><br><span class="line">        &#123;</span><br><span class="line">            state after;</span><br><span class="line">            <span class="keyword">if</span> (now.a + now.b &lt;= B)</span><br><span class="line">                after.a = <span class="number">0</span>, after.b = now.a + now.b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                after.a = now.a + now.b - B, after.b = B;</span><br><span class="line">            <span class="keyword">if</span> (from.find(after) == from.end())</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(after);</span><br><span class="line"></span><br><span class="line">                from[after] = now;</span><br><span class="line">                step[after] = <span class="string">&quot;pour A B&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略关于B的相同操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; C)</span><br><span class="line">    &#123;</span><br><span class="line">        from.clear();</span><br><span class="line">        step.clear();</span><br><span class="line">        bfs();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;success&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="超级源点问题"><a href="#超级源点问题" class="headerlink" title="超级源点问题"></a>超级源点问题</h2><blockquote>
<p>csp 201409-4 “最佳配餐”</p>
</blockquote>
<p><img src="/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/3.png" alt="image-20201214142559692"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化queue的时候将所有分店都push进去,bfs结束条件改为cnt==n*n 即网格中除了障碍物全部都遍历到.</span></span><br><span class="line"><span class="comment">//然后每个网格点都有了最小的dis,与记录的客户数目相乘算得结果即可.</span></span><br><span class="line"><span class="comment">//注:①ans要用long long储存②由图可知下标从1~n </span></span><br><span class="line"><span class="built_in">queue</span>&lt;point&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">        q.pop();</span><br><span class="line">    point now;</span><br><span class="line">    <span class="keyword">int</span> cnt = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">    &#123;<span class="comment">//读入的时候 vector v 记录一下分店的数目</span></span><br><span class="line">        now = v[i];</span><br><span class="line">        dis[now.x][now.y] = <span class="number">0</span>;</span><br><span class="line">        q.push(now);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        now = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span> (cnt == n * n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> new_x = now.x + dx[i],new_y = now.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (new_x&gt;=<span class="number">1</span>&amp;&amp;new_x&lt;=n &amp;&amp; new_y&gt;=<span class="number">1</span>&amp;&amp;new_y&lt;=n &amp;&amp; dis[new_x][new_y]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(point(new_x, new_y));</span><br><span class="line">                dis[new_x][new_y] = dis[now.x][now.y] + <span class="number">1</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="有特殊点的bfs"><a href="#有特殊点的bfs" class="headerlink" title="有特殊点的bfs"></a>有特殊点的bfs</h2><blockquote>
<p>csp 201403-4 “无线网络”</p>
</blockquote>
<p><img src="/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/4.png" alt="image-20201214161355466"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> dis, k;</span><br><span class="line">    Node() &#123; x = <span class="number">-1</span>, y = <span class="number">-1</span>, dis = <span class="number">0</span>, k = <span class="number">0</span>; &#125;</span><br><span class="line">    Node(<span class="keyword">long</span> <span class="keyword">long</span> _x, <span class="keyword">long</span> <span class="keyword">long</span> _y, <span class="keyword">int</span> _s, <span class="keyword">int</span> _k)</span><br><span class="line">    &#123;	x = _x, y = _y, dis = _s, k = _k;	&#125;</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">        q.pop();</span><br><span class="line">    Node now = node[<span class="number">1</span>];</span><br><span class="line">    vis[begin] = <span class="number">1</span>;</span><br><span class="line">    q.push(now);</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        now = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span> (now.x == node[end].x&amp;&amp;now.y == node[end].y)</span><br><span class="line">            <span class="keyword">return</span> now.dis - <span class="number">1</span>; <span class="comment">//中转个数=距离-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len;<span class="comment">// 下一跳可以选择node下标范围</span></span><br><span class="line">        <span class="keyword">if</span> (now.k == k) len = n;<span class="comment">//通过下一跳的范围限制 增设的路由器至多k个</span></span><br><span class="line">        <span class="keyword">else</span> len = n + m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; ((now.x - node[i].x) * (now.x - node[i].x) </span><br><span class="line">             + (now.y - node[i].y) * (now.y - node[i].y) &lt;= r * r))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp_k;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">                    tmp_k = now.k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp_k = now.k;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                q.push(Node(node[i].x, node[i].y, now.dis + <span class="number">1</span>, tmp_k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本题明确了有n个点,显然用一维数组struct node[N]保存更为方便.</p>
<p>回忆之前 dis[] []二维数据  vis是隐藏在了dis[] []的数值里面,即== -1 的时候认为!vis . </p>
<p>故本例中增加了vis[N]数组用来记录是否访问过.    len的界限 是解决本题的关键.</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>csp12-13收获</title>
    <url>/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<p><img src="/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/1.png" alt="image"></p>
<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="找到-gt-k的第一个位置"><a href="#找到-gt-k的第一个位置" class="headerlink" title="找到&gt;=k的第一个位置"></a>找到&gt;=k的第一个位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n,ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到-lt-k的最后一个位置"><a href="#找到-lt-k的最后一个位置" class="headerlink" title="找到&lt;=k的最后一个位置"></a>找到&lt;=k的最后一个位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse_lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到-k的第一个位置"><a href="#找到-k的第一个位置" class="headerlink" title="找到==k的第一个位置"></a>找到==k的第一个位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n,ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt; k)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到-k的最后一个位置"><a href="#找到-k的最后一个位置" class="headerlink" title="找到==k的最后一个位置"></a>找到==k的最后一个位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n,ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; k)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-整数二分-四个数列和为0"><a href="#例题-整数二分-四个数列和为0" class="headerlink" title="例题(整数二分):四个数列和为0"></a>例题(整数二分):四个数列和为0</h2><p><img src="/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/5.png" alt="image-20201216151559467"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先四重枚举肯定超时,所以要减少枚举的次数.</span></span><br><span class="line"><span class="comment">//先枚举a和b数组,然后将枚举结果放到一个新的数组ab,</span></span><br><span class="line"><span class="comment">//再枚举c和d数组,然后枚举的时候计算它的相反数在ab中出现几次(有序数组last位置-first位置)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N], b[N], c[N], d[N],ab[N*N];</span><br><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n*n, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ab[mid] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ab[mid] &lt; x)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下标从1开始,找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n*n, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ab[mid] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ab[mid] &gt; x)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i] &gt;&gt; d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ab[(i<span class="number">-1</span>) * n + j] = a[i] + b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    sort(ab + <span class="number">1</span>, ab + <span class="number">1</span> + n * n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> key = -(c[i] + d[j]);</span><br><span class="line">            <span class="keyword">int</span> l = find_first(key), r = find_last(key);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="number">-1</span>)</span><br><span class="line">                ans += r - l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-浮点二分"><a href="#例题-浮点二分" class="headerlink" title="例题(浮点二分)"></a>例题(浮点二分)</h2><blockquote>
<p>求方程 f(x)=x^6+x-2014 在(0,+<strong>∞</strong>)的一个解,要求小数点后精确<strong>5</strong>位</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先估算一个区间 f(1)&lt;0 f(10)&gt;0 不妨l=1.0,r=10.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, <span class="number">6</span>) + x - <span class="number">2014</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">1</span>, r = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(r - l) &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (f(mid) * f(r) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.5lf&quot;</span>, find());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><blockquote>
<p>二分思想:只要是单调的,都可以二分!!!</p>
</blockquote>
<p><img src="/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/6.png" alt="image-20201216162837341"></p>
<blockquote>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>暴力枚举 i,j 将数列B计算出来,然后取它的中位数.时间和空间复杂度均0(n^2),无法接受<br>—&gt;转换思路  如果给定一个数p,如何判断它是不是中位数? —-&gt;计算p在数列中的排名(假定从小到大)即可</p>
<ol>
<li><p>如果p名次比中位数小,则说明  p比中位数小</p>
</li>
<li><p>如果p名次比中位数大,则说明  p比中位数大</p>
</li>
<li><p>如果p名次等于中位数,则说明  p是中位数</p>
<p>可以看出 满足单调性,可以对p进行二分.(二分答案!!!)</p>
<blockquote>
<p>如何计算p的名次?</p>
<ol>
<li><p>对于数组B={|Ai-Aj|,任意 1&lt;=i &lt; j&lt;=n} 将A数组从小到大排序,则可以去掉绝对值.即B={ Aj-Ai ,任意 1&lt;=i &lt; j&lt;=n}</p>
</li>
<li><p>那么计算Aj - Ai &lt;= p的个数即可.</p>
</li>
<li><p>移项有 Aj&lt;=p+Ai , 其中 i&lt;j</p>
<p>即对于每个P,枚举下标 i 然后计算满足条件的下标 j 的个数(整数二分!!!)</p>
</li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>
<blockquote>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li>首先确定答案区间(即p的范围),p就是新数组B中元素可能的取值,可以看出 0=&lt;Bi&lt;=A.max()-A.min()</li>
<li>然后就是对于每一个p,计算满足不等式(Aj&lt;=p+Ai )的个数.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="comment">//找到&lt;=k的最后一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">re_lower_bound</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rnk</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//计算满足 Aj&lt;=p+Ai , 其中 i&lt;j 的个数</span></span><br><span class="line"> <span class="comment">//对于每个p,枚举下标i,然后二分计算满足的j的个数. j的范围[i+1,n];</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = re_lower_bound(i + <span class="number">1</span>, n, p + a[i]);</span><br><span class="line">        <span class="keyword">if</span>(cnt!=<span class="number">-1</span>)</span><br><span class="line">            ans += cnt - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = (<span class="number">1</span> + n * (n - <span class="number">1</span>)) / <span class="number">2</span>; 	<span class="comment">//新数组的长度 </span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>, middle = (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//middle为中位数位置,下面实现 找到名次 &gt;=middle 的第一个p</span></span><br><span class="line">        <span class="comment">//思考为什么不是找 ==middle 的第一个p???</span></span><br><span class="line">        <span class="keyword">int</span> p_min = <span class="number">0</span>, p_max = a[n] - a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (p_min &lt;= p_max)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p_mid = (p_min + p_max) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = rnk(p_mid);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= middle)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = p_mid;</span><br><span class="line">                p_max = p_mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p_min = p_mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>middle为中位数位置,下面实现 找到名次 &gt;=middle 的第一个p</p>
<p>关于为什么不是找 ==middle 的第一个p?</p>
<p>===&gt; 在计算rak的时候 用到的不等式为: Aj&lt;=p+Ai </p>
<p>​          例如初始化B=1 3 3 3 5  答案p∈[1,5]   p_mid=3 然后返回的cnt=4&gt;middle=3 , 如果判 ==middle,p∈[1,2] ,就会接着找p_mid=1,返回的cnt=1,然后p∈[2,2],p_mid=2,返回cnt=1,然后p∈[3,2],就退出了</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title>liang-barsky裁剪算法</title>
    <url>/2020/12/23/liang-barsky%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="liang-barsky裁剪算法"><a href="#liang-barsky裁剪算法" class="headerlink" title="liang-barsky裁剪算法"></a>liang-barsky裁剪算法</h1><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p><img src="/2020/12/23/liang-barsky%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/2.png" alt="image-20201223174013329"></p>
<p><img src="/2020/12/23/liang-barsky%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/3.png" alt="image-20201223174053928"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;gl/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;liang-barsky.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> site_left = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> site_top = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> WinW = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> WinH = <span class="number">450</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    point() &#123; x = <span class="number">-1</span>, y = <span class="number">-1</span>; &#125;</span><br><span class="line">    point(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1) &#123; x = x1, y = y1; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">200.0</span> / <span class="number">255</span>, <span class="number">200.0</span> / <span class="number">255</span>, <span class="number">169.0</span> / <span class="number">255</span>, <span class="number">0.0</span>);		<span class="comment">//设定清理颜色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);									<span class="comment">//清理缓冲区</span></span><br><span class="line">    <span class="comment">//绘制矩形裁剪框</span></span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);</span><br><span class="line">    glRectf(<span class="number">100</span>, <span class="number">80</span>, <span class="number">400</span>, <span class="number">360</span>);								<span class="comment">//相对于窗口正中心 四变量依次：左下 右上（横、纵左边） </span></span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt;v;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> cnt, nowid;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> tx, <span class="keyword">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> x = v[i].x, y = v[i].y;</span><br><span class="line">    <span class="keyword">if</span> (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawline</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">252.0</span> / <span class="number">255</span>, <span class="number">157.0</span> / <span class="number">255</span>, <span class="number">154.0</span> / <span class="number">255</span>);</span><br><span class="line">    glLineWidth(<span class="number">2</span>);</span><br><span class="line">    glEnable(GL_LINE_SMOOTH);</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    glVertex2i(v[x - <span class="number">1</span>].x, v[x - <span class="number">1</span>].y);</span><br><span class="line">    glVertex2i(v[x].x, v[x].y);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseClick</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> nowx, <span class="keyword">int</span> nowy)</span> <span class="comment">//x,y均是以窗口左上角为（0,0）的像素表示</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = nowx, y = WinH - nowy;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(i, x, y))</span><br><span class="line">        &#123;</span><br><span class="line">            id = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (button == GLUT_LEFT &amp;&amp; state == GLUT_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v.push_back(point(x, y));</span><br><span class="line">            nowid = v.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span> ==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                drawline(nowid);</span><br><span class="line">                liang_barsky(v[nowid - <span class="number">1</span>].x, v[nowid - <span class="number">1</span>].y, v[nowid].x, v[nowid].y, <span class="number">360</span>, <span class="number">80</span>, <span class="number">100</span>, <span class="number">400</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nowid = id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMotion</span><span class="params">(<span class="keyword">int</span> nowx, <span class="keyword">int</span> nowy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    v[nowid].x = nowx, v[nowid].y = <span class="number">450.0</span> - nowy;<span class="comment">//找到重绘时产生变化的那条线段</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全部重新绘制</span></span><br><span class="line">    display();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v.size() - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">        drawline(i), liang_barsky(v[i - <span class="number">1</span>].x, v[i - <span class="number">1</span>].y, v[i].x, v[i].y, <span class="number">360</span>, <span class="number">80</span>, <span class="number">100</span>, <span class="number">400</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);	<span class="comment">//显示窗口的缓存和颜色模型</span></span><br><span class="line">    glutInitWindowPosition(site_left, site_top);</span><br><span class="line">    glutInitWindowSize(WinW, WinH);</span><br><span class="line">    glutCreateWindow(<span class="string">&quot;liang-barsky直线裁剪算法&quot;</span>);				 	<span class="comment">//创建带标题的窗口</span></span><br><span class="line">    gluOrtho2D(<span class="number">0</span>, WinW, <span class="number">0</span>, WinH);					<span class="comment">// 区域大小定义  窗口的左下角是（0，0）</span></span><br><span class="line"></span><br><span class="line">    glutDisplayFunc(&amp;display);						<span class="comment">//事件1：显示函数</span></span><br><span class="line">    glutMouseFunc(mouseClick);						<span class="comment">//事件2：鼠标点击</span></span><br><span class="line">    glutMotionFunc(mouseMotion);					<span class="comment">//事件3：鼠标移动</span></span><br><span class="line">    glutMainLoop();									<span class="comment">//让事件保持循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="liang-barsky-h"><a href="#liang-barsky-h" class="headerlink" title="liang-barsky.h"></a>liang-barsky.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">249.0</span> / <span class="number">255</span>, <span class="number">205.0</span> / <span class="number">255</span>, <span class="number">173.0</span> / <span class="number">255</span>);<span class="comment">//区域线段颜色</span></span><br><span class="line">    glLineWidth(<span class="number">2</span>);</span><br><span class="line">    glEnable(GL_LINE_SMOOTH);</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    glVertex2i(x1, y1);</span><br><span class="line">    glVertex2i(x2, y2);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">liang_barsky</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2, <span class="keyword">double</span> YT, <span class="keyword">double</span> YB, <span class="keyword">double</span> XL, <span class="keyword">double</span> XR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//①参数方程的思想</span></span><br><span class="line"><span class="comment">//②把直线段看成一条有方向的线段。（假定方向是从x_min ---&gt; x_max）。</span></span><br><span class="line"><span class="comment">//裁剪即求 起点和终点的参数μ值 μ1 = max(0,μ入边1,μ入边2) μ2 = min(1,μ出边1,μ出边2)</span></span><br><span class="line"><span class="comment">//问题转换为---只需要判断</span></span><br><span class="line"><span class="comment">//--a.那两个边是 入边 ，哪两个边是 出边。</span></span><br><span class="line"><span class="comment">//--b.直线和窗口边界的 四个交点 的参数值如何求？</span></span><br><span class="line">    <span class="keyword">double</span> u1 = <span class="number">0</span>, u2 = <span class="number">1</span>, dx = x2 - x1, dy = y2 - y1;</span><br><span class="line">    <span class="keyword">double</span> p[<span class="number">5</span>], q[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//裁剪问题转换为 判断 点 是否在窗口内的问题。</span></span><br><span class="line">    <span class="comment">//X_left ≤ x1+μ*dx ≤ X_right</span></span><br><span class="line">    <span class="comment">//Y_btom ≤ y1+μ*dy ≤ Y_top</span></span><br><span class="line">    p[<span class="number">1</span>] = -dx; q[<span class="number">1</span>] = x1 - XL; </span><br><span class="line">    p[<span class="number">2</span>] = dx; q[<span class="number">2</span>] = XR - x1;</span><br><span class="line">    p[<span class="number">3</span>] = -dy; q[<span class="number">3</span>] = y1 - YB; </span><br><span class="line">    p[<span class="number">4</span>] = dy; q[<span class="number">4</span>] = YT - y1;</span><br><span class="line">    <span class="comment">//有μ*p[k] ≤ q[k] 不等式取 = 对应与边界的四个交点参数</span></span><br><span class="line">    <span class="comment">//p[k] &lt; 0 对应两条入边</span></span><br><span class="line">    <span class="comment">//p[k] &lt; 0 对应两条出边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            u1 = max(u1, q[i] / p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[i] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            u2 = min(u2, q[i] / p[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">            (p[i] == <span class="number">0</span> &amp;&amp; q[i] &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u1 &gt; u2) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    draw(x1 + u1 * dx, y1 + u1 * dy, x1 + u2 * dx, y1 + u2 * dy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>opengl图形学</category>
      </categories>
      <tags>
        <tag>liang-barsky裁剪</tag>
      </tags>
  </entry>
  <entry>
    <title>sstream+getline</title>
    <url>/2020/11/24/sstream+getline/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="字符串分割神器—sstream-getline"><a href="#字符串分割神器—sstream-getline" class="headerlink" title="字符串分割神器—sstream+getline"></a>字符串分割神器—sstream+getline</h1><h2 id="一些string常用的字符串处理"><a href="#一些string常用的字符串处理" class="headerlink" title="一些string常用的字符串处理"></a>一些string常用的字符串处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s.substr(pos,n);<span class="comment">//截取s中从pos开始（包括0，左边是闭区间）的n个字符的子串，并返回字符串</span></span><br><span class="line">s.find(str s1); <span class="comment">//查找s中第一次出现s1的位置,并返回(包括0)</span></span><br><span class="line">s.copy(<span class="keyword">char</span> * s,<span class="keyword">int</span> n,<span class="keyword">int</span> pos)；</span><br><span class="line"><span class="comment">//返回值为实际拷贝的字符数目；把当前串pos位置开始的n个字符拷贝到s为起始位置的数组中；</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="sstream-getline"><a href="#sstream-getline" class="headerlink" title="sstream+getline"></a>sstream+getline</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;  //头文件</span></span></span><br><span class="line"><span class="comment">//stringstream的特点是，你读入了前面的一部分字符串，对应的字符串流中就会减去那一部分</span></span><br><span class="line"><span class="comment">//(配合getline截断字符使用的话，字符流中也会减去截断字符)，</span></span><br><span class="line"><span class="comment">//所以可以使用while来一直循环读入.</span></span><br></pre></td></tr></table></figure>

<p> <strong>eg. Sample input :</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/../d<span class="comment">///c</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/24/sstream+getline/1.png" alt="img"></p>
<p> <strong>eg. Sample output :</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">..</span><br><span class="line">d</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p><strong>在插入vector的过程中,要判断当前小字符串(stemp)是否为空 ; 否则会出现很多空字符 , 如下:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">..</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关于—getline"><a href="#关于—getline" class="headerlink" title="关于—getline()"></a>关于—getline()</h2><blockquote>
<p><strong>在c++中本质有两种 getline 函数</strong></p>
<ol>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在头文件&lt;iostream&gt;中 , 是iostream类的成员函数 .</span></span><br><span class="line"><span class="function">istream&amp;  <span class="title">getline</span>  <span class="params">(<span class="keyword">char</span>* s,streamsize n)</span></span>;</span><br><span class="line"><span class="comment">//从istream中读取至多n个字符(包括结束标记符)保存在s对应的数组中.</span></span><br><span class="line"><span class="function">istream&amp;  <span class="title">getline</span>  <span class="params">(<span class="keyword">char</span>* s,streamsize n,<span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="comment">//即使还没读够n个字符，如果遇到delim 或 字数达到限制，则读取终止 . delim不会被保存进s对应的数组中</span></span><br></pre></td></tr></table></figure>
</li>
<li> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在头文件&lt;string&gt;中，是普通函数.</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(istream&amp; is,<span class="built_in">string</span>&amp; str)</span></span>;</span><br><span class="line"><span class="comment">//从输入流is中(如 cin),读一行到str里面.</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(istream&amp; is,<span class="built_in">string</span>&amp; str,<span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="comment">//从输入流is中,按照截断字符delim读到str中</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<hr>
<h2 id="关于—流和EOF-win下是ctrl-Z"><a href="#关于—流和EOF-win下是ctrl-Z" class="headerlink" title="关于—流和EOF(win下是ctrl+Z)"></a>关于—流和EOF(win下是ctrl+Z)</h2><blockquote>
<p>就while(getline(cin,line))分析一下</p>
<p>这个while语句真实的判断对象是 cin 的状态,也就是当前是否存在有效的输入流.而输入流是对象,返回的是输入流的状态.正常情况下,你是怎么输入都跳不出循环的. (如果认为输入 回车 就可以跳出,则是将 while的判断对象看成了 line(即判断line是否为空) 实际上,回车和设置的delim都是仅终止getline()的读取操作).</p>
<p>EOF是C语言中为了区分有效数据和输入结束符的。windows下是ctrl+z,linux/unix下是ctrl+d。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>vs2019添加c++万能头文件</title>
    <url>/2020/12/16/vs2019%E6%B7%BB%E5%8A%A0c++%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HekoStaticFile@latest/Heko/js/mouse_snow.min.js"></script>

<blockquote>
<ol>
<li><p>VS2019安装路径下找到VC文件依次进入Tools/MSVC/14.24.28314/include。然后在include内创建一个名称为bits的文件(图示为默认安装路径)<img src="/2020/12/16/vs2019%E6%B7%BB%E5%8A%A0c++%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/1.png" alt="image-20201216170231567"></p>
</li>
<li><p><img src="/2020/12/16/vs2019%E6%B7%BB%E5%8A%A0c++%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/2.png" alt="image-20201216170442154"></p>
</li>
<li><p>在bits文件夹创建一个stdc++.h并将下面代码复制进去即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ includes used for precompiling -*- C++ -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copyright (C) 2003-2015 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is part of the GNU ISO C++ Library.  This library is free</span></span><br><span class="line"><span class="comment">// software; you can redistribute it and/or modify it under the</span></span><br><span class="line"><span class="comment">// terms of the GNU General Public License as published by the</span></span><br><span class="line"><span class="comment">// Free Software Foundation; either version 3, or (at your option)</span></span><br><span class="line"><span class="comment">// any later version.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// This library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">// GNU General Public License for more details.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Under Section 7 of GPL version 3, you are granted additional</span></span><br><span class="line"><span class="comment">// permissions described in the GCC Runtime Library Exception, version</span></span><br><span class="line"><span class="comment">// 3.1, as published by the Free Software Foundation.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// You should have received a copy of the GNU General Public License and</span></span><br><span class="line"><span class="comment">// a copy of the GCC Runtime Library Exception along with this program;</span></span><br><span class="line"><span class="comment">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span></span><br><span class="line"><span class="comment">// &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** @file stdc++.h</span></span><br><span class="line"><span class="comment"> *  This is an implementation file for a precompiled header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 17.4.1.2 Headers</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GLIBCXX_NO_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ciso646&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csetjmp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ccomplex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfenv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdalign&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctgmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cwchar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cwctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;scoped_allocator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeindex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++万能头</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和&amp;差分</title>
    <url>/2020/12/19/%E5%89%8D%E7%BC%80%E5%92%8C&amp;%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一维前缀和 初始化</span></span><br><span class="line"><span class="keyword">int</span> a[N]=&#123;<span class="number">0</span>&#125;,dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    dp[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//性质</span></span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + a[i];</span><br><span class="line">dp[L,R] = dp[R] - dp[L<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维前缀和 初始化</span></span><br><span class="line"><span class="keyword">int</span> a[N][M]=&#123;<span class="number">0</span>&#125;,dp[N][M]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">        dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]-dp[x<span class="number">-1</span>][y<span class="number">-1</span>]+a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//性质</span></span><br><span class="line">dp[a,b][c,d]=dp[c][d]-dp[a][d]-dp[c][b]+sum[a][b];</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="/2020/12/19/%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/2.png" alt="image-20201219113830487" style="zoom:67%;">

<hr>
<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一维差分 初始化</span></span><br><span class="line"><span class="keyword">int</span> a[N]=&#123;<span class="number">0</span>&#125;,dp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    dp[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//差分数组前缀和 = a[]元素值</span></span><br><span class="line">dp[<span class="number">1</span>]+dp[<span class="number">2</span>]+...+dp[i]=a[i];</span><br><span class="line"><span class="comment">//差分数组单点修改 = a[]区间整体+-</span></span><br><span class="line">      dp[L] += c,dp[R+<span class="number">1</span>] -= c;</span><br><span class="line">等价于a[L]+=c,a[L+<span class="number">1</span>]+=c,...,a[R]+=c;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><img src="/2020/12/19/%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/3.png"></p>
<blockquote>
<p>分析: 暴力做法O(q*n),超时</p>
<ol>
<li>将原数组A—&gt;差分数组B,将区间操作—&gt;单点修改</li>
<li>B数组前缀和即为A数组最终数值.0(n+q)</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,q,a[N],b[N];<span class="comment">//防止q次操作导致int溢出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        b[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l,r,c;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        b[l]+=c; b[r+<span class="number">1</span>]-=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) </span><br><span class="line">            tmp=b[i],<span class="built_in">cout</span>&lt;&lt;tmp;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">1</span>)</span><br><span class="line">            tmp+=b[i],<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>前缀和&amp;差分</tag>
      </tags>
  </entry>
  <entry>
    <title>解决win10蓝牙设备连接不上</title>
    <url>/2020/12/16/%E5%85%B3%E4%BA%8Ewin10%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="已配对蓝牙无法连接并且搜索不到"><a href="#已配对蓝牙无法连接并且搜索不到" class="headerlink" title="已配对蓝牙无法连接并且搜索不到"></a>已配对蓝牙无法连接并且搜索不到</h1><p><img src="/2020/12/16/%E5%85%B3%E4%BA%8Ewin10%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/1.png" alt="image-20201216144906317"></p>
<p><img src="/2020/12/16/%E5%85%B3%E4%BA%8Ewin10%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/2.png" alt="image-20201216144943264"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$Source = @<span class="string">&quot;</span></span><br><span class="line"><span class="string">   [DllImport(&quot;</span>BluetoothAPIs.dll<span class="string">&quot;, SetLastError = true, CallingConvention = CallingConvention.StdCall)]</span></span><br><span class="line"><span class="string">   [return: MarshalAs(UnmanagedType.U4)]</span></span><br><span class="line"><span class="string">   static extern UInt32 BluetoothRemoveDevice(IntPtr pAddress);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   public static UInt32 Unpair(UInt64 BTAddress) &#123;</span></span><br><span class="line"><span class="string">      GCHandle pinnedAddr = GCHandle.Alloc(BTAddress, GCHandleType.Pinned);</span></span><br><span class="line"><span class="string">      IntPtr pAddress     = pinnedAddr.AddrOfPinnedObject();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      UInt32 result       = BluetoothRemoveDevice(pAddress);</span></span><br><span class="line"><span class="string">      pinnedAddr.Free();</span></span><br><span class="line"><span class="string">      return result;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&quot;</span>@</span><br><span class="line"></span><br><span class="line">Function Get-BTDevice &#123;</span><br><span class="line">    Get-PnpDevice -class Bluetooth |</span><br><span class="line">      ?&#123;$_.HardwareID -match &#x27;DEV_&#x27;&#125; |</span><br><span class="line">         select Status, Class, FriendlyName, HardwareID,</span><br><span class="line">            # Extract device address from HardwareID</span><br><span class="line">            @&#123;N=&#x27;Address&#x27;;E=&#123;[uInt64](&#x27;0x&#123;0&#125;&#x27; -f $_.HardwareID[0].Substring(12))&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">################## Execution Begins Here ################</span><br><span class="line"></span><br><span class="line">$BTR       = Add-Type -MemberDefinition $Source -Name <span class="string">&quot;BTRemover&quot;</span>  -Namespace <span class="string">&quot;BStuff&quot;</span> -PassThru</span><br><span class="line">$BTDevices = @(Get-BTDevice) # Force <span class="built_in">array</span> <span class="keyword">if</span> null <span class="keyword">or</span> single item</span><br><span class="line">Do &#123;</span><br><span class="line">   If ($BTDevices.Count) &#123;</span><br><span class="line">      <span class="string">&quot;`n******** Bluetooth Devices ********`n&quot;</span> | Write-Host</span><br><span class="line">      For ($i=<span class="number">0</span>; $i -lt $BTDevices.Count; $i++) &#123;</span><br><span class="line">         (&#x27;&#123;0,5&#125; - &#123;1&#125;&#x27; -f ($i+1), $BTDevices[$i].FriendlyName) | Write-Host</span><br><span class="line">      &#125;</span><br><span class="line">      $selected = Read-Host <span class="string">&quot;`nSelect a device to remove (0 to Exit)&quot;</span></span><br><span class="line">      If ([<span class="keyword">int</span>]$selected -in <span class="number">1.</span>.$BTDevices.Count) &#123;</span><br><span class="line">         &#x27;Removing device: &#123;0&#125;&#x27; -f $BTDevices[$Selected-1].FriendlyName | Write-Host</span><br><span class="line">         $Result = $BTR::Unpair($BTDevices[$Selected<span class="number">-1</span>].Address)</span><br><span class="line">         If (!$Result) &#123;<span class="string">&quot;Device removed successfully.&quot;</span> | Write-Host&#125;</span><br><span class="line">         Else &#123;<span class="string">&quot;Sorry, an error occured.&quot;</span> | Write-Host&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   Else &#123;</span><br><span class="line">      <span class="string">&quot;`n********* No devices foundd ********&quot;</span> | Write-Host</span><br><span class="line">   &#125;</span><br><span class="line">&#125; While (($BTDevices = @(Get-BTDevice)) -<span class="keyword">and</span> [<span class="keyword">int</span>]$selected)</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p> <strong>将上述代码直接复制粘贴到 Windows  PowerShell 里,然后删除出问题的设备,重新搜索蓝牙设备即可.</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>win10</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈和单调队列</title>
    <url>/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h1><p><img src="/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/1.png" alt="image-20201217095745201"></p>
<h2 id="伪码实现"><a href="#伪码实现" class="headerlink" title="伪码实现"></a>伪码实现</h2><blockquote>
<ol>
<li><p><strong>单增栈</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈顶---&gt;栈底,单调增  (只维护一端:栈顶)</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> a[n+<span class="number">1</span>];<span class="comment">//a[1]~a[n]源数据</span></span><br><span class="line">a[n+<span class="number">1</span>]=INT_MAX; <span class="comment">//为了将栈内元素全部弹出</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(st.size()&gt;<span class="number">0</span>&amp;&amp;a[i]&gt;st.top())</span><br><span class="line">    &#123;<span class="comment">//谁的加入(即a[i])把你弹出去了,谁就是你往→第一个比你 big 的数    </span></span><br><span class="line">!!! 即<span class="keyword">while</span>循环里 a[i]就是st.top() 往→第一个big的数</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    st.push(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>单增队列</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队首---&gt;队尾,单调增 (维护两端:队首和队尾)</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> a[n+<span class="number">1</span>];<span class="comment">//a[1]~a[n]源数据</span></span><br><span class="line"><span class="keyword">int</span> k=<span class="number">3</span>;<span class="comment">//窗口大小</span></span><br><span class="line"><span class="comment">//初始化队列大小为k-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.size()&gt;<span class="number">0</span>&amp;&amp;a[i]&lt;q.back())</span><br><span class="line">        q.pop_back();</span><br><span class="line">    q.push_back(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口从k开始向右移动,维护一个单增队列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">&#123;   <span class="comment">//维护单调性</span></span><br><span class="line">    <span class="keyword">while</span>(q.size()&gt;<span class="number">0</span>&amp;&amp;a[i]&lt;q.back())</span><br><span class="line">        q.pop_back();</span><br><span class="line">    q.push_back(a[i]);</span><br><span class="line">    <span class="comment">//再维护窗口大小,保证队列元素都落在窗口内</span></span><br><span class="line">    <span class="keyword">while</span>(q.size()&gt;<span class="number">0</span>&amp;&amp;(i-队首q.front的元素下标)&gt;=k)</span><br><span class="line">        q.pop_front();</span><br><span class="line">    </span><br><span class="line">!!! 此时窗口small值就是q.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h1 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h1><h2 id="单调栈-直方图求最大矩形面积"><a href="#单调栈-直方图求最大矩形面积" class="headerlink" title="单调栈:直方图求最大矩形面积"></a>单调栈:直方图求最大矩形面积</h2><p><img src="/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/3.png" alt="image-20201217110025171"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">int</span> a_l[N], a_r[N];<span class="comment">//必须存数组下标,因为面积计算公式要用到 区间长度</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;<span class="comment">//需配合a_l和a_r 也必须存数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">// →</span></span><br><span class="line">    a[n + <span class="number">1</span>] = <span class="number">-1</span>;<span class="comment">//保证数组中每个元素 都被 弹出一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st.size() &gt; <span class="number">0</span> &amp;&amp; a[i] &lt; a[st.top()])</span><br><span class="line">        &#123;</span><br><span class="line">            a_r[st.top()] = i;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ←</span></span><br><span class="line">    <span class="keyword">while</span> (st.size())</span><br><span class="line">        st.pop();</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//保证数组中每个元素 都被 弹出一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;=<span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st.size() &gt; <span class="number">0</span> &amp;&amp; a[i] &lt; a[st.top()])</span><br><span class="line">        &#123;</span><br><span class="line">            a_l[st.top()] = i;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = max(ans,(a_r[i]-a_l[i]<span class="number">-1</span>)*a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调队列-滑动窗口"><a href="#单调队列-滑动窗口" class="headerlink" title="单调队列:滑动窗口"></a>单调队列:滑动窗口</h2><p><img src="/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/4.png" alt="image-20201217110403393"></p>
<img src="/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/5.png" alt="image-20201217142828320" style="zoom: 67%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> a_min[N], a_max[N];<span class="comment">//里面存数组下标(直接存值亦可)</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//必须存数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">// min</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;<span class="comment">//维护单调性</span></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span> &amp;&amp; a[i] &lt; a[q.back()])</span><br><span class="line">            q.pop_back();</span><br><span class="line">        q.push_back(i);</span><br><span class="line">        <span class="comment">//再维护窗口大小,保证队列元素都落在窗口内</span></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span> &amp;&amp; (i - q.front()) &gt;= k)</span><br><span class="line">            q.pop_front();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">            a_min[i] = q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// max</span></span><br><span class="line">    q.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;<span class="comment">//维护单调性</span></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[q.back()])</span><br><span class="line">            q.pop_back();</span><br><span class="line">        q.push_back(i);</span><br><span class="line">        <span class="comment">//再维护窗口大小,保证队列元素都落在窗口内</span></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span> &amp;&amp; (i - q.front()) &gt;= k)</span><br><span class="line">            q.pop_front();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">            a_max[i] = q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[a_min[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[a_max[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>线性数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路</title>
    <url>/2020/12/20/%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<p><img src="/2020/12/20/%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF/3.png" alt="image-20201220111748833"></p>
<h1 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h1><blockquote>
<p>Floyd—&gt;求图中任意两点之间的距离.</p>
<p>Floyd怎么来的? 动态规划的思想</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">① 首先定义一个三维数组 f[k][x][y] 表示只允许经过节点<span class="number">1</span>到k,节点x到节点y的最短路长度</span><br><span class="line">② 所以f[n][x][y],即节点x到节点y的最短路长度</span><br><span class="line">③ f[k][x][y]=min(f[k<span class="number">-1</span>][x][y],f[k<span class="number">-1</span>][x][k] + f[k<span class="number">-1</span>][k][y]);</span><br><span class="line"></span><br><span class="line">改进:</span><br><span class="line">不难发现我们可以把第一维优化掉(因为在阶段k时,f[x][k]和f[k][y]不会被更新)</span><br><span class="line">    即 f[x][y]=min(f[x][y],f[x][k]+f[k][y])</span><br></pre></td></tr></table></figure>

<h2 id="Floyd代码实现"><a href="#Floyd代码实现" class="headerlink" title="Floyd代码实现"></a>Floyd代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Floyd</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N][N];<span class="comment">//dis初始化为inf,dis[i][j]表点i到点j的最短距离.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> **dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">           dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Floyd应用-复杂度-O-n-3"><a href="#Floyd应用-复杂度-O-n-3" class="headerlink" title="Floyd应用 (复杂度:O(n^3))"></a>Floyd应用 (复杂度:O(n^3))</h2><ol>
<li>多源最短路</li>
<li>图上的传递闭包,任意两点的连通关系.</li>
</ol>
<h2 id="传递闭包例题"><a href="#传递闭包例题" class="headerlink" title="传递闭包例题"></a>传递闭包例题</h2><p><img src="/2020/12/20/%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF/2.png" alt="image-20201220105100077"></p>
<blockquote>
<p>N≤500,可以看出复杂度要求是O(n^3). (但是500^3=125,000,000 容易卡常数,详情见下面第三重循环剪枝)</p>
<p>由于胜负关系具有传递性,则可以用Floyd求出任意两点的胜负关系(传递闭包).</p>
<p>可以定义关系(初始化dis[] []为0)</p>
<ol>
<li>dis[a] [b]==1 表示a赢了b</li>
<li>dis[a] [b]==0并且dis[b] [a]==0 表示a与b胜负关系无法预知.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b,dis[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        dis[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i][k])<span class="comment">//第三层剪枝 因为只有dis[i][k]=1,第三重循环才是有意义的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">              dis[i][j] = max(dis[i][j], dis[i][k] &amp; dis[k][j]);<span class="comment">//i赢k,k赢j---&gt;i赢k</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;	</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)			</span><br><span class="line">            <span class="keyword">if</span> (dis[i][j] == <span class="number">0</span> &amp;&amp; dis[j][i] == <span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Dijkstra-迪杰特斯拉"><a href="#Dijkstra-迪杰特斯拉" class="headerlink" title="Dijkstra(迪杰特斯拉)"></a>Dijkstra(迪杰特斯拉)</h1><blockquote>
<p>该算法主要用来解决 图中没有负边的单源最短路 问题(因为dj算法判断负环比较困难)</p>
<p>复杂度O((n+m)logn) 即 mlogn</p>
<p>算法实现的大致流程</p>
<ol>
<li>设置s为源点,dis[a]表示源点s到点a的最短距离,初始化dis[s]=0,dis[i]=inf,将s加入最小堆</li>
<li>每次从堆中取出一个点x(肯定是新加入的点影响到原结果),遍历x的所有邻接边edge(x y w),比较dis[y]与dis[x]+w的大小 ——即<strong>松弛操作</strong></li>
<li>以收录的点,即被最小堆弹出过的点, 对任一未收录的顶点v,dis[v]表示从s到v的最短路径,但是该最短路径 <strong>仅经过所有被收录的顶点</strong>.</li>
</ol>
</blockquote>
<h2 id="Dijkstra模板代码"><a href="#Dijkstra模板代码" class="headerlink" title="Dijkstra模板代码"></a>Dijkstra模板代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>, N = <span class="number">1e5</span>, M = <span class="number">1e6</span>;</span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="keyword">int</span> head[N], cnt = <span class="number">0</span>, n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dijkstra</span></span><br><span class="line"><span class="keyword">int</span> vis[N], dis[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;<span class="comment">//默认是最大堆,最大堆丢负数--&gt;最小堆</span></span><br><span class="line"><span class="comment">//用最小堆 是为了确定 哪个是下一个点  基本思想就是 不断地从未收录的点集中收录顶点(依据是dis值)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) q.pop();</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        vis[i] = <span class="number">0</span>, dis[i] = inf;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, s)); <span class="comment">//pair排序是按照pair.first进行排序的 所以第一个存距离，第二个存点</span></span><br><span class="line">    <span class="comment">//主要部分</span></span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.top().second;<span class="comment">//堆中dis最小值的点</span></span><br><span class="line">        q.pop();                <span class="comment">//即已收录的点集合 到 未收录点集合距离最小的点</span></span><br><span class="line">        <span class="keyword">if</span> (vis[now]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//松弛</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = now, v = edge[i].v, w = edge[i].w;<span class="comment">// u(now) v w</span></span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(-dis[v], v));  <span class="comment">//最大堆丢负数 变最小堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题–一条商业线的最短路问题"><a href="#例题–一条商业线的最短路问题" class="headerlink" title="例题–一条商业线的最短路问题"></a>例题–一条商业线的最短路问题</h2><p><img src="/2020/12/20/%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF/4.png" alt="image-20201220163344299"></p>
<h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><blockquote>
<p><strong>思路1</strong></p>
<ol>
<li><p>以 起点 为源点 跑 单源最短路,得到dis1数组;</p>
</li>
<li><p>以 终点 为源点 跑 单源最短路,得到dis2数组;</p>
</li>
<li><p>枚举每条商业线edge(u,v,w),ans=min{ans , dis1[u]+dis2[v]+w , dis1[v]+dis2[u]+w};</p>
</li>
<li><p>最后再 ans=min(ans,不走商业线的最短距离);</p>
<blockquote>
<p><strong>思路2(分层图最短路)</strong></p>
<ol>
<li>跑一次单源最短路(变形版),记录答案dis[u] [0/1]</li>
<li>dis[u] [0]表示从起点到节点u没有经过商业线时的最短路,松弛时可以选择商业线或者经济线</li>
<li>dis[u] [1]表示从起点到节点u经过商业线后的最短路,在松弛的时候只能选择经济线.</li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>, N = <span class="number">1e5</span>, M = <span class="number">1e6</span>;</span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="keyword">int</span> head[N], cnt = <span class="number">0</span>, n, m, k;</span><br><span class="line"><span class="keyword">int</span> s, e;<span class="comment">//起点,终点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dijkstra</span></span><br><span class="line"><span class="keyword">int</span> vis[N], dis1[N], dis2[N], path1[N], path2[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;<span class="comment">//默认是最大堆,最大堆丢负数--&gt;最小堆</span></span><br><span class="line"><span class="comment">//用最小堆 是为了确定 哪个是下一个点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span>* dis,<span class="keyword">int</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) q.pop();</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        vis[i] = <span class="number">0</span>, dis[i] = inf, path[i] = <span class="number">-1</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, s)); <span class="comment">//pair排序是按照pair.first进行排序的 所以第一个存距离，第二个存点</span></span><br><span class="line">    <span class="comment">//主要部分</span></span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.top().second;<span class="comment">//堆中dis最小值的点</span></span><br><span class="line">        q.pop();				<span class="comment">//即已收录的点集合 到 未收录点集合距离最小的点</span></span><br><span class="line">        <span class="keyword">if</span> (vis[now]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//松弛</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = now, v = edge[i].v, w = edge[i].w;<span class="comment">// u(now) v w</span></span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(-dis[v], v));  <span class="comment">//最大堆丢负数 变最小堆</span></span><br><span class="line">                path[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ss == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ss;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    output(path1[ss]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; e;</span><br><span class="line">    <span class="keyword">int</span> mindis = inf;</span><br><span class="line">    <span class="comment">//经济线</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(s, dis1, path1);</span><br><span class="line">    dijkstra(e, dis2, path2);</span><br><span class="line">    <span class="comment">//商业线</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">-1</span>, R = <span class="number">-1</span>, id = <span class="number">-1</span>;<span class="comment">//记录一下从哪一站乘坐商业线 以及商业线的左右节点</span></span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="comment">//mindis = min(mindis, dis1[u] + dis2[v] + w,dis1[v] + dis2[u] + w);</span></span><br><span class="line">        <span class="keyword">if</span> (mindis &gt; dis1[u] + dis2[v] + w)</span><br><span class="line">        &#123;</span><br><span class="line">            L = u, R = v, id = u;</span><br><span class="line">            mindis = dis1[u] + dis2[v] + w; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mindis &gt; dis1[v] + dis2[u] + w)</span><br><span class="line">        &#123;</span><br><span class="line">            L = v, R = u, id = v;</span><br><span class="line">            mindis = dis1[v] + dis2[u] + w; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mindis &gt; dis1[e])<span class="comment">//最短距离是 不使用商业票的时候</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;路线依次:&quot;</span>;<span class="comment">//输出路线</span></span><br><span class="line">        output(e);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Ticket Not Used&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; dis1[e] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;路线依次:&quot;</span>;<span class="comment">//输出路线</span></span><br><span class="line">        <span class="comment">//使用商业线时,路线应该为 e--&gt;L--&gt;R--&gt;s</span></span><br><span class="line">        output(L);<span class="comment">//递归反向输出第一段 e--&gt;L</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = R;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="number">-1</span>)<span class="comment">//递推正向输出第二段R--&gt;s</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (path2[tmp] != <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; tmp;</span><br><span class="line">            tmp = path2[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出商业线车站号 和 总时间</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;<span class="string">&quot;商业线车站号:&quot;</span>&lt;&lt;id &lt;&lt; <span class="built_in">endl</span> &lt;&lt;<span class="string">&quot;最短时间:&quot;</span>&lt;&lt; mindis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/2020/12/20/%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF/5.png" alt="image-20201220172254518"></p>
<p><strong>注意:</strong>  </p>
<p>输出路径时,<strong>从起点输出时</strong>递归输出(因为记录的是上一个位置,对应反向查找的过程,<strong>从终点输出时</strong>直接递推正序输出即可</p>
</blockquote>
<h4 id="思路2—分层图"><a href="#思路2—分层图" class="headerlink" title="思路2—分层图"></a>思路2—分层图</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//待补充</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Bellman-ford算法及其队列优化-SPFA"><a href="#Bellman-ford算法及其队列优化-SPFA" class="headerlink" title="Bellman-ford算法及其队列优化(SPFA)"></a>Bellman-ford算法及其队列优化(SPFA)</h1><h2 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h2><blockquote>
<p>Bellman-ford算法可以给出源点s至图中其他所有点的最短路 以及 对应的前驱子图.</p>
<p>Bellman-ford算法的正确性基于以下事实:</p>
<ol>
<li>最短路经过的路径条数 ＜ 图中点的个数.(若 ≥ 点的个数,则意味着某点被重复经过)</li>
<li>当松弛边(u,v)时,如果dis[u]已经是最短路,并且u是v的前驱点,则松弛之后dis[v]也是最短路,并且以后其dis值不会改变.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Bellman-ford</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    dis[i]=inf;<span class="comment">//初始化所有点的dis值都是inf</span></span><br><span class="line">    pre[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;n;k++)<span class="comment">//一层一层 松弛n-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//每轮松弛所有的边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[i].u , v=edge[i].v , w=edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(dis[v] &gt; dis[u]+w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[v]=dis[u]+w;</span><br><span class="line">            pre[v]=u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判负环--如果第n次还可以松弛的话</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> u=edge[i].u , v=edge[i].v , w=edge[i].w;</span><br><span class="line">    <span class="keyword">if</span>(dis[v] &gt; dis[u]+w)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;存在负环&quot;</span>&lt;&lt;<span class="built_in">endl</span>;        </span><br><span class="line">&#125;</span><br><span class="line">时间复杂度为O(nm)</span><br></pre></td></tr></table></figure>

<img src="/2020/12/20/%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF/6.png" alt="image-20201220204140832" style="zoom:67%;">

<blockquote>
<p>Bellman-ford算法完美解决了负权边的问题,但是它的复杂度过高,堪比复杂度为O(n^3)的Floyd算法,让人无法接受.  (m最大值可以为(n*(n-1))/2,也就是说m可以达到n^2.)</p>
<p>仔细观察Bellman-ford算法的松弛过程</p>
<ol>
<li>在第一轮松弛的过程中,最短路 边数为1 的点被确定了.</li>
<li>在第二轮松弛的过程中,最短路 边数为2 的点被确定了.</li>
<li>……</li>
<li>在第n-1轮松弛的过程中,最短路 边数为n-1的点被确定了.</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p>在Bellman-ford算法中,每一轮都有很多无效的松弛操作,怎样可以避免呢?</p>
<p>—&gt; 解决了这个问题就得到了 Bellman-ford的队列优化算法—SPFA</p>
</blockquote>
<h2 id="SPFA-Shortest-Path-Faster-Algorithm"><a href="#SPFA-Shortest-Path-Faster-Algorithm" class="headerlink" title="SPFA(Shortest Path Faster Algorithm)"></a>SPFA(Shortest Path Faster Algorithm)</h2><blockquote>
<p>在之前观察Bellman-ford算法的松弛过程中,可以看出,松弛操作仅仅发生在最短路径 前导节点中 已经成功松弛过的节点上.</p>
<ol>
<li>第一轮,与s邻接的点被松弛—&gt;最短路 边数为1 的点被确定</li>
<li>与第一轮被松弛的点 相邻接的点被松弛 —&gt;最短路 边数为2 的点被确定</li>
<li>…</li>
<li>一直到最短路 边数为n-1的点被确定 算法结束</li>
</ol>
</blockquote>
<blockquote>
<p><strong>为了每次都只做有效的松弛</strong></p>
<ol>
<li>建立一个队列</li>
<li>队列中储存被成功松弛的点</li>
<li>每次从队首取点并松弛其邻接点</li>
<li>如果邻接点松弛成功则将其放入队列</li>
</ol>
<p>需要注意的point: 因为队列中存储的是 每一层的点,如何避免重复入队? —-&gt; 用数组记录一下是否已经在队列中</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>, N = <span class="number">1e5</span>, M = <span class="number">1e6</span>;</span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="keyword">int</span> head[N], cnt = <span class="number">0</span>, n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs判负环</span></span><br><span class="line"><span class="keyword">bool</span> flag[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">while</span>(Q.size()) Q.pop();</span><br><span class="line">    Q.push(s); flag[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];~i;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = now,v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!flag[v])</span><br><span class="line">            &#123;</span><br><span class="line">                flag[v] = <span class="number">1</span>;</span><br><span class="line">                Q.push(v);</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//spfa(Shortest Path Faster algorithm)</span></span><br><span class="line"><span class="keyword">int</span> vis[N],cnt[N],dis[N],pre[N];</span><br><span class="line"><span class="comment">//①vis - 点在不在队列中 ②cnt[x]表示点x最短路的边数(即第几层) ③dis - 距离 ④pre - 前驱</span></span><br><span class="line"><span class="comment">//如果cnt[x]&gt;=n,则表明出现了负环</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        vis[i]=cnt[i]=pre[i]=<span class="number">0</span>,dis[i]=inf;</span><br><span class="line">    <span class="comment">//队列中加入初始点</span></span><br><span class="line">    vis[s]=<span class="number">1</span>,dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="comment">//主要部分</span></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">        vis[x]=<span class="number">0</span>;<span class="comment">//vis[]记录的是点在不在当前队列中,此时x出了队列</span></span><br><span class="line">        <span class="comment">//松弛操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];~i;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u=x,v=edge[i].v,w=edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                pre[v] = u;</span><br><span class="line">                <span class="comment">//cnt[u] 表点x最短路的边数(即第几层)</span></span><br><span class="line">                <span class="comment">//cnt[v] 相当于从x走(x,y)这条边到达了y</span></span><br><span class="line">                cnt[v] = cnt[x] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[v]&gt;=n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//出现负环 v在负环上,dis[v]= -inf 并且所有能被v到达的点dis均会变成-inf</span></span><br><span class="line">                    bfs(v);<span class="comment">//可以跑一下bfs 然后用flag数组标记一下所有负环的点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]&amp;&amp;!flag[v])<span class="comment">//当前点v没有在队列中，并且不是负环的一部分</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度平均是O(km)</span><br><span class="line">k是一个小于n的小常数(大多情况下都很小),但是在特殊情况下k可能会很大 </span><br><span class="line">(即spfa在特殊情况下时间复杂度会退化成O(nm))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考:</p>
<p>最短路存在吗? —–①当有负环的时候,最短路不存在 ②S不可达 即dis[s]==inf</p>
</blockquote>
<hr>
<h3 id="spfa例题—喵星收税"><a href="#spfa例题—喵星收税" class="headerlink" title="spfa例题—喵星收税"></a>spfa例题—喵星收税</h3><h1 id="关于最长路"><a href="#关于最长路" class="headerlink" title="关于最长路"></a>关于最长路</h1><blockquote>
<p><strong>在spfa中</strong>,只需要将 <u>**①dis初始值 改成 -inf ②松弛条件由 dis[v] &gt; dis[u] + w —&gt;dis[v] &lt; dis[u] + w即可**</u></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Dijkstra 跑 最长路</span></span><br><span class="line"><span class="keyword">int</span> vis[N], dis[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        vis[i] = <span class="number">0</span>, dis[i] = -inf;<span class="comment">//原本:dis[i] = inf</span></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.top().second,v = q.top().first;</span><br><span class="line">        q.pop(); </span><br><span class="line">        <span class="comment">//if (vis[now]) continue;</span></span><br><span class="line">        <span class="comment">//这句话原本表明 一个点一旦从最小堆中弹出,则这个点的dis到达了最小值</span></span><br><span class="line">        <span class="comment">//但如果是最长路 一个点一旦从最大堆中弹出,则这个点的dis到达了最大值??? 可惜结论是不对的</span></span><br><span class="line">        我们不太需要判断vis可以将所有vis[]变量删除即可 取出v = q.top().first即距离取出来</span><br><span class="line">        <span class="keyword">if</span>(v &lt; dis[now]) <span class="keyword">continue</span>;</span><br><span class="line">           </span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = now, v = edge[i].v, w = edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &lt; dis[u] + w)<span class="comment">//原本:dis[v] &gt; dis[u] + w</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(dis[v], v));  </span><br><span class="line">                <span class="comment">//原本:最大堆里面丢负数当最小堆,但是现在要用最大堆 所以去掉负号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/12/20/%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF/7.png" alt="image-20201220221334950" style="zoom:67%;">]]></content>
      <categories>
        <category>C++图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>图的存储和遍历</title>
    <url>/2020/12/19/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">邻接矩阵: 是一个N*N的二维数组 e[N][N]</span><br><span class="line"><span class="comment">//无向图---&gt;存两条单向边即可.</span></span><br><span class="line">e[u][v]=w;</span><br><span class="line">e[v][u]=w;</span><br><span class="line"><span class="comment">//无权图---&gt;可以令e[u][v]=1表示u-v之间有一条边,e[u][v]=0表无边</span></span><br><span class="line">e[u][v]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//有向带权图</span></span><br><span class="line">e[u][v]=w;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>优点:查询速度快,可以直接找到两点之间的关系.</li>
<li>空间负责度为O(n^2),对于稀疏图来说浪费内存.</li>
</ol>
</blockquote>
<hr>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">邻接表: 存每一个点的出边</span><br><span class="line">可以利用<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N]来记录<span class="comment">//如果需要记录边权等边上信息,把int--&gt;struct</span></span><br><span class="line">G[u]表示点u的 邻接数组,遍历这个<span class="built_in">vector</span>即可得到 u 可到达的每一个点</span><br><span class="line"><span class="comment">//无权有向图有一条边 u--&gt;v</span></span><br><span class="line">    G[u].push_back(v);</span><br><span class="line"><span class="comment">//无权无向图有一条边 u--&gt;v</span></span><br><span class="line">    G[u].push_back(v);</span><br><span class="line">    G[v].push_back(u);</span><br><span class="line"><span class="comment">//有权图</span></span><br><span class="line">如果是<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N],例如遍历G[u],只能知道u里面有哪些点,没有更多的信息(例如边权)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  	<span class="keyword">int</span> v,w;  </span><br><span class="line">    edge()&#123;v=<span class="number">-1</span>,w=<span class="number">0</span>;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _v,<span class="keyword">int</span> _w)&#123;v=_v,w=_w;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[u].push_back(edge(v,w));</span><br><span class="line">    <span class="comment">//G[v].push_back(edge(u,w)); //无向边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>优点:只记录了邻接点的信息,空间复杂度仅为O(m),m为边数</li>
<li>缺点:查询u,v两点关系的时候,需要遍历u的邻接数组,相比较慢.</li>
</ol>
</blockquote>
<hr>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p><img src="/2020/12/19/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/1.png" alt="image-20201219162502183"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,next;</span><br><span class="line">    <span class="comment">//next记录的同head[]也是边的索引id</span></span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="comment">//head[u]表 一条u射出的边的索引id. edge[head[u]]表第一条边 之后靠struct里面的next连接所有出边</span></span><br><span class="line"><span class="comment">//cnt 当前边的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//插入位置为head[]所指链表的头部;</span></span><br><span class="line">    edge[cnt].v=v , edge[cnt].w=w , edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    cnt++; <span class="comment">//edge[]从0开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">遍历时:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=head[now]; ~i; i=edge[i].next) </span><br><span class="line"><span class="comment">//因为初始化 head[N]=&#123;-1&#125;,-1的补码是全1  ~按位取反  ~（-1）= 0 即条件为假</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>用数组来模拟链表.</li>
<li>相比较<strong>邻接链表</strong>而言,边在 <strong>链式前向星</strong>中存储的相对顺序与输入顺序相反,其他差异不大.</li>
</ol>
</blockquote>
<hr>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><blockquote>
<p>BFS 或者 DFS</p>
</blockquote>
<h2 id="例题-树的直径"><a href="#例题-树的直径" class="headerlink" title="例题:树的直径"></a>例题:树的直径</h2><blockquote>
<p>首先明确 : 树的直径一定是某两个叶子之间的距离.</p>
<ol>
<li><p>从树中任选一个点开始遍历这棵树,找到一个距离这个点最远的叶子1,然后再从这个叶子1开始遍历,找到离这个叶子1最远的另一个叶子2,叶子1—叶子2就是树的直径.</p>
</li>
<li><p>两次遍历即可求树的直径.(遍历可以用dfs也可以用bfs,找到距离起点最远的叶子节点即可.)</p>
<p>(因为最远距离一定在叶子出现,所以虽然边权值不一定为1,但是可以不用dj等求两点之间最短/长距离,可以用dfs或者bfs)</p>
</li>
</ol>
</blockquote>
<img src="/2020/12/19/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/2.png" alt="image-20201219171619891" style="zoom:67%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125;edge[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">    vis[begin] = <span class="literal">true</span>;</span><br><span class="line">    q.push(begin);</span><br><span class="line">    <span class="keyword">int</span> node = begin, mx_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[edge[i].v])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[edge[i].v] = <span class="number">1</span>;</span><br><span class="line">                dis[edge[i].v] = dis[now] + edge[i].w;</span><br><span class="line">                <span class="keyword">if</span> (mx_len &lt; dis[edge[i].v])</span><br><span class="line">                &#123;</span><br><span class="line">                    mx_len = dis[edge[i].v];</span><br><span class="line">                    node = edge[i].v;</span><br><span class="line">                &#125;</span><br><span class="line">                q.push(edge[i].v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;<span class="comment">//返回距离该点最远的点id</span></span><br><span class="line">    <span class="comment">//return mx_len;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add(i, v, w);</span><br><span class="line">        add(v, i, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = bfs(<span class="number">1</span>); <span class="comment">//直径左端点 </span></span><br><span class="line">    <span class="keyword">int</span> b = bfs(a); <span class="comment">//直径右端点</span></span><br><span class="line">    <span class="keyword">int</span> dis_a[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dis_a[i] = dis[i];</span><br><span class="line">    bfs(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max(dis_a[i], dis[i]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>C++图论</category>
      </categories>
      <tags>
        <tag>图的存储和遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>尺取法</title>
    <url>/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="经典例题-求长度最小的连续区间-使之-sum-gt-给定整数S"><a href="#经典例题-求长度最小的连续区间-使之-sum-gt-给定整数S" class="headerlink" title="经典例题-求长度最小的连续区间 使之 sum&gt;=给定整数S"></a>经典例题-求长度最小的连续区间 使之 sum&gt;=给定整数S</h1><p><img src="/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/2.png" alt="image-20201217162325484"></p>
<img src="/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/3.png" alt="image-20201217154139876" style="zoom: 50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n &amp;&amp; sum &lt; s)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += a[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; s) <span class="keyword">break</span>;</span><br><span class="line">        ans = min(ans, r - l);</span><br><span class="line">        sum -= a[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="平衡字符串问题"><a href="#平衡字符串问题" class="headerlink" title="平衡字符串问题"></a>平衡字符串问题</h1><p><img src="/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/4.png" alt="image-20201217163402959"></p>
<blockquote>
<p>why用 尺取法?</p>
<ol>
<li>所求答案为一个连续的区间.</li>
<li>区间左右端点移动有着明确的方向.—&gt;当前[L,R]满足要求,则L++.当前[L,R]不满足要求,则R++.</li>
</ol>
</blockquote>
<blockquote>
<p>给定[L,R],如何判断是否满足要求呢?</p>
<ol>
<li><p>用sum1,sum2,sum3,sum4分别记录不包括区间[L,R]这一段时,字符’A’’B’’C’’D’</p>
</li>
<li><p>先通过替换使4类字符数量一致,再判断剩余空闲位置是否是4的倍数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MAX = max(sum1,sum2,sum3,sum4);</span><br><span class="line"><span class="built_in">free</span> = 区间元素个数-[(MAX-sum1)+(MAX-sum2)+(MAX-sum3)+(MAX-sum4)]</span><br><span class="line"><span class="comment">//若free&gt;=0且为4的倍数,则满足要求;否则不满足.</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">100000</span>, sum1, sum2, sum3, sum4;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            sum1++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">            sum2++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            sum3++;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">            sum4++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum1 == sum2 &amp;&amp; sum2 == sum3 &amp;&amp; sum3 == sum4)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxx = max(max(sum1, sum2), max(sum3, sum4));</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span> = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; !(<span class="built_in">free</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">free</span> % <span class="number">4</span> == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// [l,r] 不符合条件 - r++</span></span><br><span class="line">            <span class="keyword">if</span> (s[r] == <span class="string">&#x27;Q&#x27;</span>) sum1--;</span><br><span class="line">            <span class="keyword">if</span> (s[r] == <span class="string">&#x27;W&#x27;</span>) sum2--;</span><br><span class="line">            <span class="keyword">if</span> (s[r] == <span class="string">&#x27;E&#x27;</span>) sum3--;</span><br><span class="line">            <span class="keyword">if</span> (s[r] == <span class="string">&#x27;R&#x27;</span>) sum4--;</span><br><span class="line">            r++;</span><br><span class="line">            maxx = max(max(sum1, sum2), max(sum3, sum4));</span><br><span class="line">            <span class="built_in">free</span> = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">free</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">free</span> % <span class="number">4</span> == <span class="number">0</span>)) <span class="keyword">break</span>;</span><br><span class="line">        ans = min(ans, r-l);</span><br><span class="line">        <span class="comment">// [l,r] 符合条件 - l++</span></span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;Q&#x27;</span>) sum1++;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;W&#x27;</span>) sum2++;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;E&#x27;</span>) sum3++;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">&#x27;R&#x27;</span>) sum4++;</span><br><span class="line">        l++;</span><br><span class="line">        maxx = max(max(sum1, sum2), max(sum3, sum4));</span><br><span class="line">        <span class="built_in">free</span> = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>线性数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/12/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> par[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        par[i]=i,cnt[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = find(par[x]);<span class="comment">//①路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x),y=find(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt[x]&gt;cnt[y])</span><br><span class="line">        swap(x,y);<span class="comment">//小树挂在大树上.②启发式合并</span></span><br><span class="line">    par[x]=y;</span><br><span class="line">    cnt[y]+=cnt[x];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>C++图论</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>强连通分量Kosaraju</title>
    <url>/2020/12/27/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FKosaraju/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="DFS后序"><a href="#DFS后序" class="headerlink" title="DFS后序"></a>DFS后序</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> d[N], f[N], dcnt, fcnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//原本d[u]=++time;记录的是发现时间</span></span><br><span class="line">    d[++dcnt] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">            dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原本f[u]=++time;记录的是完成时间</span></span><br><span class="line">    f[++fcnt] = u;<span class="comment">//dfs后序,相当于是按完成时间小--&gt;大依次存储</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//省略点,边的声明</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            dfs(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="强连通分量-SCC"><a href="#强连通分量-SCC" class="headerlink" title="强连通分量(SCC)"></a>强连通分量(SCC)</h1><blockquote>
<p>相关概念:</p>
<ul>
<li>强连通:有向图G中任意两点u–&gt;v v–&gt;u都可达.</li>
<li>强连通分量(scc):极大的强连通子图</li>
</ul>
</blockquote>
<img src="/2020/12/27/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FKosaraju/2.png" alt="image-20201227140143478" style="zoom:80%;">

<h2 id="Kosaraju板子"><a href="#Kosaraju板子" class="headerlink" title="Kosaraju板子"></a>Kosaraju板子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有数组的下标均从1开始</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next;</span><br><span class="line">&#125;e1[M], e2[M];</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2, head1[N], head2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt1++;</span><br><span class="line">    e1[cnt1].v = v, e1[cnt1].next = head1[u];</span><br><span class="line">    head1[u] = cnt1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt2++;</span><br><span class="line">    e2[cnt2].v = v, e2[cnt2].next = head2[u];</span><br><span class="line">    head2[u] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kosaraju-dfs</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> f[N], fcnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head1[u]; ~i; i = e1[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e1[i].v;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">            dfs1(v);</span><br><span class="line">    &#125;</span><br><span class="line">    f[++fcnt] = u;<span class="comment">//dfs后序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> snum[N];<span class="comment">//snum[i]记录:节点i 所在的scc的序号</span></span><br><span class="line"><span class="keyword">int</span> scc[N], scnt;<span class="comment">//scnt--&gt;scc计数器 scc[i]--&gt;第i个scc里包含节点数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    snum[u] = scnt;</span><br><span class="line">    scc[scnt]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head2[u]; ~i; i = e2[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e2[i].v;</span><br><span class="line">        <span class="keyword">if</span> (!snum[v])</span><br><span class="line">            dfs2(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一遍dfs---&gt;生成dfs后序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) dfs1(i);</span><br><span class="line">    <span class="comment">//第二遍dfs---&gt;在反图中按dfs逆后序 遍历构成SCC</span></span><br><span class="line">    <span class="comment">//逆后序起到了类似 拓扑序 的作用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (!snum[f[i]])</span><br><span class="line">            scnt++, dfs2(f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//链式前向星-初始化</span></span><br><span class="line">    cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head1, <span class="number">-1</span>, <span class="keyword">sizeof</span> head1);</span><br><span class="line">    <span class="built_in">memset</span>(head2, <span class="number">-1</span>, <span class="keyword">sizeof</span> head2);</span><br><span class="line">    <span class="comment">//kosaraju--dfs-初始化</span></span><br><span class="line">    fcnt = <span class="number">0</span>, scnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(scc, <span class="number">0</span>, <span class="keyword">sizeof</span> scc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题–班长竞选"><a href="#例题–班长竞选" class="headerlink" title="例题–班长竞选"></a>例题–班长竞选</h2><p><img src="/2020/12/27/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FKosaraju/3.png" alt="image-20201227151059804"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>有向图通常<strong>考虑SCC并缩点</strong>,即将<strong>互相可达 与 单向可达 分开考虑.</strong></p>
<ul>
<li>缩点后,不难发现对于 属于第i个SCC的点来说 , 票数的构成分为两部分(令SCC[i]表示第i个SCC中点的个数)<ol>
<li>当前SCC中的点, ans += SCC[I] - 1;(去掉自己)</li>
<li>其他SCC中的点, ans += sum(SCC[j]) 其中 j—&gt;i 可达</li>
</ol>
</li>
<li>稍加思考可以发现,<strong>缩点后变成一个DAG(有向无环图)</strong>,最后答案一定出现在 <strong>出度为0</strong> 的 SCC中,因为具有传递性, 所以 如果出度不为0,你指向的SCC会继承你之前的票数并加上你本身</li>
</ul>
</blockquote>
<blockquote>
<p>对于ans如何求取比较方便?</p>
<ol>
<li>缩点之后,将图反向   (或者 直接<strong>在反图中缩点</strong>)</li>
<li>原本答案出现在 <strong>出度为0</strong> 的SCC们 变成了 <strong>入度为0</strong> 的SCC们 , 用dfs搜一遍 并且记录 个数.</li>
</ol>
</blockquote>
<p><img src="/2020/12/27/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FKosaraju/4.png" alt="image-20201227160022311"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next;</span><br><span class="line">&#125;e1[M], e2[M], e[M];</span><br><span class="line"><span class="keyword">int</span> cnt1, cnt2, head1[N], head2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt1++;</span><br><span class="line">    e1[cnt1].v = v, e1[cnt1].next = head1[u];</span><br><span class="line">    head1[u] = cnt1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt2++;</span><br><span class="line">    e2[cnt2].v = v, e2[cnt2].next = head2[u];</span><br><span class="line">    head2[u] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kosaraju-dfs</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> f[N], fcnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head1[u]; ~i; i = e1[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e1[i].v;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">            dfs1(v);</span><br><span class="line">    &#125;</span><br><span class="line">    f[++fcnt] = u;<span class="comment">//f[1到fcnt]记录dfs后序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> snum[N];<span class="comment">//snum[i]记录:节点i 所在的scc的序号</span></span><br><span class="line"><span class="keyword">int</span> scc[N], scnt;<span class="comment">//scnt--&gt;scc计数器 scc[i]--&gt;第i个scc里包含节点数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    snum[u] = scnt;</span><br><span class="line">    scc[scnt]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head2[u]; ~i; i = e2[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e2[i].v;</span><br><span class="line">        <span class="keyword">if</span> (!snum[v])</span><br><span class="line">            dfs2(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一遍dfs---&gt;生成dfs后序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) dfs1(i);</span><br><span class="line">    <span class="comment">//第二遍dfs---&gt;在反图中按dfs逆后序 遍历构成SCC</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (!snum[f[i]])</span><br><span class="line">            scnt++, dfs2(f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt, head[N], in_deg[N];</span><br><span class="line"><span class="comment">//缩点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].v = v, e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    in_deg[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head2[i]; ~j; j = e2[j].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e2[j].v;</span><br><span class="line">            <span class="keyword">if</span> (snum[i] == snum[v])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            add(snum[i], snum[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs计算票数</span></span><br><span class="line"><span class="keyword">int</span> temp, ans[N];</span><br><span class="line"><span class="keyword">bool</span> flag[N];<span class="comment">//用于dfs搜索</span></span><br><span class="line"><span class="keyword">bool</span> maxscc[N];<span class="comment">//用于标记scc 是不是最多票数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    temp += scc[u];</span><br><span class="line">    flag[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span> (!flag[v]) dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//链式前向星-初始化</span></span><br><span class="line">    cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head1, <span class="number">-1</span>, <span class="keyword">sizeof</span> head1);</span><br><span class="line">    <span class="built_in">memset</span>(head2, <span class="number">-1</span>, <span class="keyword">sizeof</span> head2);</span><br><span class="line">    <span class="comment">//缩点建新图-初始化</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(in_deg, <span class="number">0</span>, <span class="keyword">sizeof</span> in_deg);</span><br><span class="line">    <span class="comment">//kosaraju  dfs-初始化</span></span><br><span class="line">    fcnt = <span class="number">0</span>, scnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(scc, <span class="number">0</span>, <span class="keyword">sizeof</span> scc);</span><br><span class="line">    <span class="built_in">memset</span>(snum, <span class="number">0</span>, <span class="keyword">sizeof</span> snum);</span><br><span class="line">    <span class="comment">//计算票数</span></span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span> flag);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    <span class="built_in">memset</span>(maxscc, <span class="number">0</span>, <span class="keyword">sizeof</span> maxscc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">int</span> case_num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            u++, v++;<span class="comment">//将节点0到n-1 转化为 1到n</span></span><br><span class="line">            add1(u, v);</span><br><span class="line">            add2(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        kosaraju();</span><br><span class="line">        <span class="comment">//此时snum[i]记录:节点i 所在的scc的序号</span></span><br><span class="line">        <span class="comment">//scnt--&gt;scc计数器 scc[i]--&gt;第i个scc里包含节点数</span></span><br><span class="line">        shrink();<span class="comment">//在反图中缩点</span></span><br><span class="line">        <span class="comment">//此时节点从1-n变为1-scnt 边数(cnt)仅包含 不同scc之间的边(节点1到节点scnt之间相连)</span></span><br><span class="line">        <span class="comment">//in_deg[1-scnt] 记录了新图节点的入度</span></span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= scnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (in_deg[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span> flag);</span><br><span class="line">                dfs(i);</span><br><span class="line">                ans[i] = (temp - <span class="number">1</span>);</span><br><span class="line">                maxans = max(ans[i], maxans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= scnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i] == maxans)</span><br><span class="line">                maxscc[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; case_num++ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; maxans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">bool</span> space = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxscc[snum[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!space)</span><br><span class="line">                    space = <span class="literal">true</span>, <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++图论</category>
      </categories>
      <tags>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2020/12/21/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="拓扑排序-仅DAG"><a href="#拓扑排序-仅DAG" class="headerlink" title="拓扑排序(仅DAG)"></a>拓扑排序(仅DAG)</h1><h2 id="dfs逆后序-即-拓扑序"><a href="#dfs逆后序-即-拓扑序" class="headerlink" title="dfs逆后序 即 拓扑序"></a>dfs逆后序 即 拓扑序</h2><blockquote>
<p>首先明确 dfs后序 即 各点完成时间的序列</p>
<p>逆后序—&gt;完成时间从大到小进行排序</p>
</blockquote>
<p><img src="/2020/12/21/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/2.png" alt="image-20201227134142180"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> d[N], f[N], dcnt, fcnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//原本d[u]=++time;记录的是发现时间</span></span><br><span class="line">    d[++dcnt] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">            dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原本f[u]=++time;记录的是完成时间</span></span><br><span class="line">    f[fcnt++] = u;<span class="comment">//dfs后序 相当于是按完成时间小--&gt;大依次存储</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            dfs(i);</span><br><span class="line">    <span class="comment">//反向输出 dfs后序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= i; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一层一层的拓扑序"><a href="#一层一层的拓扑序" class="headerlink" title="一层一层的拓扑序"></a>一层一层的拓扑序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans.clear();</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="comment">//点从1开始到n   如果从0开始 改成  for(int i=0;i&lt;n;i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in_deg[i]==<span class="number">0</span>&amp;&amp;!vis[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            q.push(-i);</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.top(); q.pop();</span><br><span class="line">        count--;</span><br><span class="line">        ans.push_back(-now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[-now];~i;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            in_deg[v]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  <span class="comment">//点从1开始到n   </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(in_deg[i]==<span class="number">0</span>&amp;&amp;!vis[i]) </span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(-i);</span><br><span class="line">                    count++;</span><br><span class="line">                    vis[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;		</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只关注相邻序列的拓扑序-Kahn算法"><a href="#只关注相邻序列的拓扑序-Kahn算法" class="headerlink" title="只关注相邻序列的拓扑序(Kahn算法)"></a>只关注相邻序列的拓扑序(Kahn算法)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仅 使得前面节点 不依赖于 后面的节点(联想 选课.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">()</span><span class="comment">//输出字典序最小的toposort</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans.clear();</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in_deg[i]==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            q.push(-i);</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.top(); q.pop();</span><br><span class="line">        ans.push_back(-now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[-now];~i;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(--in_deg[v]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(-v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++图论</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线填充多边形算法</title>
    <url>/2020/12/23/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%A1%AB%E5%85%85%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="扫描线填充多边形算法"><a href="#扫描线填充多边形算法" class="headerlink" title="扫描线填充多边形算法"></a>扫描线填充多边形算法</h1><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p><img src="/2020/12/23/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%A1%AB%E5%85%85%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%AE%97%E6%B3%95/2.png" alt="image-20201223175153594"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> site_left = <span class="number">550</span>, site_top = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> WinW = <span class="number">500</span>, WinH = <span class="number">450</span>;</span><br><span class="line"><span class="comment">//画 多边形边界</span></span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt;input;	  <span class="comment">//鼠标键入的多边形各点</span></span><br><span class="line"><span class="keyword">int</span> nowid;</span><br><span class="line"><span class="keyword">bool</span> already = <span class="literal">false</span>;<span class="comment">//封闭之后屏蔽鼠标操作</span></span><br><span class="line"><span class="comment">//ScanLine要用到NET(新边表)AET(活动边表)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;NET[<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;AET;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;line&gt;l;		<span class="comment">//多边形各边界</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glClearColor(<span class="number">200.0</span> / <span class="number">255</span>, <span class="number">200.0</span> / <span class="number">255</span>, <span class="number">169.0</span> / <span class="number">255</span>, <span class="number">0.0</span>);		<span class="comment">//设定清理颜色</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);									<span class="comment">//清理缓冲区</span></span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span><span class="comment">//画多边形边界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">131.0</span> / <span class="number">255</span>, <span class="number">175.0</span> / <span class="number">255</span>, <span class="number">155.0</span> / <span class="number">255</span>);<span class="comment">//边界线段颜色</span></span><br><span class="line">    glEnable(GL_LINE_SMOOTH);</span><br><span class="line">    glLineWidth(<span class="number">3</span>);</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    glVertex2d(x0, y0);</span><br><span class="line">    glVertex2d(x1, y1);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> tx, <span class="keyword">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> x = input[i].x, y = input[i].y;</span><br><span class="line">    <span class="keyword">if</span> (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ScanLine</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> minyy=<span class="number">0</span>, maxyy=WinH;<span class="comment">//记录特征多边形的y_min和y_max</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseClick</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> nowx, <span class="keyword">int</span> nowy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    x = nowx, y = WinH - nowy;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">-1</span>;<span class="comment">//是否封闭，即回到起始点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(i, x, y))</span><br><span class="line">        &#123;</span><br><span class="line">            id = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">if</span> (button == GLUT_LEFT &amp;&amp; state == GLUT_DOWN) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">-1</span> &amp;&amp; !already) </span><br><span class="line">        &#123;</span><br><span class="line">            input.push_back(point(x, y));</span><br><span class="line">            minyy = min(minyy, y);</span><br><span class="line">            maxyy = max(maxyy, y);</span><br><span class="line">            nowid = input.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nowid &gt;= <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                drawLine(input[nowid - <span class="number">1</span>].x, input[nowid - <span class="number">1</span>].y, input[nowid].x, input[nowid].y);</span><br><span class="line">                l.push_back(line(input[nowid - <span class="number">1</span>].x, input[nowid - <span class="number">1</span>].y, input[nowid].x, input[nowid].y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (id != <span class="number">-1</span> &amp;&amp; !already) </span><br><span class="line">        &#123;</span><br><span class="line">            already = <span class="literal">true</span>;</span><br><span class="line">            nowid = input.size() - <span class="number">1</span>;</span><br><span class="line">            drawLine(input[nowid].x, input[nowid].y, input[id].x, input[id].y);</span><br><span class="line">            l.push_back(line(input[id].x, input[id].y, input[nowid].x, input[nowid].y));</span><br><span class="line">            </span><br><span class="line">            ScanLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);	<span class="comment">//显示窗口的缓存和颜色模型</span></span><br><span class="line">    glutInitWindowPosition(site_left, site_top);</span><br><span class="line">    glutInitWindowSize(WinW, WinH);</span><br><span class="line">    glutCreateWindow(<span class="string">&quot;扫描线填充算法&quot;</span>);				 	<span class="comment">//创建带标题的窗口</span></span><br><span class="line">    gluOrtho2D(<span class="number">0</span>, WinW, <span class="number">0</span>, WinH); <span class="comment">// 区域大小定义  窗口的左下角是（0，0）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glutDisplayFunc(&amp;display);						<span class="comment">//事件1：显示函数</span></span><br><span class="line">    glutMouseFunc(mouseClick);						<span class="comment">//事件2：鼠标点击</span></span><br><span class="line">    <span class="comment">//glutMotionFunc(mouseMotion);					//事件3：鼠标移动</span></span><br><span class="line">    glutMainLoop();									<span class="comment">//让事件保持循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="struct-h"><a href="#struct-h" class="headerlink" title="struct.h"></a>struct.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;gl/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    point() &#123; x = <span class="number">-1</span>, y = <span class="number">-1</span>; &#125;</span><br><span class="line">    point(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1) &#123; x = x1, y = y1; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//AET和NET所用的节点</span></span><br><span class="line">    <span class="keyword">double</span> xi; <span class="keyword">double</span> dx; <span class="keyword">int</span> ymax;</span><br><span class="line">    node(<span class="keyword">double</span> _xi, <span class="keyword">double</span> _dx, <span class="keyword">int</span> _ymax) :xi(_xi), dx(_dx), ymax(_ymax) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node x) &#123; <span class="keyword">return</span> xi &lt; x.xi; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    point a, b;</span><br><span class="line">    <span class="keyword">bool</span> is_flat = <span class="literal">false</span>;		<span class="comment">//多边形边界是否是直线</span></span><br><span class="line">    line() &#123;&#125;;</span><br><span class="line">    line(point x, point y) </span><br><span class="line">    &#123;</span><br><span class="line">        a = x, b = y;</span><br><span class="line">        <span class="keyword">if</span> (a.y != b.y) is_flat = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> is_flat = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    line(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span><br><span class="line">    &#123;</span><br><span class="line">        a.x = x1, a.y = y1, b.x = x2, b.y = y2;</span><br><span class="line">        <span class="keyword">if</span> (a.y != b.y) is_flat = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> is_flat = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">miny</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.y &lt; b.y) <span class="keyword">return</span> a.y;</span><br><span class="line">        <span class="keyword">return</span> b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.y &gt; b.y) <span class="keyword">return</span> a.y;</span><br><span class="line">        <span class="keyword">return</span> b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_xi</span><span class="params">(<span class="keyword">int</span> _y)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_y == a.y) <span class="keyword">return</span> a.x;</span><br><span class="line">        <span class="keyword">return</span> b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dx</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (is_flat) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> k = <span class="keyword">double</span>((b.y - a.y) * <span class="number">1.0</span> / (b.x - a.x));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扫描线填充算法"><a href="#扫描线填充算法" class="headerlink" title="扫描线填充算法"></a>扫描线填充算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glColor3f(<span class="number">252.0</span> / <span class="number">255</span>, <span class="number">157.0</span> / <span class="number">255</span>, <span class="number">154.0</span> / <span class="number">255</span>);<span class="comment">//扫描填充线段颜色</span></span><br><span class="line">    glEnable(GL_LINE_SMOOTH);</span><br><span class="line">    glLineWidth(<span class="number">1.0</span>);   <span class="comment">//扫描线</span></span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    glVertex2d(x1, y);</span><br><span class="line">    glVertex2d(x2, y);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;node&gt;NET[<span class="number">455</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;node&gt;AET;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;line&gt;l;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> WinH;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> minyy, maxyy;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScanLine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//初始化NET</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nowy = minyy; nowy &lt;= maxyy; nowy++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[i].miny() == nowy) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (l[i].is_flat) </span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//如果特征多边形的边与扫描线重合，即边界是平的,则跳过该边界</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">double</span> xi = l[i].get_xi(nowy);</span><br><span class="line">                <span class="keyword">double</span> dx = l[i].dx();</span><br><span class="line">                <span class="keyword">int</span> ymax = l[i].maxy();</span><br><span class="line">                NET[nowy].push_back(node(xi, dx, ymax));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nowy = minyy; nowy &lt;= maxyy; nowy++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NET[nowy].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            AET.push_back(NET[nowy][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(AET.begin(), AET.end());</span><br><span class="line">        <span class="comment">//根据活性表 画 y=nowy 的填充线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AET.size(); i += <span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> x1 = AET[i].xi, x2 = AET[i + <span class="number">1</span>].xi;</span><br><span class="line">            draw(x1, x2, nowy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为下一条扫描线更新AET</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AET.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//检查是否需要删除node</span></span><br><span class="line">            <span class="keyword">if</span> (AET[i].ymax == nowy + <span class="number">1</span>)	</span><br><span class="line">            &#123;</span><br><span class="line">                AET.erase(AET.begin() + i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该节点不需要删除的话 则更新node(x,dx,ymax)----&gt;node(x+dx,dx,ymax)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (AET[i].ymax &gt; nowy) </span><br><span class="line">            &#123;</span><br><span class="line">                AET[i].xi += AET[i].dx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>opengl图形学</category>
      </categories>
      <tags>
        <tag>扫描线填充多边形算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2020/12/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<p><img src="/2020/12/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/4.png"></p>
<blockquote>
<ul>
<li>一般来说是<strong>无向图</strong>,有向图没太大意义.</li>
</ul>
</blockquote>
<h1 id="Kruskal-克鲁斯卡尔"><a href="#Kruskal-克鲁斯卡尔" class="headerlink" title="Kruskal(克鲁斯卡尔)"></a>Kruskal(克鲁斯卡尔)</h1><blockquote>
<p>基于边的贪心算法</p>
<p>一句话—&gt;”每次贪心地将图中最小的非树边标记为树边,非法则跳过.”</p>
<ol>
<li>将边按照权值小–&gt;大排序</li>
<li>按顺序考虑每条边,只要这条边和我们已经选择的边不构成回路,就保留该边,否则放弃这条边.</li>
<li>成功选择(n-1)条边后,则构成最小生成树; 如果无法选择出(n-1)条边,这说明原图不连通</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kruskal算法 记录图的拓扑 可以简单用struct Edge来实现. 因为该算法不需要遍历点(点的出边等)</span></span><br><span class="line"><span class="comment">//而且不需要考虑边的方向性. 每条边保存一次即可</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; p)<span class="keyword">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> w &lt; p.w;&#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//边数</span></span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">int</span> par[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        par[i]=i,cnt[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = find(par[x]);<span class="comment">//①路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x),y=find(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt[x]&gt;cnt[y])</span><br><span class="line">        swap(x,y);<span class="comment">//小树挂在大树上.②启发式合并</span></span><br><span class="line">    par[x]=y;</span><br><span class="line">    cnt[y]+=cnt[x];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kruskal</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init(n);</span><br><span class="line">    sort(edge,edge+num);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(unite(edge[i].u,edge[i].v))</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=edge[i].w;</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">if</span>(sum==n<span class="number">-1</span>)<span class="comment">//n个点求MST</span></span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Prim-普里姆"><a href="#Prim-普里姆" class="headerlink" title="Prim(普里姆)"></a>Prim(普里姆)</h1><blockquote>
<p>基于点的贪心算法</p>
<p>一句话—&gt;”维护一个连通的点集 , 每次都从不在该点集内的点选出一个加入该连通点集的代价最小的点.”</p>
</blockquote>
<h2 id="堆优化prim-代码同Dijkstra"><a href="#堆优化prim-代码同Dijkstra" class="headerlink" title="堆优化prim(代码同Dijkstra)"></a>堆优化prim(代码同Dijkstra)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>, N = <span class="number">1e5</span>, M = <span class="number">1e6</span>;</span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="keyword">int</span> head[N], cnt = <span class="number">0</span>, n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//prim  代码基本上同dij</span></span><br><span class="line"><span class="keyword">int</span> vis[N],min_cost[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;   <span class="comment">//默认是最大堆,最大堆丢负数--&gt;最小堆</span></span><br><span class="line"><span class="comment">//用最小堆 是为了确定 哪个是下一个点  基本思想就是 不断地从未收录的点集中收录顶点(依据是min_cost值)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q.size()) q.pop();</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        vis[i] = <span class="number">0</span>, min_cost[i] = inf;</span><br><span class="line">    min_cost[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">1</span>));<span class="comment">//不妨以节点1为起始</span></span><br><span class="line">    <span class="comment">//主要部分</span></span><br><span class="line">    <span class="keyword">while</span> (q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.top().second,       </span><br><span class="line">            tmp_ans = -q.top().first;   </span><br><span class="line">        q.pop();                    </span><br><span class="line">        <span class="keyword">if</span> (vis[now]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        ans += tmp_ans;</span><br><span class="line">        <span class="comment">//松弛</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; ~i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = now, v = edge[i].v, w = edge[i].w;</span><br><span class="line">            <span class="keyword">if</span> (min_cost[v] &gt;  w)</span><br><span class="line">            &#123;</span><br><span class="line">                min_cost[v] =  w;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(-w, v));  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; prim() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="朴素的prim代码"><a href="#朴素的prim代码" class="headerlink" title="朴素的prim代码"></a>朴素的prim代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>,inf=<span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m, min_cost[N], g[N][N] = &#123;&#125;;<span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span><span class="comment">//点集从1到n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, tot = <span class="number">1</span>;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//连通点集不妨从点1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        min_cost[i] = g[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//选出一个!vis 并且 到点集距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; (!v || min_cost[v] &gt; min_cost[i]))</span><br><span class="line">                v = i;</span><br><span class="line">        <span class="comment">//if (!v) break;</span></span><br><span class="line">        <span class="keyword">if</span> (min_cost[v] == inf || !v) <span class="keyword">break</span>; <span class="comment">//没有可以选的点</span></span><br><span class="line">        tot++;</span><br><span class="line">        ans += min_cost[v];</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//必定是新加入的点影响了其他未加入的点 到点集的距离</span></span><br><span class="line">        <span class="comment">//以这个新点为边点,更新所有未加入点到该点集的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; min_cost[i] &gt; g[v][i])</span><br><span class="line">                min_cost[i] = g[v][i];</span><br><span class="line">        &#125;			</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tot != n) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//n个点是否连通</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            g[i][j] = inf;	<span class="comment">//初始化g[N][N]为inf</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        g[u][v] = w;</span><br><span class="line">        g[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; prim()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++图论</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>高精加法乘法</title>
    <url>/2020/12/23/%E9%AB%98%E7%B2%BE%E5%8A%A0%E6%B3%95%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script>

<h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><blockquote>
<p>过程 见 高精乘法 图例.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], ans[N];<span class="comment">//下标均从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读入并且将两个数a,b放入a[1-len_a],b[1-len_b]</span></span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">int</span> len_a = s1.size(), len_b = s2.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_a; i++)</span><br><span class="line">        a[i] = s1[len_a - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_b; i++)</span><br><span class="line">        b[i] = s2[len_b - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//模拟手算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max(len_a, len_b); i++)</span><br><span class="line">        ans[i] = a[i] + b[i];</span><br><span class="line">    <span class="keyword">int</span> len = max(len_a, len_b) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &gt; <span class="number">9</span>)</span><br><span class="line">            ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>, ans[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (ans[len] == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">1</span>)</span><br><span class="line">        len--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h1><blockquote>
<p>模拟手算乘法</p>
<ul>
<li>先将读入的两个字符串”2934”,”3489”,分别倒序存入数组a[]和b[]中. ( a[1,4]={4,3,9,2} b[1.4]={9,8,4,3} )</li>
<li>手算过程 : 枚举 b[i] 去乘 a[1~4] 并且每次都记录进位 (进位可以最后综合到一起,如下图右侧)</li>
<li>最后处理一下 进位和前导0即可.</li>
</ul>
</blockquote>
<p><img src="/2020/12/23/%E9%AB%98%E7%B2%BE%E5%8A%A0%E6%B3%95%E4%B9%98%E6%B3%95/2.png" alt="image-20201223171705835"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], ans[N];<span class="comment">//下标均从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读入并且将两个数a,b放入a[1-len_a],b[1-len_b]</span></span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">int</span> len_a = s1.size(), len_b = s2.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_a; i++)</span><br><span class="line">        a[i] = s1[len_a - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_b; i++)</span><br><span class="line">        b[i] = s2[len_b - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//模拟手算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len_b;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len_a; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i + j - <span class="number">1</span>] += b[i] * a[j];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = len_a + len_b;</span><br><span class="line">    <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &gt; <span class="number">9</span>)</span><br><span class="line">            ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>, ans[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (ans[len] == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">1</span>)</span><br><span class="line">        len--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阶乘之和"><a href="#阶乘之和" class="headerlink" title="阶乘之和"></a>阶乘之和</h1><p><img src="/2020/12/23/%E9%AB%98%E7%B2%BE%E5%8A%A0%E6%B3%95%E4%B9%98%E6%B3%95/3.png" alt="image-20201223211653981"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], ans[N];<span class="comment">//下标均从1开始</span></span><br><span class="line"><span class="built_in">string</span> str[<span class="number">51</span>];</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multi</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="keyword">int</span> len_a = s1.size(), len_b = s2.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_a; i++)</span><br><span class="line">        a[i] = s1[len_a - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_b; i++)</span><br><span class="line">        b[i] = s2[len_b - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//模拟手算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_b; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len_a; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i + j - <span class="number">1</span>] += b[i] * a[j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> len = len_a + len_b;</span><br><span class="line">    <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &gt; <span class="number">9</span>)</span><br><span class="line">            ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>, ans[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (ans[len] == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">1</span>)</span><br><span class="line">        len--;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        s += ans[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="keyword">int</span> len_a = s1.size(), len_b = s2.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_a; i++)</span><br><span class="line">        a[i] = s1[len_a - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_b; i++)</span><br><span class="line">        b[i] = s2[len_b - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//模拟手算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max(len_a, len_b); i++)</span><br><span class="line">        ans[i] = a[i] + b[i];</span><br><span class="line">    <span class="keyword">int</span> len = max(len_a, len_b) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &gt; <span class="number">9</span>)</span><br><span class="line">            ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>, ans[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (ans[len] == <span class="number">0</span> &amp;&amp; len &gt; <span class="number">1</span>)</span><br><span class="line">        len--;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        s += ans[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">50</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">10</span>)</span><br><span class="line">            str[i] += i / <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        str[i] += (i % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i] = multi(str[i], str[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i] = add(str[i], str[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>高精</tag>
      </tags>
  </entry>
</search>
