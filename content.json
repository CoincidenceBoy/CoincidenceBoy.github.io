{"meta":{"title":"CoincidenceBoy","subtitle":"blog","description":"","author":"CoincidenceBoy","url":"https://coincidenceboy.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"about/index.html","permalink":"https://coincidenceboy.github.io/about/index.html","excerpt":"","text":"神奇の沟通 沟通是 传递 沟通是 交流 沟通是 分享 沟通是 智慧 沟通是 友谊 沟通是 力量 “ 认识自我、超越自我 “ 是沟通的最高境界 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我CSDN：https://chocolate.blog.csdn.net/（CSDN认证博客专家） 微信公众号：小狮子前端Vue 一个不是只会写业务代码的前端攻城狮会带给你怎样的体会呢？ 座右铭：学如逆水行舟，不进则退"},{"title":"番剧列表","date":"2020-04-20T01:39:20.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"bangumis/index.html","permalink":"https://coincidenceboy.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-04-19T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"books/index.html","permalink":"https://coincidenceboy.github.io/books/index.html","excerpt":"","text":""},{"title":"相册集","date":"2020-04-21T10:44:23.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"gallery/index.html","permalink":"https://coincidenceboy.github.io/gallery/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-04-22T23:39:34.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"contact/index.html","permalink":"https://coincidenceboy.github.io/contact/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-19T04:59:34.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"categories/index.html","permalink":"https://coincidenceboy.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-23T13:22:33.961Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"home/index.html","permalink":"https://coincidenceboy.github.io/home/index.html","excerpt":"","text":"Chocolate Home lionLoveVue 小狮子前端 Chocolate I Can Do It Hello world! -「ROBOT」 首页 博客 导航 Github CSDN Email Powered By JsonBird And Hitokoto Modify by Chocolate .github-corner:hover .octo-arm { animation: octocat-wave 560ms ease-in-out } @keyframes octocat-wave { 0%, 100% { transform: rotate(0) } 20%, 60% { transform: rotate(-25deg) } 40%, 80% { transform: rotate(10deg) } } @media (max-width:500px) { .github-corner:hover .octo-arm { animation: none } .github-corner .octo-arm { animation: octocat-wave 560ms ease-in-out } }"},{"title":"友情链接","date":"2020-04-19T05:00:10.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"link/index.html","permalink":"https://coincidenceboy.github.io/link/index.html","excerpt":"","text":""},{"title":"Music","date":"2020-04-23T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"music/index.html","permalink":"https://coincidenceboy.github.io/music/index.html","excerpt":"","text":""},{"title":"电影","date":"2020-04-19T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"movies/index.html","permalink":"https://coincidenceboy.github.io/movies/index.html","excerpt":"","text":""},{"title":"说说","date":"2020-04-22T23:47:23.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"talk/index.html","permalink":"https://coincidenceboy.github.io/talk/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-19T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"tags/index.html","permalink":"https://coincidenceboy.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-23T13:22:33.949Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"box/about/index.html","permalink":"https://coincidenceboy.github.io/box/about/index.html","excerpt":"","text":"聚宝盒丨小狮子前端 关于本页 本页面收集了比较常用或者实用的网站，相当于一个小小的导航页面。 整个页面由 Viggo 开发，完全开源，如果你也喜欢，欢迎去其 Github 点亮 star。 关于 Viggo Designer. Viggo. Full-time UI designer with an enduring interest in Coding. 一个全职的用户界面设计师，优秀的前端开发工程师，擅长 WEB 开发、WEB 设计、UI/UX 设计，对编程，拍照和单车有着持久的兴趣，生活在广州；如果您想招收此方面的人才，Viggo 无疑是一个很好的选择。 关于 超逸の博客 一百个Chocolate 在校本科计算机科学与技术大三学生，主攻前端，Vue框架。 不是只会写业务代码的前端开发攻城狮！学如逆水行舟，不进则退。 COPYRIGHT 2019 - 2020 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY Chocolate"},{"title":"","date":"2020-11-23T13:22:33.951Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"box/index.html","permalink":"https://coincidenceboy.github.io/box/index.html","excerpt":"","text":"聚宝盒丨小狮子前端 footer.main-footer .go-up { width: 45px; float: right; position: fixed; right: -10px; bottom: 30px; z-index: 10; margin: 0; padding: 0; list-style: none } footer.main-footer .go-up a { display: inline-block; width: 35px; height: 35px; text-align: center; border-radius: 50%; background: rgba(123, 123, 123, .5); color: #fff; font-size: 20px; line-height: 35px; padding: 0 } 开发社区 代码托管 语言文档 技能训练 在线平台 高校平台 游戏编程 HOT Pythoner 文档资料 博客收藏 学习资源 组织社区 爬虫相关 HOT 学习教程 在线视频 博客论坛 学习平台 常用工具 站长工具 HOT IT工具箱 文件处理 HOT 设计素材 效率软件 HOT 服务平台 云服务商 众包平台 更多导航 关于本页 隐藏/显示侧边栏 博客首页 友情链接 评论留言 关于博主 ! function (e, t, n, a, o, i, c, r) { r = function () { i = t.createElement(n), c = t.getElementsByTagName(n)[0], i.src = o, i.charset = \"utf-8\", i.async = 1, c.parentNode.insertBefore(i, c) }, e.SeniverseWeatherWidgetObject = a, e[a] || (e[a] = function () { (e[a].q = e[a].q || []).push(arguments) }), e[a].l = +new Date, e.attachEvent ? e.attachEvent(\"onload\", r) : e .addEventListener(\"load\", r, !1) }(window, document, \"script\", \"SeniverseWeatherWidget\", \"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\" + parseInt(((new Date).getTime() / 1e8).toString(), 10)), window.SeniverseWeatherWidget(\"show\", { flavor: \"slim\", location: \"WX4FBXXFKE4F\", geolocation: !0, language: \"auto\", unit: \"c\", theme: \"auto\", token: \"a39cd5a0-4024-4cb2-85c6-0250317058db\", hover: \"enabled\", container: \"tp-weather-widget\" }) 导航内容不定期更新... 开发社区 Stack Overflow 全球最受程序员欢迎的开发社区 CSDN 全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台 博客园 代码改变世界 V2EX V2EX = way to explore 掘金 一个帮助开发者成长的社区 SegmentFault 改变并提升人们获取知识的方式和效率，帮助更多的开发者获得成长与成功 开源中国 国内最大的开源技术社区 ITeye ITeye软件开发交流社区 - Java编程 Spring框架 Ajax技术 agile敏捷软件开发 ruby on rails实践 51CTO 技术成就梦想 ITPUB 全球最大的学习分享平台 知乎 国内最受欢迎的知识性问答社区 简书 创作你的创作 云+社区 来自腾讯的开发者技术分享社区 云栖社区 阿里云面向开发者的开放型技术平台 极术社区 全球软硬件资源信息，只要你有问题，我们就能解答。 代码托管 Github 全球最大的面向开源及私有软件项目的托管平台 Gitlab 支持无限的公有项目和私有项目的代码托管平台 Bitbucket 同时支持 Git 和 Mercurial 这两个版本控制软件，免费的私有仓库，支持5人以内的合作开发 SourceForge 又称 SF.net，是开源软件开发者进行开发管理的集中式场所 Coding 国内首个一站式云端软件服务平台 Gitee 国内最大的开源社区 OSChina 的代码托管平台 阿里云代码托管 阿里云旗下代码托管平台 百度效率云 百度云旗下的 Git 代码托管平台 语言文档 Zeal 脱机文档浏览器，包含196种语言API文档，支持Windows、Linux和macOS Dash 适用于Mac OS平台的软件编程文档管理工具,可以浏览API文档,以及管理代码片段工具。自带了丰富的API文档,涉及各种主流的编程语言和框架 DevDocs 在快速，有条理和可搜索的界面中结合了多个API文档，可以在移动设备上离线运行，并且可以安装在Chrome上 C/C++ C/C++ API 文档 C# C# API 文档 Java Java API 文档 .NET .NET API 文档 PHP PHP API 文档 JavaScript JavaScript API 文档 Python Python API 文档 Android Android API 文档 iOS iOS API 文档 SQL SQL API 文档 Swift Swift API 文档 Ruby Ruby API 文档 GO GO API 文档 R R API 文档 MATLAB MATLAB API 文档 Node.js Node.js API 文档 HTML HTML API 文档 CSS CSS API 文档 Redis Redis API 文档 MongoDB MongoDB API 文档 Django Django API 文档 在线平台 LeetCode 全球极客挚爱的技术成长平台 Topcoder 全世界规模最大的程序竞赛网站，也会有一些算法竞赛，适合一些高端的或者搞ACM的，也会举办一些比赛 Codeforces 俄罗斯最大的算法比赛网站 Hihocoder 技术团队来自原北京大学POJ (PKU Online Judge)开发团队，收集了全球范围内很多地区、高校举办的比赛试题， 提供365天*24小时的在线提交、评判程序的服务 LintCode 被称作中文版的leetcode，也是可以做为编程能力提升的一个中转站 SPOJ 波兰的算法刷题网站 NEUQ OJ 一个在线的判题平台 洛谷 创办于2013年，致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验 牛客网 中国最大的IT题库 C语言网 在这里可以参加包括ACM、NOI在内的各种C/C++/java程序比赛，也可以DIY举办各类程序比赛活动！ 计蒜客 计蒜客OI题库致力于为参加noi、noip、信息学竞赛的选手提供优秀的Online Judge系统 高校平台 POJ 北京大学程序在线评测系统 FDU OJ 复旦大学程序在线评测系统 TJ OJ 同济大学程序在线评测系统 USTC OJ 中国科学技术大学程序在线评测系统 ZOJ 浙江大学程序在线评测系统 HDU OJ 杭州电子科技大学程序在线评测系统 CSU-ACM 中南大学程序在线评测系统 HOJX 哈尔滨工业大学程序在线评测系统 HRBUST OJ 哈尔滨理工大学程序在线评测系统 PowerOJ 西南科技大学程序在线评测系统 SCU OJ 四川大学程序在线评测系统 FZU CoidngOJ 福州大学程序在线评测系统 NBUT OJ 宁波工程学院程序在线评测系统 Lutece 电子科技大学程序在线评测系统 武汉大学 ACM 协会 武汉大学 ACM 协会 ZJUT OJ 浙江工业大学程序在线评测系统 游戏编程 CheckiO 面向初学者和高级程序员的编码游戏，使用Python和JavaScript解决棘手的挑战和有趣的任务，从而提高您的编码技能 Coding Games 支持包括PHP、C、JavaScript在内的20多种编程语言。用户界面功能强大，可以定制 Codewars 一个外国的在线练习编程的网站,做题的过程类似打怪,做题升级,而且可以看到别人的解法,里面有很多巧妙的写法可以学习 CodeCombat 一个面向学生的游戏和CS学习平台。这是一个社区项目，有数百玩家自愿提供支持。支持语言包括Java、JS、Python、Lua、CoffeeScript Screeps 在游戏中学习JavaScript。世界上第一款针对程序员的MMO沙盒游戏 VIM Adventures 玩游戏的时候学VIM Cyber-Dojo 一个提供给程序员们练习写程序的地方。支持语言包括JavaScript、Java、Python、PHP、Ruby和很多其他语言 Elevator Saga 电梯编程游戏，跟随关卡解决所有挑站，使用语言为JavaScript Ruby Quiz 一个Ruby程序员提供的每周编程挑战项目 hacker.org 这项挑战由一系列本设计来强化你黑客技巧的解密、诡计、测试、烧脑环节组成。想要通关本系列，你必须学会解密、编码、渗透 Ruby Warrior 玩游戏学Ruby，通过Ruby脚本来控制一个Warrior通过每一关，每一关的代码难度都会有所增加，使玩家逐渐了解Ruby基本的函数、控制、变量、数组等语言特性的用法 文档资料 Python 官方文档 Python 官方文档 Python 标准库 Python 标准库 Python Requests Python Requests 文档 Python Urllib Python Urllib 文档 Python Selenium Python Selenium 中文翻译文档 正则表达式 Python 正则表达式官方文档 Beautiful Soup Beautiful Soup 文档 Scrapy Scrapy 爬虫框架官方文档 PySpider PySpider 爬虫框架官方文档 Matplotlib Matplotlib 2D绘图库 官方中文文档 Numpy Numpy 科学计算 官方中文文档 Pandas Pandas 结构化数据分析 官方中文文档 博客收藏 廖雪峰 廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程 崔庆才 崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析 莫烦Python 专注Python、机器学习、深度学习 唐松 专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析 捕蛇者说 编程、程序员、Python FxxkPython 学习python的正确姿势 wistbean Python 大佬 Piglei Python 大佬 TendCode Python 大佬 追梦人物的博客 Python Django 大佬 the5fire 《Django企业开发实战》作者，关注Python、Django、Vim、Linux、Web开发 小明明S À DOMICILE 《Python Web开发实战》作者，Python 大佬 Python之禅 Python 大佬 Python 知识圈 Python知识圈 - 实用的Python教程网站 Python 教程网 小詹学Python，专注Python学习 烂笔头 j_hao104 Python大佬 咸鱼日常 专注Python爬虫，有许多JS逆向文章 AnSheng Python 全栈大佬 夏溪辰 云栖社区特邀爬虫工程师，Python大佬 高级农民工 Python大佬 云爬虫技术研究笔记 Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家 云爬虫技术研究笔记(CSDN) Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家 Jack Cui CSDN博客专家，Python 大佬 学习资源 Python爬虫人工智能学习教程 Python爬虫人工智能学习教程分享 Python 中文学习大本营 Python 中文学习大本营 Python 资源大全中文版 Python 资源大全中文版 组织社区 PyChina Python 中国社区 PyCon China 中国 Python 开发者大会 蠎周刊 蠎周刊 - 汇集全球蠎事儿 爬虫相关 镀金的天空 GlidedSky 镀金的天空，在线爬虫练习题库 夜幕爬虫安全论坛 一个专注于爬虫与 PC/Web/ 移动端安全领域技术交流的社区，社区由夜幕团队 NightTeam 创办，旨在提升开发者对爬虫与软件安全防护的理解 西刺免费代理IP 每日更新免费HTTP代理，所有代理均为6675端口高匿代理，可隐藏IP 爬虫IP代理池 爬虫IP代理池 云打码 采用全球领先的秒传识别系统，50%图片零秒识别，人工平均处理时间0-3秒 超级鹰 专业的验证码云端识别服务,让验证码识别更快速、更准确、更强大 八爪鱼采集器 一款使用简单、功能强大的网络爬虫工具，完全可视化操作，无需编写代码，内置海量模板，支持任意网络数据抓取 Python 逆向 Python 逆向相关资源 Python 爬虫集合 Python 爬虫集合 Python 入门网络爬虫之精华版 Python 入门网络爬虫之精华版 爬虫项目进阶实战 Python3 爬虫项目进阶实战、JS加解密、逆向教程、css 加密、字体加密 Python 模拟登陆一些大型网站 Python 模拟登陆一些大型网站 系统化学习 Python 爬虫 系统化学习 Python 爬虫 Python3 网络爬虫实战 Python3 网络爬虫实战 在线视频 腾讯课堂 腾讯推出的专业在线教育平台，聚合大量优质教育机构和名师 网易云课堂 网易旗下一个专注职业技能提升的在线学习平台。立足于实用性的要求，与多家教育培训机构和行业的专家、讲师建立合作 中国大学 MOOC 中国大学MOOC(慕课)，国家精品课程在线学习平台 黑马程序员 致力于培养中级程序员，是业内以口碑闻名的IT教育培训机构 课工场 更可靠的IT就业教育平台，针对大学生量身定制人工智能、大数据、云计算、区块链、Java大数据开发等大学生IT培训课程 极客学院 极客学院作为中国专业IT职业在线教育平台,拥有海量高清IT职业课程,涵盖30+个技术领域 慕课网 慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课 尚硅谷 尚硅谷Java培训，谷粉与老学员为你推荐的Java培训、Web前端培训、前端培训、大数据培训、Python培训；0基础入学，学员就业起薪屡创新高！ 实验楼 国内领先的IT在线编程及在线实训学习平台，专业导师提供精选的实践项目，创新的技术使得学习者无需配置繁琐的本地环境，随时在线流畅使用 优达学城 Udacity是来自硅谷的前沿技术平台，为广大学子提供WEB前端开发、Python/JAVA编程、IOS/Android开发、人工智能开发等一系列在线课程及实战项目，满足学员灵活的学习需求 51CTO学院 51CTO学院IT职业在线教育平台是依托12年行业品牌、1400万IT技术用户建立的专业IT技能学习培训平台，已签约1000多位技术专家发布了12万个自学式实战视频教程 CSDN 学院 CSDN 学院作为IT在线教育平台,涵盖人工智能、考试认证、移动开发、大数据技术领域职业课程 老男孩IT教育 隶属北京一天天教育科技有限公司,是一直专注于Linux培训、Linux系统及架构师培训、Python培训、网络安全培训，大数据实战的高端培训机构 千锋教育 千锋教育 - 坚持教育初心，坚持面授品质，IT培训良心品牌 博客论坛 鱼C工作室 鱼C工作室-免费编程视频教学|Python教学|Web开发教学|全栈开发教学|C语言教学|汇编教学|Win32开发|加密与解密|Linux教学 吾爱破解 致力于软件安全与病毒分析的前沿，丰富的技术版块交相辉映，由无数热衷于软件加密解密及反病毒爱好者共同维护 廖雪峰 廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程 崔庆才 崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析 莫烦Python 专注Python、机器学习、深度学习 唐松 专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析 阮一峰 上海财经大学世界经济博士研究生，计算机科普博主，对自由软件有着坚定不移的信念 学习平台 菜鸟教程 提供了编程的基础技术教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识 W3school 领先的 Web 技术教程 C语言网 C语言网 - 领先实用的编程在线学习网站 前端网 前端网，最好的自学web前端网站 牛客网 牛客网 - 互联网求职神器和备考学习平台 How2J How2J的Java教程, 内容涵盖J2SE、WEB前端、J2EE、框架技术等全面的Java内容 站长工具 新浪短网址 多种后缀短网址生成 百度短网址 百度旗下专业的网址缩短服务 站长工具 - 站长之家 站长工具,SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询 阿里云 whois 查询 whois查询,域名whois,域名注册信息,whois查询工具,whois信息,域名信息 NnameBeta 国际域名搜索、域名注册、国别域名注册、域名比价 Domcomp 域名比价，Domain Name Price and Availability. 仿站工具箱 在线仿站工具箱 超级 SEO 外链工具 网站自动化宣传机器/免费的超级外链工具可批量增加外链 百度站长平台 百度搜索资源平台 - 让网站更具价值 搜狗站长平台 搜狗站长平台 - 全面掌握在搜狗搜索中的数据表现 360 站长平台 360 站长平台 - 给网站带来更多流量和展现 Google 站长平台 Google 网站站长 - 支持、学习、互动交流和 Search Console – Google Bing 网站管理员工具 Bing 网站管理员工具 百度广告联盟 百度广告联盟为您的流量增值 Google AdSense Google 广告平台 百度统计 百度统计 — 最大的中文网站分析平台 友盟+ 国内领先的第三方全域数据智能服务商 ICP/IP地址/域名信息备案管理系统 工业和信息化部ICP/IP地址/域名信息备案管理系统 全国互联网安全管理服务平台 公安备案网 - 全国互联网安全管理服务平台 IT工具箱 在线工具 - 程序员的工具箱 站长工具、代码格式化、压缩、加密、解密、下载链接转换等 在线工具 - OSCHINA.NET社区 常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等 记磊工具箱 Dns检测、CSS格式化、超级Ping、端口扫描等 孟坤工具箱 css一键美化、文本差异比较、代码高亮等 Syntax Highlight Syntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码 Text to ASCII Art Generator Text to ASCII Art Generator，字符串转成 ASCII 码图案 MDEditor 开源在线 Markdown 编辑器 临时邮箱 匿名注册不常用的网站/论坛，保护隐私免骚扰 SM.MS SM 免费图床，每个文件最大支持 5MB 路过图床 免费公共图床，支持最大10MB、批量上传 Greasy Fork 安全、实用的用户脚本大全 Hello World 大全 收集了大约481种 Hello World 程序，涵盖了目前已知的所有编程语言，另加上 67 人类语言 动画展示各种路径搜索算法 动画展示各种路径搜索算法 IT eBooks 可以下载IT电子书籍的网站（英文） GEEKTyper 在线模拟黑客工作的虚拟桌面系统，提供多种黑客工作的场景 免费计算机编程类中文书籍 免费计算机编程类中文书籍 EaseUS Partition Master 磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间 文件处理 Convertio 在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式 Office-Converter 免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式 TinyPNG PNG/JPG图片在线压缩利器 Squoosh Google开源在线压缩、调整工具，支持WebP ILoveIMG 永远免费的在线图片处理工具，可在线编辑，压缩、裁剪、转换、水印等 Smallpdf Smallpdf - A Free Solution to all your PDF Problems,PDF压缩、转换、分割、合并等 PHOTOMOSH 故障艺术在线生成，可以输出jpg、gif和视频 稿定抠图 免费在线抠图软件,图片快速换背景-抠白底图 U钙网 完全免费的LOGO在线设计制作工具 SVGOMG SVG在线压缩平台 在线图片透明圆角处理 在线图片透明圆角处理 草料二维码 国内创建二维码在线应用 Logaster 在线免费创建简单logo及名片设计 Preloaders Loading 懒加载动画在线制作 Loading 制作GIF、SVG、CSS加载动画图标 waifu2x 图片智能无损放大2倍，适合动漫、插画等 智图 腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台 音乐免费下载 全网音乐免费下载工具 OK资源采集 OK资源采集-最新影视资源大全 网易见外工作台 针对视频、图片、文档、音频都可以进行翻译转写操作，每天两小时免费使用 HiPDF 一站式解决所有PDF相关的问题 视频鱼 在线下载各大网站视频的网站 ScreenToGif 开源、轻量级却非常强大的录屏软件，快速将屏幕录制成高清GIF 设计素材 Iconfont 阿里巴巴矢量图标库，提供矢量图标下载、在线存储、格式转换等功能 Font Awesome 一个基于CSS 和 LESS 的字体和图标工具包 Flaticon 海量扁平化免费的图标库 icons8 独特系统平台风格和web图标库，下载免费图标，音乐 千图网 海量原创设计模板免费下载 昵图网 国内海量平面免费素材下载 千库网 免费 png 图片背景素材下载 Pexels 才华横溢的摄影作者在这里免费分享最精彩的素材照片和视频 必应壁纸 必应每日高清壁纸 Piqsels 精美的免版税图库 私藏字体 优质字体免费下载站 第一 PPT 网 免费 PPT 模板下载 吾道幻灯片 全新的office生产力工具，支持演示文稿、PPT模板、协同办公，可以帮助用户轻松创建具有视觉吸引力的幻灯片 Mixkit 免费、高质量、可商用的视频素材分享网站 The Stocks 对各大图片网站进行整合，免费优质图片下载 极简壁纸 高质量精品壁纸网站 NASA Image and Video Library 美国国家航天局的官方库，从此太空类的素材再也不是问题 Unsplash 质量超高的免费图片素材库，无需注册，直接下载 WordArt 文字云工具 效率软件 分流抢票 全程自动抢票,自动抢候补,自动识别验证码,多线程秒单、稳定捡漏,支持多天、多车次、多席别、多乘客等功能 PanDownload 百度网盘下载神器 Quicker 为常用操作建立捷径，PC 快捷动作面板，让效率触手可及! 万彩办公大师 免费、轻松处理文档/音视频/图片的工具 LICEcap 简洁易用的动画屏幕录制软件，它可将屏幕录像的内容直接保存为高质量（每帧颜色数量可超过256）GIF动态图片格式 Snipaste 简单但强大的截图工具，支持截图 + 贴图 FSCapture 一个强大的，轻量级的，功能齐全的屏幕捕获工具 Everything 速度最快的的文件搜索工具 DeskPins 顶置任意窗口 TrafficMonitor 一个用于显示当前网速、CPU及内存利用率的桌面悬浮窗软件 PicGo 由 electronic-vue 构建的简单而精美的图片上传工具 PowerToys 微软为 Windows 系统推出的一系列免费实用小工具合集 Dism++ 一款根据微软底层的架构结构设计的一个系统维护工具，全球第一款基于 CBS 的 Dism GUI 实现 ColorPix 屏幕取色小工具 CCleaner 一款免费的系统优化和隐私保护工具 GifCam 集录制与剪辑为一体的屏幕 GIF 动画制作工具，录制后的动画可以逐帧编辑 EV录屏 一款免费并且不添加水印的录屏工具 Fliqlo 一款极简主义的时钟屏保软件 Fences 栅栏管理桌面，使桌面更加整洁有条理 Q-dir 多窗口文件整理工具 WGestures 鼠标手势工具 XMind 一个全功能的思维导图和头脑风暴软件 速盘 免登录，自动查询提取码，极速的度盘下载工具 f.lux 国外开源的护眼软件，通过根据时间调节屏幕颜色，减少蓝光对视力的影响 云服务商 阿里云 阿里云 - 为了无法计算的价值 腾讯云 腾讯云 - 产业智变 云启未来 百度云 百度云 - 计算无限可能 华为云 华为云 - +智能，见未来 京东云 京东云 - 遇见无限可能 西部数码 西部数码 - 云服务器、虚拟主机、域名注册17年知名云计算服务提供商！ 景安云 景安云 - 专业的数据中心服务商 七牛云 七牛云 - 国内领先的企业级云服务商 又拍云 又拍云 - 加速在线业务-CDN-云存储 美橙互联 美橙互联 - 域名注册、企业建站、云服务器、企业网络推广整体解决方案服务商！ UCloud UCloud - 中立 安全 可信赖的云计算服务商 AWS AWS 云服务 - 专业的大数据和云计算服务以及云解决方案提供商 Microsoft Azure Azure. Invent with purpose. GoDaddy GoDaddy - 提供域名注册和互联网主机服务的美国公司 Cloudflare Cloudflare - 网络性能和安全公司 jsDelivr jsDelivr - A free, fast, and reliable Open Source CDN for npm and GitHub 众包平台 猿急送 专注于 IT 众包领域，职位内容大多集中于 UI 设计、产品设计、程序开发、产品运营等需求 开源众包 开源中国旗下外包网站，项目大多是团队的整包项目，适合多人组团接单 外包大师 PMCAFF旗下的一个众包开发平台，目前以技术开发为主，以众包开发和自有开发相结合形式运营 人人开发 集可视化开发，应用市场，威客众包，PaaS云于一体的企业级应用服务平台 快码 提供智能硬件、各种智能共享项目解决方案，为互联网创业者提供APP、小程序、公众号开发。 我爱方案网 专注于硬件类外包，电子方案开发供应链众包平台，软件外包，方案，硬件开发方案，硬件设计开发 英选 提供可信赖的定制开发外包服务，包括企业品牌官网、电商系统及创新定制产品开发 智筹 为企业&创业者提供互联网高级人才直租服务。按次直租，解决临时、突发问题；按月直租，建立长期兼职合作；按任务直租，解决有明确预算的外包任务 开发邦 互联网软件定制开发与软件外包开发服务，十年互联网软件定制开发经验 码市 Coding 推出的互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作 自由职客 自由职客是权威的IT互联网行业灵活用工交易平台，外包，众包，兼职，招聘，erp，sap 解放号 解放号众包平台提供软件开发外包、人力驻场服务等软件项目外包服务。解放号的软件项目交付全流程可视化监控与全生命周期管理能力 程序员客栈 领先的程序员自由工作平台，38万+优秀开发者，您的专属云端开发团队，BAT级别的开发者，标准化的服务和交付 码易 智网易联旗下IT软件服务平台，集软件商城、企业应用、电商软件、crm软件、商务服务平台于一体的一站式软件外包开发服务平台 电鸭社区 电鸭社区旨在推动自由工作方式在国内渐进式发展，区别于传统方式的工作职位，倡导「只工作，不上班」的工作心态 Sxsoft 中国最早的外包服务平台，18年口碑服务，20万程序员、100+专业软件开发公司，专注解决各类软件开发需求 实现网 为企业提供BAT等名企背景的、靠谱的开发设计兼职人才和自由职业者，满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求 智城外包网 零佣金开发资源平台，认证担保，全程无忧，专业的软件外包网和项目外包、项目开发、人力外派、短期招聘、人力资源交易平台 更多导航 创造狮导航 创造狮，一个创意工作者的导航，专注分享正版优质设计、前端、产品、运营的书签导航，设计教程、设计规范、颜色搭配、灵感创意、前端框架、开发者工具、互联网新品推荐、运营数据分析、自媒体和工具利器好用的分类导航大全 大数据导航 大数据导航，以大数据产业为主，大数据工具为辅，给用户提供一个更加快速找到大数据相关的工具平台 优设导航 优设网站导航为设计师提供ps教程、UI设计、素材下载、高清图库、配色方案、用户体验、网页设计等全方位设计师网站导航指引 牛导航 实用工具导航 聚BT 聚BT - 聚合最优质的BT、磁力资源 ShareHub ShareHub - 资源和工具的集合 狼牌工作网址导航 工具，资源，方法，All IN ONE的办公工作网址导航 COPYRIGHT 2019 - 2020 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY Chocolate $(document).ready(function () { return $(document).on(\"click\", \".has-sub\", function () { var e = $(this); $(this).hasClass(\"expanded\") ? $(\".has-sub ul\").each(function (s, i) { var t = $(this); e.find(\"ul\")[0] != i && setTimeout(function () { t.attr(\"style\", \"\") }, 300) }) : setTimeout(function () { e.find(\"ul\").attr(\"style\", \"\") }, 300) }), $(\".user-info-menu .hidden-sm\").click(function () { $(\".sidebar-menu\").hasClass(\"collapsed\") ? $(\".has-sub.expanded > ul\").attr(\"style\", \"\") : $(\".has-sub.expanded > ul\").show() }), $(\"#main-menu li ul li\").click(function () { $(this).siblings(\"li\").removeClass(\"active\"), $(this).addClass(\"active\") }), $(\"a.smooth\").click(function (s) { s.preventDefault(), public_vars.$mainMenu.add(public_vars.$sidebarProfile).toggleClass( \"mobile-is-visible\"), ps_destroy(), $(\"html, body\").animate({ scrollTop: $($(this).attr(\"href\")).offset().top - 30 }, { duration: 500, easing: \"swing\" }) }), !1 }); var href = \"\", pos = 0; $(\"a.smooth\").click(function (s) { $(\"#main-menu li\").each(function () { $(this).removeClass(\"active\") }), $(this).parent(\"li\").addClass(\"active\"), s.preventDefault(), href = $(this).attr(\"href\"), pos = $(href).position().top - 30 })"}],"posts":[{"title":"最短路","slug":"图中最短路","date":"2020-12-20T01:36:22.000Z","updated":"2020-12-20T14:14:16.928Z","comments":true,"path":"2020/12/20/图中最短路/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/20/%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"Floyd Floyd—&gt;求图中任意两点之间的距离. Floyd怎么来的? 动态规划的思想 1234567① 首先定义一个三维数组 f[k][x][y] 表示只允许经过节点1到k,节点x到节点y的最短路长度② 所以f[n][x][y],即节点x到节点y的最短路长度③ f[k][x][y]=min(f[k-1][x][y],f[k-1][x][k] + f[k-1][k][y]);改进:不难发现我们可以把第一维优化掉(因为在阶段k时,f[x][k]和f[k][y]不会被更新) 即 f[x][y]=min(f[x][y],f[x][k]+f[k][y]) Floyd代码实现1234567891011//Floydconst int N = 1e2+5;const int inf = 1e9;int dis[N][N];//dis初始化为inf,dis[i][j]表点i到点j的最短距离.void Floyd(int n,int **dis)&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);&#125; Floyd应用 (复杂度:O(n^3)) 多源最短路 图上的传递闭包,任意两点的连通关系. 传递闭包例题 N≤500,可以看出复杂度要求是O(n^3). (但是500^3=125,000,000 容易卡常数,详情见下面第三重循环剪枝) 由于胜负关系具有传递性,则可以用Floyd求出任意两点的胜负关系(传递闭包). 可以定义关系(初始化dis[] []为0) dis[a] [b]==1 表示a赢了b dis[a] [b]==0并且dis[b] [a]==0 表示a与b胜负关系无法预知. 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 505;int n, m, a, b,dis[N][N];int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; memset(dis, 0, sizeof(dis)); for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; dis[a][b] = 1; &#125; for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) &#123; if (dis[i][k])//第三层剪枝 因为只有dis[i][k]=1,第三重循环才是有意义的 &#123; for (int j = 1; j &lt;= n; j++) dis[i][j] = max(dis[i][j], dis[i][k] &amp; dis[k][j]);//i赢k,k赢j---&gt;i赢k &#125; &#125; int ans = 0; for(int i=1;i&lt;=n;i++) for (int j = i+1; j &lt;= n; j++) if (dis[i][j] == 0 &amp;&amp; dis[j][i] == 0) ans++; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Dijkstra(迪杰特斯拉) 该算法主要用来解决 图中没有负边的单源最短路 问题(因为dj算法判断负环比较困难) 复杂度O((n+m)logn) 即 mlogn 算法实现的大致流程 设置s为源点,dis[a]表示源点s到点a的最短距离,初始化dis[s]=0,dis[i]=inf,将s加入最小堆 每次从堆中取出一个点x(肯定是新加入的点影响到原结果),遍历x的所有邻接边edge(x y w),比较dis[y]与dis[x]+w的大小 ——即松弛操作 以收录的点,即被最小堆弹出过的点, 对任一未收录的顶点v,dis[v]表示从s到v的最短路径,但是该最短路径 仅经过所有被收录的顶点. Dijkstra模板代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 1e9, N = 1e5, M = 1e6;//链式前向星int head[N], cnt = 0, n, m;struct Edge&#123; int v, w, next;&#125;edge[M];void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u]; head[u] = cnt++;&#125;//Dijkstraint vis[N], dis[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;//默认是最大堆,最大堆丢负数--&gt;最小堆//用最小堆 是为了确定 哪个是下一个点 基本思想就是 不断地从未收录的点集中收录顶点(依据是dis值)void dijkstra(int s)&#123; while (q.size()) q.pop(); //初始化 for (int i = 1; i &lt;= n; i++) vis[i] = 0, dis[i] = inf; dis[s] = 0; q.push(make_pair(0, s)); //pair排序是按照pair.first进行排序的 所以第一个存距离，第二个存点 //主要部分 while (q.size()) &#123; int now = q.top().second;//堆中dis最小值的点 q.pop(); //即已收录的点集合 到 未收录点集合距离最小的点 if (vis[now]) continue; vis[now] = true; //松弛 for (int i = head[now]; ~i; i = edge[i].next) &#123; int u = now, v = edge[i].v, w = edge[i].w;// u(now) v w if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(make_pair(-dis[v], v)); //最大堆丢负数 变最小堆 &#125; &#125; &#125;&#125; 例题–一条商业线的最短路问题 问题思路 思路1 以 起点 为源点 跑 单源最短路,得到dis1数组; 以 终点 为源点 跑 单源最短路,得到dis2数组; 枚举每条商业线edge(u,v,w),ans=min{ans , dis1[u]+dis2[v]+w , dis1[v]+dis2[u]+w}; 最后再 ans=min(ans,不走商业线的最短距离); 思路2(分层图最短路) 跑一次单源最短路(变形版),记录答案dis[u] [0/1] dis[u] [0]表示从起点到节点u没有经过商业线时的最短路,松弛时可以选择商业线或者经济线 dis[u] [1]表示从起点到节点u经过商业线后的最短路,在松弛的时候只能选择经济线. 代码实现思路1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 1e9, N = 1e5, M = 1e6;//链式前向星int head[N], cnt = 0, n, m, k;int s, e;//起点,终点struct Edge&#123; int v, w, next;&#125;edge[M];void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u]; head[u] = cnt++;&#125;//Dijkstraint vis[N], dis1[N], dis2[N], path1[N], path2[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;//默认是最大堆,最大堆丢负数--&gt;最小堆//用最小堆 是为了确定 哪个是下一个点void dijkstra(int s,int* dis,int* path)&#123; while (q.size()) q.pop(); //初始化 for (int i = 1; i &lt;= n; i++) vis[i] = 0, dis[i] = inf, path[i] = -1; dis[s] = 0; q.push(make_pair(0, s)); //pair排序是按照pair.first进行排序的 所以第一个存距离，第二个存点 //主要部分 while (q.size()) &#123; int now = q.top().second;//堆中dis最小值的点 q.pop(); //即已收录的点集合 到 未收录点集合距离最小的点 if (vis[now]) continue; vis[now] = true; //松弛 for (int i = head[now]; ~i; i = edge[i].next) &#123; int u = now, v = edge[i].v, w = edge[i].w;// u(now) v w if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(make_pair(-dis[v], v)); //最大堆丢负数 变最小堆 path[v] = u; &#125; &#125; &#125;&#125;void output(int ss)&#123; if (ss == s) &#123; cout &lt;&lt; ss; return; &#125; output(path1[ss]); cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; ss;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; s &gt;&gt; e; int mindis = inf; //经济线 cin &gt;&gt; m; init(); while (m--) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); add(v, u, w); &#125; dijkstra(s, dis1, path1); dijkstra(e, dis2, path2); //商业线 cin &gt;&gt; k; int L = -1, R = -1, id = -1;//记录一下从哪一站乘坐商业线 以及商业线的左右节点 while (k--) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; //mindis = min(mindis, dis1[u] + dis2[v] + w,dis1[v] + dis2[u] + w); if (mindis &gt; dis1[u] + dis2[v] + w) &#123; L = u, R = v, id = u; mindis = dis1[u] + dis2[v] + w; &#125; if (mindis &gt; dis1[v] + dis2[u] + w) &#123; L = v, R = u, id = v; mindis = dis1[v] + dis2[u] + w; &#125; &#125; if (mindis &gt; dis1[e])//最短距离是 不使用商业票的时候 &#123; cout &lt;&lt; &quot;路线依次:&quot;;//输出路线 output(e); cout &lt;&lt; endl &lt;&lt; &quot;Ticket Not Used&quot; &lt;&lt; endl &lt;&lt; dis1[e] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;路线依次:&quot;;//输出路线 //使用商业线时,路线应该为 e--&gt;L--&gt;R--&gt;s output(L);//递归反向输出第一段 e--&gt;L cout &lt;&lt;&quot;-&gt;&quot;; int tmp = R; while (tmp != -1)//递推正向输出第二段R--&gt;s &#123; if (path2[tmp] != -1) cout &lt;&lt; tmp &lt;&lt; &quot;-&gt;&quot;; else cout &lt;&lt; tmp; tmp = path2[tmp]; &#125; //输出商业线车站号 和 总时间 cout &lt;&lt; endl &lt;&lt;&quot;商业线车站号:&quot;&lt;&lt;id &lt;&lt; endl &lt;&lt;&quot;最短时间:&quot;&lt;&lt; mindis; &#125; return 0;&#125; 注意: 输出路径时,从起点输出时递归输出(因为记录的是上一个位置,对应反向查找的过程,从终点输出时直接递推正序输出即可 思路2—分层图12//待补充// Bellman-ford算法及其队列优化(SPFA)Bellman-ford Bellman-ford算法可以给出源点s至图中其他所有点的最短路 以及 对应的前驱子图. Bellman-ford算法的正确性基于以下事实: 最短路经过的路径条数 ＜ 图中点的个数.(若 ≥ 点的个数,则意味着某点被重复经过) 当松弛边(u,v)时,如果dis[u]已经是最短路,并且u是v的前驱点,则松弛之后dis[v]也是最短路,并且以后其dis值不会改变. 12345678910111213141516171819202122232425//Bellman-fordfor(int i=1;i&lt;=n;i++)&#123; dis[i]=inf;//初始化所有点的dis值都是inf pre[i]=0;&#125;dis[s]=0;for(int k=1;k&lt;n;k++)//一层一层 松弛n-1次 for(int i=1;i&lt;=m;i++)//每轮松弛所有的边 &#123; int u=edge[i].u , v=edge[i].v , w=edge[i].w; if(dis[v] &gt; dis[u]+w) &#123; dis[v]=dis[u]+w; pre[v]=u; &#125; &#125;//判负环--如果第n次还可以松弛的话for(int i=1;i&lt;=m;i++)&#123; int u=edge[i].u , v=edge[i].v , w=edge[i].w; if(dis[v] &gt; dis[u]+w) cout&lt;&lt;&quot;存在负环&quot;&lt;&lt;endl; &#125;时间复杂度为O(nm) Bellman-ford算法完美解决了负权边的问题,但是它的复杂度过高,堪比复杂度为O(n^3)的Floyd算法,让人无法接受. (m最大值可以为(n*(n-1))/2,也就是说m可以达到n^2.) 仔细观察Bellman-ford算法的松弛过程 在第一轮松弛的过程中,最短路 边数为1 的点被确定了. 在第二轮松弛的过程中,最短路 边数为2 的点被确定了. …… 在第n-1轮松弛的过程中,最短路 边数为n-1的点被确定了. 在Bellman-ford算法中,每一轮都有很多无效的松弛操作,怎样可以避免呢? —&gt; 解决了这个问题就得到了 Bellman-ford的队列优化算法—SPFA SPFA(Shortest Path Faster Algorithm) 在之前观察Bellman-ford算法的松弛过程中,可以看出,松弛操作仅仅发生在最短路径 前导节点中 已经成功松弛过的节点上. 第一轮,与s邻接的点被松弛—&gt;最短路 边数为1 的点被确定 与第一轮被松弛的点 相邻接的点被松弛 —&gt;最短路 边数为2 的点被确定 … 一直到最短路 边数为n-1的点被确定 算法结束 为了每次都只做有效的松弛 建立一个队列 队列中储存被成功松弛的点 每次从队首取点并松弛其邻接点 如果邻接点松弛成功则将其放入队列 需要注意的point: 因为队列中存储的是 每一层的点,如何避免重复入队? —-&gt; 用数组记录一下是否已经在队列中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 1e9, N = 1e5, M = 1e6;//链式前向星int head[N], cnt = 0, n, m;struct Edge&#123; int v, w, next;&#125;edge[M];void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u]; head[u] = cnt++;&#125;//bfs判负环bool flag[maxn];void bfs(int s)&#123; queue&lt;int&gt; Q; while(Q.size()) Q.pop(); Q.push(s); flag[s] = 1; while(Q.size()) &#123; int now = Q.front(); Q.pop(); for(int i=head[now];~i;i=edge[i].next) &#123; int u = now,v = edge[i].to; if(!flag[v]) &#123; flag[v] = 1; Q.push(v); &#125; &#125; &#125;&#125;//spfa(Shortest Path Faster algorithm)int vis[N],cnt[N],dis[N],pre[N];//①vis - 点在不在队列中 ②cnt[x]表示点x最短路的边数(即第几层) ③dis - 距离 ④pre - 前驱//如果cnt[x]&gt;=n,则表明出现了负环queue&lt;int&gt; q;void spfa(int s)&#123; while(q.size()) q.pop(); //初始化 for(int i=1;i&lt;=n;i++) vis[i]=cnt[i]=pre[i]=0,dis[i]=inf; //队列中加入初始点 vis[s]=1,dis[s]=0; q.push(s); //主要部分 while(q.size()) &#123; int x = q.front(); q.pop(); vis[x]=0;//vis[]记录的是点在不在当前队列中,此时x出了队列 //松弛操作 for(int i=head[x];~i;i=edge[i].next) &#123; int u=x,v=edge[i].v,w=edge[i].w; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; pre[v] = u; //cnt[u] 表点x最短路的边数(即第几层) //cnt[v] 相当于从x走(x,y)这条边到达了y cnt[v] = cnt[x] + 1; if(cnt[v]&gt;=n) &#123; //出现负环 v在负环上,dis[v]= -inf 并且所有能被v到达的点dis均会变成-inf bfs(v);//可以跑一下bfs 然后用flag数组标记一下所有负环的点 &#125; if(!vis[v]&amp;&amp;!flag[v])//当前点v没有在队列中，并且不是负环的一部分 &#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;时间复杂度平均是O(km)k是一个小于n的小常数(大多情况下都很小),但是在特殊情况下k可能会很大 (即spfa在特殊情况下时间复杂度会退化成O(nm)) 思考: 最短路存在吗? —–①当有负环的时候,最短路不存在 ②S不可达 即dis[s]==inf spfa例题—喵星收税关于最长路 在spfa中,只需要将 **①dis初始值 改成 -inf ②松弛条件由 dis[v] &gt; dis[u] + w —&gt;dis[v] &lt; dis[u] + w即可** 123456789101112131415161718192021222324252627282930313233//Dijkstra 跑 最长路int vis[N], dis[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void dijkstra(int s)&#123; while (q.size()) q.pop(); for (int i = 1; i &lt;= n; i++) vis[i] = 0, dis[i] = -inf;//原本:dis[i] = inf dis[s] = 0; q.push(make_pair(0, s)); while (q.size()) &#123; int now = q.top().second,v = q.top().first; q.pop(); //if (vis[now]) continue; //这句话原本表明 一个点一旦从最小堆中弹出,则这个点的dis到达了最小值 //但如果是最长路 一个点一旦从最大堆中弹出,则这个点的dis到达了最大值??? 可惜结论是不对的 我们不太需要判断vis可以将所有vis[]变量删除即可 取出v = q.top().first即距离取出来 if(v &lt; dis[now]) continue; vis[now] = true; for (int i = head[now]; ~i; i = edge[i].next) &#123; int u = now, v = edge[i].v, w = edge[i].w; if (dis[v] &lt; dis[u] + w)//原本:dis[v] &gt; dis[u] + w &#123; dis[v] = dis[u] + w; q.push(make_pair(dis[v], v)); //原本:最大堆里面丢负数当最小堆,但是现在要用最大堆 所以去掉负号 &#125; &#125; &#125;&#125;","categories":[{"name":"C++图论","slug":"C-图论","permalink":"https://coincidenceboy.github.io/categories/C-%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://coincidenceboy.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2020-12-19T10:26:03.000Z","updated":"2020-12-19T13:19:35.426Z","comments":true,"path":"2020/12/19/最小生成树/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"Kruskal(克鲁斯卡尔) 基于边的贪心算法 一句话—&gt;”每次贪心地将图中最小的非树边标记为树边,非法则跳过.” 将边按照权值小–&gt;大排序 按顺序考虑每条边,只要这条边和我们已经选择的边不构成回路,就保留该边,否则放弃这条边. 成功选择(n-1)条边后,则构成最小生成树; 如果无法选择出(n-1)条边,这说明原图不连通 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//kruskal算法 记录图的拓扑 可以简单用struct Edge来实现. 因为该算法不需要遍历点(点的出边等)//而且不需要考虑边的方向性. 每条边保存一次即可const int N = 1e4+5;const int M = 1e5+5;struct Edge&#123; int u,v,w; bool operator &lt; (const Edge&amp; p)const &#123;return w &lt; p.w;&#125;&#125;edge[M];int num;//边数//并查集int par[N],cnt[N];void init(int n)&#123; for(int i=1;i&lt;=n;i++) par[i]=i,cnt[i]=1;&#125;int find(int x)&#123; if(par[x]==x) return x; return par[x] = find(par[x]);//①路径压缩&#125;bool unite(int x,int y)&#123; x = find(x),y=find(y); if(x==y) return false; if(cnt[x]&gt;cnt[y]) swap(x,y);//小树挂在大树上.②启发式合并 par[x]=y; cnt[y]+=cnt[x]; return true;&#125;//kruskalint kruskal(int n)&#123; init(n); sort(edge,edge+num); int sum=0,ans=0; for(int i=0;i&lt;num;i++) &#123; if(unite(edge[i].u,edge[i].v)) &#123; ans+=edge[i].w; sum++; if(sum==n-1)//n个点求MST return ans; &#125; &#125; return -1;&#125; Prim(普里姆) 基于点的贪心算法 一句话—&gt;”维护一个连通的点集 , 每次都从不在该点集内的点选出一个加入该连通点集的代价最小的点.” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5,inf=1e9+5;int n,m, min_cost[N], g[N][N] = &#123;&#125;;//邻接矩阵存图bool vis[N];int prim()//点集从1到n&#123; int ans = 0, tot = 1; vis[1] = true; //连通点集不妨从点1开始 for (int i = 1; i &lt;= n; i++) min_cost[i] = g[1][i]; while (true) &#123; int v = 0; //选出一个!vis 并且 到点集距离最小的点 for (int i = 1; i &lt;= n; i++) if (!vis[i] &amp;&amp; (!v || min_cost[v] &gt; min_cost[i])) v = i; //if (!v) break; if (min_cost[v] == inf || !v) break; //没有可以选的点 tot++; ans += min_cost[v]; vis[v] = true; //必定是新加入的点影响了其他未加入的点 到点集的距离 //以这个新点为边点,更新所有未加入点到该点集的距离 for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; min_cost[i] &gt; g[v][i]) min_cost[i] = g[v][i]; &#125; &#125; if (tot != n) return -1;//n个点是否连通 return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) g[i][j] = inf; //初始化g[N][N]为inf int u, v, w; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u][v] = w; g[v][u] = w; &#125; cout &lt;&lt; prim()&lt;&lt;endl; return 0;&#125; 进阶：斐波那契堆优化、平衡树优化 （感兴趣的话自行了解）","categories":[{"name":"C++图论","slug":"C-图论","permalink":"https://coincidenceboy.github.io/categories/C-%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"https://coincidenceboy.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"并查集","slug":"并查集","date":"2020-12-19T10:25:39.000Z","updated":"2020-12-19T11:03:15.146Z","comments":true,"path":"2020/12/19/并查集/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集123456789101112131415161718192021222324const int N = 1e5+5;int par[N],cnt[N];void init(int n)&#123; for(int i=1;i&lt;=n;i++) par[i]=i,cnt[i]=1;&#125;int find(int x)&#123; if(par[x]==x) return x; return par[x] = find(par[x]);//①路径压缩&#125;bool unite(int x,int y)&#123; x = find(x),y=find(y); if(x==y) return false; if(cnt[x]&gt;cnt[y]) swap(x,y);//小树挂在大树上.②启发式合并 par[x]=y; cnt[y]+=cnt[x]; return true;&#125;","categories":[{"name":"C++图论","slug":"C-图论","permalink":"https://coincidenceboy.github.io/categories/C-%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://coincidenceboy.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"图的存储和遍历","slug":"图的存储和遍历","date":"2020-12-19T07:51:43.000Z","updated":"2020-12-19T13:19:40.686Z","comments":true,"path":"2020/12/19/图的存储和遍历/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/19/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/","excerpt":"","text":"图的存储邻接矩阵12345678邻接矩阵: 是一个N*N的二维数组 e[N][N]//无向图---&gt;存两条单向边即可.e[u][v]=w;e[v][u]=w;//无权图---&gt;可以令e[u][v]=1表示u-v之间有一条边,e[u][v]=0表无边e[u][v]=1;//有向带权图e[u][v]=w; 优点:查询速度快,可以直接找到两点之间的关系. 空间负责度为O(n^2),对于稀疏图来说浪费内存. 邻接表1234567891011121314151617181920212223邻接表: 存每一个点的出边可以利用vector&lt;int&gt; G[N]来记录//如果需要记录边权等边上信息,把int--&gt;structG[u]表示点u的 邻接数组,遍历这个vector即可得到 u 可到达的每一个点//无权有向图有一条边 u--&gt;v G[u].push_back(v);//无权无向图有一条边 u--&gt;v G[u].push_back(v); G[v].push_back(u);//有权图如果是vector&lt;int&gt; G[N],例如遍历G[u],只能知道u里面有哪些点,没有更多的信息(例如边权)const int N = 1e4+5;struct edge&#123; int v,w; edge()&#123;v=-1,w=0;&#125; edge(int _v,int _w)&#123;v=_v,w=_w;&#125;&#125;;vector&lt;edge&gt; G[N];void addEdge(int u,int v,int w)&#123; G[u].push_back(edge(v,w)); //G[v].push_back(edge(u,w)); //无向边&#125; 优点:只记录了邻接点的信息,空间复杂度仅为O(m),m为边数 缺点:查询u,v两点关系的时候,需要遍历u的邻接数组,相比较慢. 链式前向星 1234567891011121314151617181920const int N = 1e4+5;const int M = 1e5+5;struct Edge&#123; int v,w,next; //next记录的同head[]也是边的索引id&#125;edge[M];int head[N]=&#123;-1&#125;;//head[u]表 一条u射出的边的索引id. edge[head[u]]表第一条边 之后靠struct里面的next连接所有出边int cnt=0;//当前边的个数void add(int u,int v,int w)&#123;//插入位置为head[]所指链表的头部; edge[cnt].v=v , edge[cnt].w=w , edge[cnt].next=head[u]; head[u]=cnt; cnt++; //edge[]从0开始&#125;遍历时:for (int i=head[now]; ~i; i=edge[i].next) //因为初始化 head[N]=&#123;-1&#125;,-1的补码是全1 ~按位取反 ~（-1）= 0 即条件为假 用数组来模拟链表. 相比较邻接链表而言,边在 链式前向星中存储的相对顺序与输入顺序相反,其他差异不大. 图的遍历 BFS 或者 DFS 例题:树的直径 首先明确 : 树的直径一定是某两个叶子之间的距离. 从树中任选一个点开始遍历这棵树,找到一个距离这个点最远的叶子1,然后再从这个叶子1开始遍历,找到离这个叶子1最远的另一个叶子2,叶子1—叶子2就是树的直径. 两次遍历即可求树的直径.(遍历可以用dfs也可以用bfs,找到距离起点最远的叶子节点即可.) (因为最远距离一定在叶子出现,所以虽然边权值不一定为1,但是可以不用dj等求两点之间最短/长距离,可以用dfs或者bfs) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 5;//链式前向星struct Edge&#123; int v, w, next;&#125;edge[2*N];int head[N] = &#123; -1 &#125;;int cnt;void add(int u, int v, int w)&#123; edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u]; head[u] = cnt++;&#125;//bfsqueue&lt;int&gt; q;bool vis[N];int dis[N];int bfs(int begin)&#123; while (q.size()) q.pop(); memset(dis, 0, sizeof(dis)); memset(vis, 0, sizeof(vis)); vis[begin] = true; q.push(begin); int node = begin, mx_len = 0; while (q.size()) &#123; int now = q.front(); q.pop(); for (int i = head[now]; ~i; i = edge[i].next) &#123; if (!vis[edge[i].v]) &#123; vis[edge[i].v] = 1; dis[edge[i].v] = dis[now] + edge[i].w; if (mx_len &lt; dis[edge[i].v]) &#123; mx_len = dis[edge[i].v]; node = edge[i].v; &#125; q.push(edge[i].v); &#125; &#125; &#125; return node;//返回距离该点最远的点id //return mx_len;&#125;int main()&#123; ios::sync_with_stdio(false); int n, v, w; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; v &gt;&gt; w; add(i, v, w); add(v, i, w); &#125; int a = bfs(1); //直径左端点 int b = bfs(a); //直径右端点 int dis_a[N]; for (int i = 1; i &lt;= n; i++) dis_a[i] = dis[i]; bfs(b); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; max(dis_a[i], dis[i]) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++图论","slug":"C-图论","permalink":"https://coincidenceboy.github.io/categories/C-%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"图的存储和遍历","slug":"图的存储和遍历","permalink":"https://coincidenceboy.github.io/tags/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"}]},{"title":"前缀和&差分","slug":"前缀和&差分","date":"2020-12-19T03:02:08.000Z","updated":"2020-12-19T03:56:35.167Z","comments":true,"path":"2020/12/19/前缀和&差分/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/19/%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和 1234567891011121314151617181920212223//一维前缀和 初始化int a[N]=&#123;0&#125;,dp[N]=&#123;0&#125;;for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; dp[i]=s[i-1]+a[i];&#125;//性质dp[i] = dp[i-1] + a[i];dp[L,R] = dp[R] - dp[L-1];//二维前缀和 初始化int a[N][M]=&#123;0&#125;,dp[N][M]=&#123;0&#125;;for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;a[i][j]; dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[x-1][y-1]+a[i][j]; &#125;&#125;//性质dp[a,b][c,d]=dp[c][d]-dp[a][d]-dp[c][b]+sum[a][b]; 差分 123456789101112//一维差分 初始化int a[N]=&#123;0&#125;,dp[N]=&#123;0&#125;;for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; dp[i]=a[i]-a[i-1];&#125;//差分数组前缀和 = a[]元素值dp[1]+dp[2]+...+dp[i]=a[i];//差分数组单点修改 = a[]区间整体+- dp[L] += c,dp[R+1] -= c;等价于a[L]+=c,a[L+1]+=c,...,a[R]+=c; 例题 分析: 暴力做法O(q*n),超时 将原数组A—&gt;差分数组B,将区间操作—&gt;单点修改 B数组前缀和即为A数组最终数值.0(n+q) 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2*1e5+5;long long n,q,a[N],b[N];//防止q次操作导致int溢出int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;q; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; b[i]=a[i]-a[i-1]; &#125; int l,r,c; while(q--) &#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; b[l]+=c; b[r+1]-=c; &#125; long long tmp=0; for(int i=1;i&lt;=n;i++) &#123; if(i==1) tmp=b[i],cout&lt;&lt;tmp; if(i&gt;1) tmp+=b[i],cout&lt;&lt;&quot; &quot;&lt;&lt;tmp; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"前缀和&差分","slug":"前缀和-差分","permalink":"https://coincidenceboy.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/"}]},{"title":"尺取法","slug":"尺取法","date":"2020-12-17T07:27:12.000Z","updated":"2020-12-17T12:41:41.852Z","comments":true,"path":"2020/12/17/尺取法/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/","excerpt":"","text":"经典例题-求长度最小的连续区间 使之 sum&gt;=给定整数S 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1005;int n, s, a[N];int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int l = 1, r = 1, sum = 0; int ans = n+1; while (1) &#123; while (r &lt;= n &amp;&amp; sum &lt; s) &#123; sum += a[r++]; &#125; if (sum &lt; s) break; ans = min(ans, r - l); sum -= a[l++]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 平衡字符串问题 why用 尺取法? 所求答案为一个连续的区间. 区间左右端点移动有着明确的方向.—&gt;当前[L,R]满足要求,则L++.当前[L,R]不满足要求,则R++. 给定[L,R],如何判断是否满足要求呢? 用sum1,sum2,sum3,sum4分别记录不包括区间[L,R]这一段时,字符’A’’B’’C’’D’ 先通过替换使4类字符数量一致,再判断剩余空闲位置是否是4的倍数. 123MAX = max(sum1,sum2,sum3,sum4);free = 区间元素个数-[(MAX-sum1)+(MAX-sum2)+(MAX-sum3)+(MAX-sum4)]//若free&gt;=0且为4的倍数,则满足要求;否则不满足. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int ans = 100000, sum1, sum2, sum3, sum4;string s;int main()&#123; cin &gt;&gt; s; int n = s.size(); for (int i = 0; i &lt; n; i++) &#123; if (s[i] == &#x27;Q&#x27;) sum1++; if (s[i] == &#x27;W&#x27;) sum2++; if (s[i] == &#x27;E&#x27;) sum3++; if (s[i] == &#x27;R&#x27;) sum4++; &#125; if (sum1 == sum2 &amp;&amp; sum2 == sum3 &amp;&amp; sum3 == sum4) &#123; cout &lt;&lt; 0 &lt;&lt;endl; return 0; &#125; int l = 0, r = 0, sum = 0; int maxx = max(max(sum1, sum2), max(sum3, sum4)); int free = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4); while (1) &#123; while (r &lt; n &amp;&amp; !(free &gt;= 0 &amp;&amp; free % 4 == 0)) &#123; // [l,r] 不符合条件 - r++ if (s[r] == &#x27;Q&#x27;) sum1--; if (s[r] == &#x27;W&#x27;) sum2--; if (s[r] == &#x27;E&#x27;) sum3--; if (s[r] == &#x27;R&#x27;) sum4--; r++; maxx = max(max(sum1, sum2), max(sum3, sum4)); free = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4); &#125; if (!(free &gt;= 0 &amp;&amp; free % 4 == 0)) break; ans = min(ans, r-l); // [l,r] 符合条件 - l++ if (s[l] == &#x27;Q&#x27;) sum1++; if (s[l] == &#x27;W&#x27;) sum2++; if (s[l] == &#x27;E&#x27;) sum3++; if (s[l] == &#x27;R&#x27;) sum4++; l++; maxx = max(max(sum1, sum2), max(sum3, sum4)); free = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4); &#125; cout &lt;&lt; ans &lt;&lt;endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"线性数据结构","slug":"线性数据结构","permalink":"https://coincidenceboy.github.io/tags/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"单调栈和单调队列","slug":"单调栈和单调队列","date":"2020-12-17T01:08:15.161Z","updated":"2020-12-17T07:19:47.621Z","comments":true,"path":"2020/12/17/单调栈和单调队列/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"","text":"简单分析 伪码实现 单增栈 1234567891011121314//栈顶---&gt;栈底,单调增 (只维护一端:栈顶)stack&lt;int&gt; st;int a[n+1];//a[1]~a[n]源数据a[n+1]=INT_MAX; //为了将栈内元素全部弹出//for(int i=1;i&lt;=n+1;i++)&#123; while(st.size()&gt;0&amp;&amp;a[i]&gt;st.top()) &#123;//谁的加入(即a[i])把你弹出去了,谁就是你往→第一个比你 big 的数 !!! 即while循环里 a[i]就是st.top() 往→第一个big的数 st.pop(); &#125; st.push(a[i]);&#125; 单增队列 1234567891011121314151617181920212223//队首---&gt;队尾,单调增 (维护两端:队首和队尾)deque&lt;int&gt; q;int a[n+1];//a[1]~a[n]源数据int k=3;//窗口大小//初始化队列大小为k-1for(int i=1;i&lt;=k-1;i++)&#123; while(q.size()&gt;0&amp;&amp;a[i]&lt;q.back()) q.pop_back(); q.push_back(a[i]);&#125;//窗口从k开始向右移动,维护一个单增队列for(int i=k;i&lt;=n;i++)&#123; //维护单调性 while(q.size()&gt;0&amp;&amp;a[i]&lt;q.back()) q.pop_back(); q.push_back(a[i]); //再维护窗口大小,保证队列元素都落在窗口内 while(q.size()&gt;0&amp;&amp;(i-队首q.front的元素下标)&gt;=k) q.pop_front(); !!! 此时窗口small值就是q.front();&#125; 经典例题单调栈:直方图求最大矩形面积 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int n, a[N];int a_l[N], a_r[N];//必须存数组下标,因为面积计算公式要用到 区间长度stack&lt;int&gt; st;//需配合a_l和a_r 也必须存数组下标int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; // → a[n + 1] = -1;//保证数组中每个元素 都被 弹出一次 for (int i = 1; i &lt;= n+1; i++) &#123; while (st.size() &gt; 0 &amp;&amp; a[i] &lt; a[st.top()]) &#123; a_r[st.top()] = i; st.pop(); &#125; st.push(i); &#125; // ← while (st.size()) st.pop(); a[0] = -1;//保证数组中每个元素 都被 弹出一次 for (int i = n; i &gt;=0 ; i--) &#123; while (st.size() &gt; 0 &amp;&amp; a[i] &lt; a[st.top()]) &#123; a_l[st.top()] = i; st.pop(); &#125; st.push(i); &#125; long long ans = -1; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans,(a_r[i]-a_l[i]-1)*a[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 单调队列:滑动窗口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;int n,k;int a[N];int a_min[N], a_max[N];//里面存数组下标(直接存值亦可)deque&lt;int&gt; q;//必须存数组下标int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; // min for (int i = 1; i &lt;= n; i++) &#123;//维护单调性 while (q.size() &gt; 0 &amp;&amp; a[i] &lt; a[q.back()]) q.pop_back(); q.push_back(i); //再维护窗口大小,保证队列元素都落在窗口内 while (q.size() &gt; 0 &amp;&amp; (i - q.front()) &gt;= k) q.pop_front(); if (i &gt;= k) a_min[i] = q.front(); &#125; // max q.clear(); for (int i = 1; i &lt;= n; i++) &#123;//维护单调性 while (q.size() &gt; 0 &amp;&amp; a[i] &gt; a[q.back()]) q.pop_back(); q.push_back(i); //再维护窗口大小,保证队列元素都落在窗口内 while (q.size() &gt; 0 &amp;&amp; (i - q.front()) &gt;= k) q.pop_front(); if (i &gt;= k) a_max[i] = q.front(); &#125; for (int i = k; i &lt;= n; i++) cout &lt;&lt; a[a_min[i]] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int i = k; i &lt;= n; i++) cout &lt;&lt; a[a_max[i]] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"线性数据结构","slug":"线性数据结构","permalink":"https://coincidenceboy.github.io/tags/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"vs2019添加c++万能头文件","slug":"vs2019添加c++万能头文件","date":"2020-12-16T07:52:53.000Z","updated":"2020-12-16T09:08:38.000Z","comments":true,"path":"2020/12/16/vs2019添加c++万能头文件/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/16/vs2019%E6%B7%BB%E5%8A%A0c++%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/","excerpt":"","text":"VS2019安装路径下找到VC文件依次进入Tools/MSVC/14.24.28314/include。然后在include内创建一个名称为bits的文件(图示为默认安装路径) 在bits文件夹创建一个stdc++.h并将下面代码复制进去即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// C++ includes used for precompiling -*- C++ -*- // Copyright (C) 2003-2015 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library. This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version. // This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details. // Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation. // You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively. If not, see// &lt;http://www.gnu.org/licenses/&gt;. /** @file stdc++.h * This is an implementation file for a precompiled header. */ // 17.4.1.2 Headers // C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt; #if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif // C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt; #if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"c++万能头","slug":"c-万能头","permalink":"https://coincidenceboy.github.io/tags/c-%E4%B8%87%E8%83%BD%E5%A4%B4/"}]},{"title":"解决win10蓝牙设备连接不上","slug":"关于win10蓝牙设备连接不上","date":"2020-12-16T06:45:44.000Z","updated":"2020-12-16T09:09:54.273Z","comments":true,"path":"2020/12/16/关于win10蓝牙设备连接不上/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/16/%E5%85%B3%E4%BA%8Ewin10%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/","excerpt":"","text":"已配对蓝牙无法连接并且搜索不到 123456789101112131415161718192021222324252627282930313233343536373839404142434445$Source = @&quot; [DllImport(&quot;BluetoothAPIs.dll&quot;, SetLastError = true, CallingConvention = CallingConvention.StdCall)] [return: MarshalAs(UnmanagedType.U4)] static extern UInt32 BluetoothRemoveDevice(IntPtr pAddress); public static UInt32 Unpair(UInt64 BTAddress) &#123; GCHandle pinnedAddr = GCHandle.Alloc(BTAddress, GCHandleType.Pinned); IntPtr pAddress = pinnedAddr.AddrOfPinnedObject(); UInt32 result = BluetoothRemoveDevice(pAddress); pinnedAddr.Free(); return result; &#125;&quot;@Function Get-BTDevice &#123; Get-PnpDevice -class Bluetooth | ?&#123;$_.HardwareID -match &#x27;DEV_&#x27;&#125; | select Status, Class, FriendlyName, HardwareID, # Extract device address from HardwareID @&#123;N=&#x27;Address&#x27;;E=&#123;[uInt64](&#x27;0x&#123;0&#125;&#x27; -f $_.HardwareID[0].Substring(12))&#125;&#125;&#125;################## Execution Begins Here ################$BTR = Add-Type -MemberDefinition $Source -Name &quot;BTRemover&quot; -Namespace &quot;BStuff&quot; -PassThru$BTDevices = @(Get-BTDevice) # Force array if null or single itemDo &#123; If ($BTDevices.Count) &#123; &quot;`n******** Bluetooth Devices ********`n&quot; | Write-Host For ($i=0; $i -lt $BTDevices.Count; $i++) &#123; (&#x27;&#123;0,5&#125; - &#123;1&#125;&#x27; -f ($i+1), $BTDevices[$i].FriendlyName) | Write-Host &#125; $selected = Read-Host &quot;`nSelect a device to remove (0 to Exit)&quot; If ([int]$selected -in 1..$BTDevices.Count) &#123; &#x27;Removing device: &#123;0&#125;&#x27; -f $BTDevices[$Selected-1].FriendlyName | Write-Host $Result = $BTR::Unpair($BTDevices[$Selected-1].Address) If (!$Result) &#123;&quot;Device removed successfully.&quot; | Write-Host&#125; Else &#123;&quot;Sorry, an error occured.&quot; | Write-Host&#125; &#125; &#125; Else &#123; &quot;`n********* No devices foundd ********&quot; | Write-Host &#125;&#125; While (($BTDevices = @(Get-BTDevice)) -and [int]$selected) 将上述代码直接复制粘贴到 Windows PowerShell 里,然后删除出问题的设备,重新搜索蓝牙设备即可.","categories":[{"name":"win10","slug":"win10","permalink":"https://coincidenceboy.github.io/categories/win10/"}],"tags":[{"name":"蓝牙","slug":"蓝牙","permalink":"https://coincidenceboy.github.io/tags/%E8%93%9D%E7%89%99/"}]},{"title":"csp12-13收获","slug":"csp12-13收获","date":"2020-12-13T12:59:01.000Z","updated":"2020-12-17T14:20:44.606Z","comments":true,"path":"2020/12/13/csp12-13收获/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/","excerpt":"","text":"二分找到&gt;=k的第一个位置1234567891011121314151617//下标从1开始,找不到返回-1int lower_bound(int k)&#123; int l=1,r=n,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&gt;=k) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; return ans;&#125; 找到&lt;=k的最后一个位置12345678910111213141516int reverse_lower_bound(int k)&#123; int l = 1, r = n, ans = -1; while (l&lt;=r) &#123; int mid = (l + r) &gt;&gt; 1; if (a[mid] &lt;= k) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; return ans;&#125; 找到==k的第一个位置123456789101112131415161718//下标从1开始,找不到返回-1int find_first(int k)&#123; int l=1,r=n,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(a[mid]==k) &#123; ans = mid; r = mid - 1; &#125; else if(a[mid] &lt; k) l = mid + 1; else r = mid - 1; &#125; return ans;&#125; 找到==k的最后一个位置123456789101112131415161718//下标从1开始,找不到返回-1int find_last(int k)&#123; int l=1,r=n,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(a[mid]==k) &#123; ans = mid; l = mid + 1; &#125; else if(a[mid] &gt; k) r = mid - 1; else l = mid + 1; &#125; return ans;&#125; 例题(整数二分):四个数列和为0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//首先四重枚举肯定超时,所以要减少枚举的次数.//先枚举a和b数组,然后将枚举结果放到一个新的数组ab,//再枚举c和d数组,然后枚举的时候计算它的相反数在ab中出现几次(有序数组last位置-first位置)#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 4005;int n,a[N], b[N], c[N], d[N],ab[N*N];//下标从1开始,找不到返回-1int find_first(int x)&#123; int l = 1, r = n*n, ans = -1; while (r &gt;= l) &#123; int mid = (l + r) &gt;&gt; 1; if (ab[mid] == x) &#123; ans = mid; r = mid - 1; &#125; else if (ab[mid] &lt; x) l = mid + 1; else r = mid - 1; &#125; return ans;&#125;//下标从1开始,找不到返回-1int find_last(int x)&#123; int l = 1, r = n*n, ans = -1; while (r &gt;= l) &#123; int mid = (l + r) &gt;&gt; 1; if (ab[mid] == x) &#123; ans = mid; l = mid + 1; &#125; else if (ab[mid] &gt; x) r = mid - 1; else l = mid + 1; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i] &gt;&gt; d[i]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; ab[(i-1) * n + j] = a[i] + b[j]; &#125; sort(ab + 1, ab + 1 + n * n); int ans = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; int key = -(c[i] + d[j]); int l = find_first(key), r = find_last(key); if (r != -1) ans += r - l + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 例题(浮点二分) 求方程 f(x)=x^6+x-2014 在(0,+∞)的一个解,要求小数点后精确5位 1234567891011121314151617181920212223242526272829//先估算一个区间 f(1)&lt;0 f(10)&gt;0 不妨l=1.0,r=10.0#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-5;double f(double x)&#123; return pow(x, 6) + x - 2014;&#125;double find()&#123; double l = 1, r = 10; while (abs(r - l) &gt; eps) &#123; double mid = (l + r) / 2; if (f(mid) * f(r) &lt;= 0) &#123; l = mid; &#125; else r = mid; &#125; return l;&#125;int main()&#123; ios::sync_with_stdio(false); printf(&quot;%.5lf&quot;, find()); return 0;&#125; 二分答案 二分思想:只要是单调的,都可以二分!!! 问题分析暴力枚举 i,j 将数列B计算出来,然后取它的中位数.时间和空间复杂度均0(n^2),无法接受—&gt;转换思路 如果给定一个数p,如何判断它是不是中位数? —-&gt;计算p在数列中的排名(假定从小到大)即可 如果p名次比中位数小,则说明 p比中位数小 如果p名次比中位数大,则说明 p比中位数大 如果p名次等于中位数,则说明 p是中位数 可以看出 满足单调性,可以对p进行二分.(二分答案!!!) 如何计算p的名次? 对于数组B={|Ai-Aj|,任意 1&lt;=i &lt; j&lt;=n} 将A数组从小到大排序,则可以去掉绝对值.即B={ Aj-Ai ,任意 1&lt;=i &lt; j&lt;=n} 那么计算Aj - Ai &lt;= p的个数即可. 移项有 Aj&lt;=p+Ai , 其中 i&lt;j 即对于每个P,枚举下标 i 然后计算满足条件的下标 j 的个数(整数二分!!!) 具体实现 首先确定答案区间(即p的范围),p就是新数组B中元素可能的取值,可以看出 0=&lt;Bi&lt;=A.max()-A.min() 然后就是对于每一个p,计算满足不等式(Aj&lt;=p+Ai )的个数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int n,a[N];//找到&lt;=k的最后一个位置int re_lower_bound(int l,int r,int k)&#123; int ans = -1; while (r &gt;= l) &#123; int mid = (l + r) &gt;&gt; 1; if (a[mid] &lt;= k) &#123; ans = mid; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; return ans;&#125;int rnk(int p)&#123;//计算满足 Aj&lt;=p+Ai , 其中 i&lt;j 的个数 //对于每个p,枚举下标i,然后二分计算满足的j的个数. j的范围[i+1,n]; int ans = 0; for (int i = 1; i &lt; n; i++) &#123; int cnt = re_lower_bound(i + 1, n, p + a[i]); if(cnt!=-1) ans += cnt - i; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; sort(a + 1, a + n + 1); int len = (1 + n * (n - 1)) / 2; //新数组的长度 int ans = -1, middle = (len + 1) / 2; //middle为中位数位置,下面实现 找到名次 &gt;=middle 的第一个p //思考为什么不是找 ==middle 的第一个p??? int p_min = 0, p_max = a[n] - a[1]; while (p_min &lt;= p_max) &#123; int p_mid = (p_min + p_max) / 2; int cnt = rnk(p_mid); if (cnt &gt;= middle) &#123; ans = p_mid; p_max = p_mid - 1; &#125; else p_min = p_mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; middle为中位数位置,下面实现 找到名次 &gt;=middle 的第一个p 关于为什么不是找 ==middle 的第一个p? ===&gt; 在计算rak的时候 用到的不等式为: Aj&lt;=p+Ai ​ 例如初始化B=1 3 3 3 5 答案p∈[1,5] p_mid=3 然后返回的cnt=4&gt;middle=3 , 如果判 ==middle,p∈[1,2] ,就会接着找p_mid=1,返回的cnt=1,然后p∈[2,2],p_mid=2,返回cnt=1,然后p∈[3,2],就退出了","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"csp","slug":"csp","permalink":"https://coincidenceboy.github.io/tags/csp/"}]},{"title":"sort,map,set","slug":"STL排序和map","date":"2020-12-09T05:52:13.000Z","updated":"2020-12-15T01:38:00.050Z","comments":true,"path":"2020/12/09/STL排序和map/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/09/STL%E6%8E%92%E5%BA%8F%E5%92%8Cmap/","excerpt":"","text":"sort基本用法—对类型为T的数组 默认从小到大排序 1sort(a,a+n); 从大到小排序 1sort(a,a+n,greater&lt;int&gt;()); 对struct类型数组进行排序123456789101112struct rank&#123; string name; int score = 0; bool operator &lt; (const rank1 &amp; s) const &#123; if (score!=s.score) return score &gt; s.score; //首先 按score从大--&gt;小 return name &lt; s.name;//其次 按name字典序从小--&gt;大 &#125;&#125;;rank r[1000];sort(r,r+count); struct配合map自定义排序顺序(给元素添加一个val值,按val进行排序)12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;map&lt;char,int&gt; hua_val;map&lt;char,int&gt; name_val;struct card&#123; char hua;//卡牌的花色 char name;//卡牌的牌面 bool operator &lt; (const card &amp; s) const &#123; if (hua!=s.hua) return hua_val[hua] &lt; hua_val[s.hua]; else return name_val[name] &lt; name_val[s.name]; &#125;&#125;;int main()&#123; hua_val[&#x27;C&#x27;] = 1; hua_val[&#x27;D&#x27;] = 2; hua_val[&#x27;S&#x27;] = 3; hua_val[&#x27;H&#x27;] = 4; //用C,D,S,H分别表示梅花，方片，黑桃，红桃，即其单词首字母 //规定花色（梅花）&lt;（方片）&lt;（黑桃）&lt;（红桃） name_val[&#x27;2&#x27;] = 1; name_val[&#x27;3&#x27;] = 2; name_val[&#x27;4&#x27;] = 3; name_val[&#x27;5&#x27;] = 4; name_val[&#x27;6&#x27;] = 5; name_val[&#x27;7&#x27;] = 6; name_val[&#x27;8&#x27;] = 7; name_val[&#x27;9&#x27;] = 8; name_val[&#x27;T&#x27;] = 9; name_val[&#x27;J&#x27;] = 10; name_val[&#x27;Q&#x27;] = 11; name_val[&#x27;K&#x27;] = 12; name_val[&#x27;A&#x27;] = 13; //规定2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; T &lt; J &lt; Q &lt; K &lt; A card puke [13]; sort(puke,puke+13);&#125; 1234567//常量map声明,而不是声明一个空的map随后再赋值const map&lt;char,int&gt; hua_val(&#123; &#123;&#x27;C&#x27;,1&#125;, &#123;&#x27;D&#x27;,2&#125;, &#123;&#x27;S&#x27;,3&#125;, &#123;&#x27;H&#x27;,4&#125;&#125;); 如果涉及到大量的insert数据,erase数据,find数据,考虑用stl中的平衡二叉树数据结构会很方便. 上述操作都能在 log(n)复杂度完成. 体现在stl中有4种容器 : multiset set multimap map 都会自动维持有序性 set和multiset1234567891011121314151617set&lt;int&gt; st;multiset&lt;int&gt; st;//缺省排序规则 表达式&quot;a&lt;b&quot;为ture,则a排在b前面//可用 st.insert() st.erase() st.find() 复杂度均log(n)//赋值st.insert(1);//查找if(st.find(1)!=s.end()) printf(&quot;the element is in set&quot;);//遍历for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++) printf(&quot;%d &quot;,*it);for(auto &amp;x : s)//c++11 新特性 printf(&quot;%d &quot;,x);//清空s.erase(val);s.clear(); map和multimap map中使用结构体需要重写比较方法 &lt; ,因为要维持其有序性.","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://coincidenceboy.github.io/tags/STL/"}]},{"title":"bfs及其应用","slug":"bfs及其应用","date":"2020-12-08T07:31:04.409Z","updated":"2020-12-14T09:49:20.182Z","comments":true,"path":"2020/12/08/bfs及其应用/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","excerpt":"","text":"BFS 篇幅问题 只给出核心代码 省略一些不必要的声明和main() BFS板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//以输出路径的5×5迷宫为例struct point&#123;//省略重载point(x,y)和== int x, y;&#125;;const int dx[4] = &#123; 0,0,-1,1 &#125;;const int dy[4] = &#123; -1,1,0,0 &#125;;int dis[5][5];//-1表可以走,-2表不能走point path[5][5];void output(point a, point b)&#123; if (b == a) &#123; printf(&quot;(%d,%d)\\n&quot;, b.x, b.y); return; &#125; output(a, path[b.x][b.y]); printf(&quot;(%d,%d)\\n&quot;, b.x, b.y);&#125;int bfs(point a,point b)&#123; queue&lt;point&gt; q; point now = a; dis[now.x][now.y] = 0; q.push(now); while (q.size()) &#123; now = q.front(); q.pop(); if (now == b) &#123; output(a, b); return dis[now.x][now.y]; &#125; for (int i = 0; i &lt; 4; i++) &#123; int new_x = now.x + dx[i],new_y = now.y + dy[i]; if (new_x&gt;=0&amp;&amp;new_x&lt;=4 &amp;&amp; new_y&gt;=0&amp;&amp;new_y&lt;=4 &amp;&amp; dis[new_x][new_y]==-1) &#123; q.push(point(new_x, new_y)); dis[new_x][new_y] = dis[now.x][now.y] + 1; path[new_x][new_y] = now; &#125; &#125; &#125; return -1;&#125; 倒水问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int A, B, C;//map中使用struct需要重载 &lt; 进行排序struct state&#123; int a, b;//省略重载state(a,b) bool operator &lt; (const state&amp; p) const &#123; if (a != p.a)return a &lt; p.a; return b &lt; p.b; &#125;&#125;;map&lt;state, state&gt; from; map&lt;state, string&gt; step;void output(state now)&#123; if (now.a == 0 &amp;&amp; now.b == 0) &#123; //printf(&quot;&lt;%d,%d&gt;\\n&quot;, now.a, now.b); return; &#125; output(from[now]); //printf(&quot;-&gt;&lt;%d,%d&gt;&quot;, now.a, now.b); cout &lt;&lt; step[now] &lt;&lt; endl;&#125;void bfs()&#123; queue&lt;state&gt; q; state now(0,0); q.push(now); while (q.size()) &#123; now = q.front(); q.pop(); if (now.a == C || now.b == C) &#123; output(now); return true; &#125; //如何记录之前状态是否已经存在了呢? 类似迷宫 已经走过 //map&lt;state, state&gt; from; if (now.a &lt; A)//①fill A &#123; state after(A, now.b); if (from.find(after) == from.end()) &#123; q.push(after); from[after] = now; step[after] = &quot;fill A&quot;; &#125; &#125; //省略②empty A if (now.a &gt; 0)//③pour A B B满orA空 &#123; state after; if (now.a + now.b &lt;= B) after.a = 0, after.b = now.a + now.b; else after.a = now.a + now.b - B, after.b = B; if (from.find(after) == from.end()) &#123; q.push(after); from[after] = now; step[after] = &quot;pour A B&quot;; &#125; &#125; //省略关于B的相同操作 &#125;&#125;int main()&#123; while (cin &gt;&gt; A &gt;&gt; B &gt;&gt; C) &#123; from.clear(); step.clear(); bfs(); cout &lt;&lt; &quot;success&quot; &lt;&lt; endl; &#125; return 0;&#125; 超级源点问题 csp 201409-4 “最佳配餐” 123456789101112131415161718192021222324252627282930313233343536//初始化queue的时候将所有分店都push进去,bfs结束条件改为cnt==n*n 即网格中除了障碍物全部都遍历到.//然后每个网格点都有了最小的dis,与记录的客户数目相乘算得结果即可.//注:①ans要用long long储存②由图可知下标从1~n queue&lt;point&gt; q;void bfs()&#123; while (q.size()) q.pop(); point now; int cnt = d; for (int i = 0; i &lt; v.size(); i++) &#123;//读入的时候 vector v 记录一下分店的数目 now = v[i]; dis[now.x][now.y] = 0; q.push(now); cnt++; &#125; while (q.size()) &#123; now = q.front(); q.pop(); if (cnt == n * n) &#123; return; &#125; for (int i = 0; i &lt; 4; i++) &#123; int new_x = now.x + dx[i],new_y = now.y + dy[i]; if (new_x&gt;=1&amp;&amp;new_x&lt;=n &amp;&amp; new_y&gt;=1&amp;&amp;new_y&lt;=n &amp;&amp; dis[new_x][new_y]==-1) &#123; q.push(point(new_x, new_y)); dis[new_x][new_y] = dis[now.x][now.y] + 1; cnt++; &#125; &#125; &#125;&#125; 有特殊点的bfs csp 201403-4 “无线网络” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int N = 205;int n, m, k;long long r;struct Node&#123; long long x, y; int dis, k; Node() &#123; x = -1, y = -1, dis = 0, k = 0; &#125; Node(long long _x, long long _y, int _s, int _k) &#123; x = _x, y = _y, dis = _s, k = _k; &#125;&#125;node[N];bool vis[N];queue&lt;Node&gt; q;int bfs(int begin, int end)&#123; while (q.size()) q.pop(); Node now = node[1]; vis[begin] = 1; q.push(now); while (q.size()) &#123; now = q.front(); q.pop(); if (now.x == node[end].x&amp;&amp;now.y == node[end].y) return now.dis - 1; //中转个数=距离-1 int len;// 下一跳可以选择node下标范围 if (now.k == k) len = n;//通过下一跳的范围限制 增设的路由器至多k个 else len = n + m; for (int i = 1; i &lt;= len; i++) &#123; if (!vis[i] &amp;&amp; ((now.x - node[i].x) * (now.x - node[i].x) + (now.y - node[i].y) * (now.y - node[i].y) &lt;= r * r)) &#123; int tmp_k; if (i &gt; n) tmp_k = now.k + 1; else tmp_k = now.k; vis[i] = 1; q.push(Node(node[i].x, node[i].y, now.dis + 1, tmp_k)); &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; r; for (int i = 1; i &lt;= n + m; i++) cin &gt;&gt; node[i].x &gt;&gt; node[i].y; cout &lt;&lt; bfs(1, 2) &lt;&lt; endl; return 0;&#125; 本题明确了有n个点,显然用一维数组struct node[N]保存更为方便. 回忆之前 dis[] []二维数据 vis是隐藏在了dis[] []的数值里面,即== -1 的时候认为!vis . 故本例中增加了vis[N]数组用来记录是否访问过. len的界限 是解决本题的关键.","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"https://coincidenceboy.github.io/tags/bfs/"}]},{"title":"sstream+getline","slug":"sstream+getline","date":"2020-11-24T02:22:04.591Z","updated":"2020-12-15T01:34:42.591Z","comments":true,"path":"2020/11/24/sstream+getline/","link":"","permalink":"https://coincidenceboy.github.io/2020/11/24/sstream+getline/","excerpt":"","text":"字符串分割神器—sstream+getline一些string常用的字符串处理12345string s;s.substr(pos,n);//截取s中从pos开始（包括0，左边是闭区间）的n个字符的子串，并返回字符串s.find(str s1); //查找s中第一次出现s1的位置,并返回(包括0)s.copy(char * s,int n,int pos)；//返回值为实际拷贝的字符数目；把当前串pos位置开始的n个字符拷贝到s为起始位置的数组中； sstream+getline1234#include&lt;sstream&gt; //头文件//stringstream的特点是，你读入了前面的一部分字符串，对应的字符串流中就会减去那一部分//(配合getline截断字符使用的话，字符流中也会减去截断字符)，//所以可以使用while来一直循环读入. eg. Sample input : 1/../d///c eg. Sample output : 123..dc 在插入vector的过程中,要判断当前小字符串(stemp)是否为空 ; 否则会出现很多空字符 , 如下: 123456..dc 关于—getline() 在c++中本质有两种 getline 函数 12345//在头文件&lt;iostream&gt;中 , 是iostream类的成员函数 .istream&amp; getline (char* s,streamsize n);//从istream中读取至多n个字符(包括结束标记符)保存在s对应的数组中.istream&amp; getline (char* s,streamsize n,char delim);//即使还没读够n个字符，如果遇到delim 或 字数达到限制，则读取终止 . delim不会被保存进s对应的数组中 12345//在头文件&lt;string&gt;中，是普通函数.istream&amp; getline(istream&amp; is,string&amp; str);//从输入流is中(如 cin),读一行到str里面.istream&amp; getline(istream&amp; is,string&amp; str,char delim);//从输入流is中,按照截断字符delim读到str中 关于—流和EOF(win下是ctrl+Z) 就while(getline(cin,line))分析一下 这个while语句真实的判断对象是 cin 的状态,也就是当前是否存在有效的输入流.而输入流是对象,返回的是输入流的状态.正常情况下,你是怎么输入都跳不出循环的. (如果认为输入 回车 就可以跳出,则是将 while的判断对象看成了 line(即判断line是否为空) 实际上,回车和设置的delim都是仅终止getline()的读取操作). EOF是C语言中为了区分有效数据和输入结束符的。windows下是ctrl+z,linux/unix下是ctrl+d。","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"字符串处理","slug":"字符串处理","permalink":"https://coincidenceboy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"}]}],"categories":[{"name":"C++图论","slug":"C-图论","permalink":"https://coincidenceboy.github.io/categories/C-%E5%9B%BE%E8%AE%BA/"},{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"},{"name":"win10","slug":"win10","permalink":"https://coincidenceboy.github.io/categories/win10/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://coincidenceboy.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://coincidenceboy.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"并查集","slug":"并查集","permalink":"https://coincidenceboy.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"图的存储和遍历","slug":"图的存储和遍历","permalink":"https://coincidenceboy.github.io/tags/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"},{"name":"前缀和&差分","slug":"前缀和-差分","permalink":"https://coincidenceboy.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/"},{"name":"线性数据结构","slug":"线性数据结构","permalink":"https://coincidenceboy.github.io/tags/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c++万能头","slug":"c-万能头","permalink":"https://coincidenceboy.github.io/tags/c-%E4%B8%87%E8%83%BD%E5%A4%B4/"},{"name":"蓝牙","slug":"蓝牙","permalink":"https://coincidenceboy.github.io/tags/%E8%93%9D%E7%89%99/"},{"name":"csp","slug":"csp","permalink":"https://coincidenceboy.github.io/tags/csp/"},{"name":"STL","slug":"STL","permalink":"https://coincidenceboy.github.io/tags/STL/"},{"name":"bfs","slug":"bfs","permalink":"https://coincidenceboy.github.io/tags/bfs/"},{"name":"字符串处理","slug":"字符串处理","permalink":"https://coincidenceboy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"}]}