{"meta":{"title":"CoincidenceBoy","subtitle":"blog","description":"","author":"CoincidenceBoy","url":"https://coincidenceboy.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"about/index.html","permalink":"https://coincidenceboy.github.io/about/index.html","excerpt":"","text":"神奇の沟通 沟通是 传递 沟通是 交流 沟通是 分享 沟通是 智慧 沟通是 友谊 沟通是 力量 “ 认识自我、超越自我 “ 是沟通的最高境界 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我CSDN：https://chocolate.blog.csdn.net/（CSDN认证博客专家） 微信公众号：小狮子前端Vue 一个不是只会写业务代码的前端攻城狮会带给你怎样的体会呢？ 座右铭：学如逆水行舟，不进则退"},{"title":"番剧列表","date":"2020-04-20T01:39:20.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"bangumis/index.html","permalink":"https://coincidenceboy.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-19T04:59:34.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"categories/index.html","permalink":"https://coincidenceboy.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-04-19T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"books/index.html","permalink":"https://coincidenceboy.github.io/books/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-04-22T23:39:34.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"contact/index.html","permalink":"https://coincidenceboy.github.io/contact/index.html","excerpt":"","text":""},{"title":"相册集","date":"2020-04-21T10:44:23.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"gallery/index.html","permalink":"https://coincidenceboy.github.io/gallery/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-19T05:00:10.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"link/index.html","permalink":"https://coincidenceboy.github.io/link/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-23T13:22:33.961Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"home/index.html","permalink":"https://coincidenceboy.github.io/home/index.html","excerpt":"","text":"Chocolate Home lionLoveVue 小狮子前端 Chocolate I Can Do It Hello world! -「ROBOT」 首页 博客 导航 Github CSDN Email Powered By JsonBird And Hitokoto Modify by Chocolate .github-corner:hover .octo-arm { animation: octocat-wave 560ms ease-in-out } @keyframes octocat-wave { 0%, 100% { transform: rotate(0) } 20%, 60% { transform: rotate(-25deg) } 40%, 80% { transform: rotate(10deg) } } @media (max-width:500px) { .github-corner:hover .octo-arm { animation: none } .github-corner .octo-arm { animation: octocat-wave 560ms ease-in-out } }"},{"title":"电影","date":"2020-04-19T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"movies/index.html","permalink":"https://coincidenceboy.github.io/movies/index.html","excerpt":"","text":""},{"title":"Music","date":"2020-04-23T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"music/index.html","permalink":"https://coincidenceboy.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-19T04:58:56.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"tags/index.html","permalink":"https://coincidenceboy.github.io/tags/index.html","excerpt":"","text":""},{"title":"说说","date":"2020-04-22T23:47:23.000Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"talk/index.html","permalink":"https://coincidenceboy.github.io/talk/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-23T13:22:33.949Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"box/about/index.html","permalink":"https://coincidenceboy.github.io/box/about/index.html","excerpt":"","text":"聚宝盒丨小狮子前端 关于本页 本页面收集了比较常用或者实用的网站，相当于一个小小的导航页面。 整个页面由 Viggo 开发，完全开源，如果你也喜欢，欢迎去其 Github 点亮 star。 关于 Viggo Designer. Viggo. Full-time UI designer with an enduring interest in Coding. 一个全职的用户界面设计师，优秀的前端开发工程师，擅长 WEB 开发、WEB 设计、UI/UX 设计，对编程，拍照和单车有着持久的兴趣，生活在广州；如果您想招收此方面的人才，Viggo 无疑是一个很好的选择。 关于 超逸の博客 一百个Chocolate 在校本科计算机科学与技术大三学生，主攻前端，Vue框架。 不是只会写业务代码的前端开发攻城狮！学如逆水行舟，不进则退。 COPYRIGHT 2019 - 2020 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY Chocolate"},{"title":"","date":"2020-11-23T13:22:33.951Z","updated":"2020-07-13T03:42:12.000Z","comments":true,"path":"box/index.html","permalink":"https://coincidenceboy.github.io/box/index.html","excerpt":"","text":"聚宝盒丨小狮子前端 footer.main-footer .go-up { width: 45px; float: right; position: fixed; right: -10px; bottom: 30px; z-index: 10; margin: 0; padding: 0; list-style: none } footer.main-footer .go-up a { display: inline-block; width: 35px; height: 35px; text-align: center; border-radius: 50%; background: rgba(123, 123, 123, .5); color: #fff; font-size: 20px; line-height: 35px; padding: 0 } 开发社区 代码托管 语言文档 技能训练 在线平台 高校平台 游戏编程 HOT Pythoner 文档资料 博客收藏 学习资源 组织社区 爬虫相关 HOT 学习教程 在线视频 博客论坛 学习平台 常用工具 站长工具 HOT IT工具箱 文件处理 HOT 设计素材 效率软件 HOT 服务平台 云服务商 众包平台 更多导航 关于本页 隐藏/显示侧边栏 博客首页 友情链接 评论留言 关于博主 ! function (e, t, n, a, o, i, c, r) { r = function () { i = t.createElement(n), c = t.getElementsByTagName(n)[0], i.src = o, i.charset = \"utf-8\", i.async = 1, c.parentNode.insertBefore(i, c) }, e.SeniverseWeatherWidgetObject = a, e[a] || (e[a] = function () { (e[a].q = e[a].q || []).push(arguments) }), e[a].l = +new Date, e.attachEvent ? e.attachEvent(\"onload\", r) : e .addEventListener(\"load\", r, !1) }(window, document, \"script\", \"SeniverseWeatherWidget\", \"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\" + parseInt(((new Date).getTime() / 1e8).toString(), 10)), window.SeniverseWeatherWidget(\"show\", { flavor: \"slim\", location: \"WX4FBXXFKE4F\", geolocation: !0, language: \"auto\", unit: \"c\", theme: \"auto\", token: \"a39cd5a0-4024-4cb2-85c6-0250317058db\", hover: \"enabled\", container: \"tp-weather-widget\" }) 导航内容不定期更新... 开发社区 Stack Overflow 全球最受程序员欢迎的开发社区 CSDN 全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台 博客园 代码改变世界 V2EX V2EX = way to explore 掘金 一个帮助开发者成长的社区 SegmentFault 改变并提升人们获取知识的方式和效率，帮助更多的开发者获得成长与成功 开源中国 国内最大的开源技术社区 ITeye ITeye软件开发交流社区 - Java编程 Spring框架 Ajax技术 agile敏捷软件开发 ruby on rails实践 51CTO 技术成就梦想 ITPUB 全球最大的学习分享平台 知乎 国内最受欢迎的知识性问答社区 简书 创作你的创作 云+社区 来自腾讯的开发者技术分享社区 云栖社区 阿里云面向开发者的开放型技术平台 极术社区 全球软硬件资源信息，只要你有问题，我们就能解答。 代码托管 Github 全球最大的面向开源及私有软件项目的托管平台 Gitlab 支持无限的公有项目和私有项目的代码托管平台 Bitbucket 同时支持 Git 和 Mercurial 这两个版本控制软件，免费的私有仓库，支持5人以内的合作开发 SourceForge 又称 SF.net，是开源软件开发者进行开发管理的集中式场所 Coding 国内首个一站式云端软件服务平台 Gitee 国内最大的开源社区 OSChina 的代码托管平台 阿里云代码托管 阿里云旗下代码托管平台 百度效率云 百度云旗下的 Git 代码托管平台 语言文档 Zeal 脱机文档浏览器，包含196种语言API文档，支持Windows、Linux和macOS Dash 适用于Mac OS平台的软件编程文档管理工具,可以浏览API文档,以及管理代码片段工具。自带了丰富的API文档,涉及各种主流的编程语言和框架 DevDocs 在快速，有条理和可搜索的界面中结合了多个API文档，可以在移动设备上离线运行，并且可以安装在Chrome上 C/C++ C/C++ API 文档 C# C# API 文档 Java Java API 文档 .NET .NET API 文档 PHP PHP API 文档 JavaScript JavaScript API 文档 Python Python API 文档 Android Android API 文档 iOS iOS API 文档 SQL SQL API 文档 Swift Swift API 文档 Ruby Ruby API 文档 GO GO API 文档 R R API 文档 MATLAB MATLAB API 文档 Node.js Node.js API 文档 HTML HTML API 文档 CSS CSS API 文档 Redis Redis API 文档 MongoDB MongoDB API 文档 Django Django API 文档 在线平台 LeetCode 全球极客挚爱的技术成长平台 Topcoder 全世界规模最大的程序竞赛网站，也会有一些算法竞赛，适合一些高端的或者搞ACM的，也会举办一些比赛 Codeforces 俄罗斯最大的算法比赛网站 Hihocoder 技术团队来自原北京大学POJ (PKU Online Judge)开发团队，收集了全球范围内很多地区、高校举办的比赛试题， 提供365天*24小时的在线提交、评判程序的服务 LintCode 被称作中文版的leetcode，也是可以做为编程能力提升的一个中转站 SPOJ 波兰的算法刷题网站 NEUQ OJ 一个在线的判题平台 洛谷 创办于2013年，致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验 牛客网 中国最大的IT题库 C语言网 在这里可以参加包括ACM、NOI在内的各种C/C++/java程序比赛，也可以DIY举办各类程序比赛活动！ 计蒜客 计蒜客OI题库致力于为参加noi、noip、信息学竞赛的选手提供优秀的Online Judge系统 高校平台 POJ 北京大学程序在线评测系统 FDU OJ 复旦大学程序在线评测系统 TJ OJ 同济大学程序在线评测系统 USTC OJ 中国科学技术大学程序在线评测系统 ZOJ 浙江大学程序在线评测系统 HDU OJ 杭州电子科技大学程序在线评测系统 CSU-ACM 中南大学程序在线评测系统 HOJX 哈尔滨工业大学程序在线评测系统 HRBUST OJ 哈尔滨理工大学程序在线评测系统 PowerOJ 西南科技大学程序在线评测系统 SCU OJ 四川大学程序在线评测系统 FZU CoidngOJ 福州大学程序在线评测系统 NBUT OJ 宁波工程学院程序在线评测系统 Lutece 电子科技大学程序在线评测系统 武汉大学 ACM 协会 武汉大学 ACM 协会 ZJUT OJ 浙江工业大学程序在线评测系统 游戏编程 CheckiO 面向初学者和高级程序员的编码游戏，使用Python和JavaScript解决棘手的挑战和有趣的任务，从而提高您的编码技能 Coding Games 支持包括PHP、C、JavaScript在内的20多种编程语言。用户界面功能强大，可以定制 Codewars 一个外国的在线练习编程的网站,做题的过程类似打怪,做题升级,而且可以看到别人的解法,里面有很多巧妙的写法可以学习 CodeCombat 一个面向学生的游戏和CS学习平台。这是一个社区项目，有数百玩家自愿提供支持。支持语言包括Java、JS、Python、Lua、CoffeeScript Screeps 在游戏中学习JavaScript。世界上第一款针对程序员的MMO沙盒游戏 VIM Adventures 玩游戏的时候学VIM Cyber-Dojo 一个提供给程序员们练习写程序的地方。支持语言包括JavaScript、Java、Python、PHP、Ruby和很多其他语言 Elevator Saga 电梯编程游戏，跟随关卡解决所有挑站，使用语言为JavaScript Ruby Quiz 一个Ruby程序员提供的每周编程挑战项目 hacker.org 这项挑战由一系列本设计来强化你黑客技巧的解密、诡计、测试、烧脑环节组成。想要通关本系列，你必须学会解密、编码、渗透 Ruby Warrior 玩游戏学Ruby，通过Ruby脚本来控制一个Warrior通过每一关，每一关的代码难度都会有所增加，使玩家逐渐了解Ruby基本的函数、控制、变量、数组等语言特性的用法 文档资料 Python 官方文档 Python 官方文档 Python 标准库 Python 标准库 Python Requests Python Requests 文档 Python Urllib Python Urllib 文档 Python Selenium Python Selenium 中文翻译文档 正则表达式 Python 正则表达式官方文档 Beautiful Soup Beautiful Soup 文档 Scrapy Scrapy 爬虫框架官方文档 PySpider PySpider 爬虫框架官方文档 Matplotlib Matplotlib 2D绘图库 官方中文文档 Numpy Numpy 科学计算 官方中文文档 Pandas Pandas 结构化数据分析 官方中文文档 博客收藏 廖雪峰 廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程 崔庆才 崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析 莫烦Python 专注Python、机器学习、深度学习 唐松 专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析 捕蛇者说 编程、程序员、Python FxxkPython 学习python的正确姿势 wistbean Python 大佬 Piglei Python 大佬 TendCode Python 大佬 追梦人物的博客 Python Django 大佬 the5fire 《Django企业开发实战》作者，关注Python、Django、Vim、Linux、Web开发 小明明S À DOMICILE 《Python Web开发实战》作者，Python 大佬 Python之禅 Python 大佬 Python 知识圈 Python知识圈 - 实用的Python教程网站 Python 教程网 小詹学Python，专注Python学习 烂笔头 j_hao104 Python大佬 咸鱼日常 专注Python爬虫，有许多JS逆向文章 AnSheng Python 全栈大佬 夏溪辰 云栖社区特邀爬虫工程师，Python大佬 高级农民工 Python大佬 云爬虫技术研究笔记 Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家 云爬虫技术研究笔记(CSDN) Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家 Jack Cui CSDN博客专家，Python 大佬 学习资源 Python爬虫人工智能学习教程 Python爬虫人工智能学习教程分享 Python 中文学习大本营 Python 中文学习大本营 Python 资源大全中文版 Python 资源大全中文版 组织社区 PyChina Python 中国社区 PyCon China 中国 Python 开发者大会 蠎周刊 蠎周刊 - 汇集全球蠎事儿 爬虫相关 镀金的天空 GlidedSky 镀金的天空，在线爬虫练习题库 夜幕爬虫安全论坛 一个专注于爬虫与 PC/Web/ 移动端安全领域技术交流的社区，社区由夜幕团队 NightTeam 创办，旨在提升开发者对爬虫与软件安全防护的理解 西刺免费代理IP 每日更新免费HTTP代理，所有代理均为6675端口高匿代理，可隐藏IP 爬虫IP代理池 爬虫IP代理池 云打码 采用全球领先的秒传识别系统，50%图片零秒识别，人工平均处理时间0-3秒 超级鹰 专业的验证码云端识别服务,让验证码识别更快速、更准确、更强大 八爪鱼采集器 一款使用简单、功能强大的网络爬虫工具，完全可视化操作，无需编写代码，内置海量模板，支持任意网络数据抓取 Python 逆向 Python 逆向相关资源 Python 爬虫集合 Python 爬虫集合 Python 入门网络爬虫之精华版 Python 入门网络爬虫之精华版 爬虫项目进阶实战 Python3 爬虫项目进阶实战、JS加解密、逆向教程、css 加密、字体加密 Python 模拟登陆一些大型网站 Python 模拟登陆一些大型网站 系统化学习 Python 爬虫 系统化学习 Python 爬虫 Python3 网络爬虫实战 Python3 网络爬虫实战 在线视频 腾讯课堂 腾讯推出的专业在线教育平台，聚合大量优质教育机构和名师 网易云课堂 网易旗下一个专注职业技能提升的在线学习平台。立足于实用性的要求，与多家教育培训机构和行业的专家、讲师建立合作 中国大学 MOOC 中国大学MOOC(慕课)，国家精品课程在线学习平台 黑马程序员 致力于培养中级程序员，是业内以口碑闻名的IT教育培训机构 课工场 更可靠的IT就业教育平台，针对大学生量身定制人工智能、大数据、云计算、区块链、Java大数据开发等大学生IT培训课程 极客学院 极客学院作为中国专业IT职业在线教育平台,拥有海量高清IT职业课程,涵盖30+个技术领域 慕课网 慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课 尚硅谷 尚硅谷Java培训，谷粉与老学员为你推荐的Java培训、Web前端培训、前端培训、大数据培训、Python培训；0基础入学，学员就业起薪屡创新高！ 实验楼 国内领先的IT在线编程及在线实训学习平台，专业导师提供精选的实践项目，创新的技术使得学习者无需配置繁琐的本地环境，随时在线流畅使用 优达学城 Udacity是来自硅谷的前沿技术平台，为广大学子提供WEB前端开发、Python/JAVA编程、IOS/Android开发、人工智能开发等一系列在线课程及实战项目，满足学员灵活的学习需求 51CTO学院 51CTO学院IT职业在线教育平台是依托12年行业品牌、1400万IT技术用户建立的专业IT技能学习培训平台，已签约1000多位技术专家发布了12万个自学式实战视频教程 CSDN 学院 CSDN 学院作为IT在线教育平台,涵盖人工智能、考试认证、移动开发、大数据技术领域职业课程 老男孩IT教育 隶属北京一天天教育科技有限公司,是一直专注于Linux培训、Linux系统及架构师培训、Python培训、网络安全培训，大数据实战的高端培训机构 千锋教育 千锋教育 - 坚持教育初心，坚持面授品质，IT培训良心品牌 博客论坛 鱼C工作室 鱼C工作室-免费编程视频教学|Python教学|Web开发教学|全栈开发教学|C语言教学|汇编教学|Win32开发|加密与解密|Linux教学 吾爱破解 致力于软件安全与病毒分析的前沿，丰富的技术版块交相辉映，由无数热衷于软件加密解密及反病毒爱好者共同维护 廖雪峰 廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程 崔庆才 崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析 莫烦Python 专注Python、机器学习、深度学习 唐松 专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析 阮一峰 上海财经大学世界经济博士研究生，计算机科普博主，对自由软件有着坚定不移的信念 学习平台 菜鸟教程 提供了编程的基础技术教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识 W3school 领先的 Web 技术教程 C语言网 C语言网 - 领先实用的编程在线学习网站 前端网 前端网，最好的自学web前端网站 牛客网 牛客网 - 互联网求职神器和备考学习平台 How2J How2J的Java教程, 内容涵盖J2SE、WEB前端、J2EE、框架技术等全面的Java内容 站长工具 新浪短网址 多种后缀短网址生成 百度短网址 百度旗下专业的网址缩短服务 站长工具 - 站长之家 站长工具,SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询 阿里云 whois 查询 whois查询,域名whois,域名注册信息,whois查询工具,whois信息,域名信息 NnameBeta 国际域名搜索、域名注册、国别域名注册、域名比价 Domcomp 域名比价，Domain Name Price and Availability. 仿站工具箱 在线仿站工具箱 超级 SEO 外链工具 网站自动化宣传机器/免费的超级外链工具可批量增加外链 百度站长平台 百度搜索资源平台 - 让网站更具价值 搜狗站长平台 搜狗站长平台 - 全面掌握在搜狗搜索中的数据表现 360 站长平台 360 站长平台 - 给网站带来更多流量和展现 Google 站长平台 Google 网站站长 - 支持、学习、互动交流和 Search Console – Google Bing 网站管理员工具 Bing 网站管理员工具 百度广告联盟 百度广告联盟为您的流量增值 Google AdSense Google 广告平台 百度统计 百度统计 — 最大的中文网站分析平台 友盟+ 国内领先的第三方全域数据智能服务商 ICP/IP地址/域名信息备案管理系统 工业和信息化部ICP/IP地址/域名信息备案管理系统 全国互联网安全管理服务平台 公安备案网 - 全国互联网安全管理服务平台 IT工具箱 在线工具 - 程序员的工具箱 站长工具、代码格式化、压缩、加密、解密、下载链接转换等 在线工具 - OSCHINA.NET社区 常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等 记磊工具箱 Dns检测、CSS格式化、超级Ping、端口扫描等 孟坤工具箱 css一键美化、文本差异比较、代码高亮等 Syntax Highlight Syntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码 Text to ASCII Art Generator Text to ASCII Art Generator，字符串转成 ASCII 码图案 MDEditor 开源在线 Markdown 编辑器 临时邮箱 匿名注册不常用的网站/论坛，保护隐私免骚扰 SM.MS SM 免费图床，每个文件最大支持 5MB 路过图床 免费公共图床，支持最大10MB、批量上传 Greasy Fork 安全、实用的用户脚本大全 Hello World 大全 收集了大约481种 Hello World 程序，涵盖了目前已知的所有编程语言，另加上 67 人类语言 动画展示各种路径搜索算法 动画展示各种路径搜索算法 IT eBooks 可以下载IT电子书籍的网站（英文） GEEKTyper 在线模拟黑客工作的虚拟桌面系统，提供多种黑客工作的场景 免费计算机编程类中文书籍 免费计算机编程类中文书籍 EaseUS Partition Master 磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间 文件处理 Convertio 在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式 Office-Converter 免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式 TinyPNG PNG/JPG图片在线压缩利器 Squoosh Google开源在线压缩、调整工具，支持WebP ILoveIMG 永远免费的在线图片处理工具，可在线编辑，压缩、裁剪、转换、水印等 Smallpdf Smallpdf - A Free Solution to all your PDF Problems,PDF压缩、转换、分割、合并等 PHOTOMOSH 故障艺术在线生成，可以输出jpg、gif和视频 稿定抠图 免费在线抠图软件,图片快速换背景-抠白底图 U钙网 完全免费的LOGO在线设计制作工具 SVGOMG SVG在线压缩平台 在线图片透明圆角处理 在线图片透明圆角处理 草料二维码 国内创建二维码在线应用 Logaster 在线免费创建简单logo及名片设计 Preloaders Loading 懒加载动画在线制作 Loading 制作GIF、SVG、CSS加载动画图标 waifu2x 图片智能无损放大2倍，适合动漫、插画等 智图 腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台 音乐免费下载 全网音乐免费下载工具 OK资源采集 OK资源采集-最新影视资源大全 网易见外工作台 针对视频、图片、文档、音频都可以进行翻译转写操作，每天两小时免费使用 HiPDF 一站式解决所有PDF相关的问题 视频鱼 在线下载各大网站视频的网站 ScreenToGif 开源、轻量级却非常强大的录屏软件，快速将屏幕录制成高清GIF 设计素材 Iconfont 阿里巴巴矢量图标库，提供矢量图标下载、在线存储、格式转换等功能 Font Awesome 一个基于CSS 和 LESS 的字体和图标工具包 Flaticon 海量扁平化免费的图标库 icons8 独特系统平台风格和web图标库，下载免费图标，音乐 千图网 海量原创设计模板免费下载 昵图网 国内海量平面免费素材下载 千库网 免费 png 图片背景素材下载 Pexels 才华横溢的摄影作者在这里免费分享最精彩的素材照片和视频 必应壁纸 必应每日高清壁纸 Piqsels 精美的免版税图库 私藏字体 优质字体免费下载站 第一 PPT 网 免费 PPT 模板下载 吾道幻灯片 全新的office生产力工具，支持演示文稿、PPT模板、协同办公，可以帮助用户轻松创建具有视觉吸引力的幻灯片 Mixkit 免费、高质量、可商用的视频素材分享网站 The Stocks 对各大图片网站进行整合，免费优质图片下载 极简壁纸 高质量精品壁纸网站 NASA Image and Video Library 美国国家航天局的官方库，从此太空类的素材再也不是问题 Unsplash 质量超高的免费图片素材库，无需注册，直接下载 WordArt 文字云工具 效率软件 分流抢票 全程自动抢票,自动抢候补,自动识别验证码,多线程秒单、稳定捡漏,支持多天、多车次、多席别、多乘客等功能 PanDownload 百度网盘下载神器 Quicker 为常用操作建立捷径，PC 快捷动作面板，让效率触手可及! 万彩办公大师 免费、轻松处理文档/音视频/图片的工具 LICEcap 简洁易用的动画屏幕录制软件，它可将屏幕录像的内容直接保存为高质量（每帧颜色数量可超过256）GIF动态图片格式 Snipaste 简单但强大的截图工具，支持截图 + 贴图 FSCapture 一个强大的，轻量级的，功能齐全的屏幕捕获工具 Everything 速度最快的的文件搜索工具 DeskPins 顶置任意窗口 TrafficMonitor 一个用于显示当前网速、CPU及内存利用率的桌面悬浮窗软件 PicGo 由 electronic-vue 构建的简单而精美的图片上传工具 PowerToys 微软为 Windows 系统推出的一系列免费实用小工具合集 Dism++ 一款根据微软底层的架构结构设计的一个系统维护工具，全球第一款基于 CBS 的 Dism GUI 实现 ColorPix 屏幕取色小工具 CCleaner 一款免费的系统优化和隐私保护工具 GifCam 集录制与剪辑为一体的屏幕 GIF 动画制作工具，录制后的动画可以逐帧编辑 EV录屏 一款免费并且不添加水印的录屏工具 Fliqlo 一款极简主义的时钟屏保软件 Fences 栅栏管理桌面，使桌面更加整洁有条理 Q-dir 多窗口文件整理工具 WGestures 鼠标手势工具 XMind 一个全功能的思维导图和头脑风暴软件 速盘 免登录，自动查询提取码，极速的度盘下载工具 f.lux 国外开源的护眼软件，通过根据时间调节屏幕颜色，减少蓝光对视力的影响 云服务商 阿里云 阿里云 - 为了无法计算的价值 腾讯云 腾讯云 - 产业智变 云启未来 百度云 百度云 - 计算无限可能 华为云 华为云 - +智能，见未来 京东云 京东云 - 遇见无限可能 西部数码 西部数码 - 云服务器、虚拟主机、域名注册17年知名云计算服务提供商！ 景安云 景安云 - 专业的数据中心服务商 七牛云 七牛云 - 国内领先的企业级云服务商 又拍云 又拍云 - 加速在线业务-CDN-云存储 美橙互联 美橙互联 - 域名注册、企业建站、云服务器、企业网络推广整体解决方案服务商！ UCloud UCloud - 中立 安全 可信赖的云计算服务商 AWS AWS 云服务 - 专业的大数据和云计算服务以及云解决方案提供商 Microsoft Azure Azure. Invent with purpose. GoDaddy GoDaddy - 提供域名注册和互联网主机服务的美国公司 Cloudflare Cloudflare - 网络性能和安全公司 jsDelivr jsDelivr - A free, fast, and reliable Open Source CDN for npm and GitHub 众包平台 猿急送 专注于 IT 众包领域，职位内容大多集中于 UI 设计、产品设计、程序开发、产品运营等需求 开源众包 开源中国旗下外包网站，项目大多是团队的整包项目，适合多人组团接单 外包大师 PMCAFF旗下的一个众包开发平台，目前以技术开发为主，以众包开发和自有开发相结合形式运营 人人开发 集可视化开发，应用市场，威客众包，PaaS云于一体的企业级应用服务平台 快码 提供智能硬件、各种智能共享项目解决方案，为互联网创业者提供APP、小程序、公众号开发。 我爱方案网 专注于硬件类外包，电子方案开发供应链众包平台，软件外包，方案，硬件开发方案，硬件设计开发 英选 提供可信赖的定制开发外包服务，包括企业品牌官网、电商系统及创新定制产品开发 智筹 为企业&创业者提供互联网高级人才直租服务。按次直租，解决临时、突发问题；按月直租，建立长期兼职合作；按任务直租，解决有明确预算的外包任务 开发邦 互联网软件定制开发与软件外包开发服务，十年互联网软件定制开发经验 码市 Coding 推出的互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作 自由职客 自由职客是权威的IT互联网行业灵活用工交易平台，外包，众包，兼职，招聘，erp，sap 解放号 解放号众包平台提供软件开发外包、人力驻场服务等软件项目外包服务。解放号的软件项目交付全流程可视化监控与全生命周期管理能力 程序员客栈 领先的程序员自由工作平台，38万+优秀开发者，您的专属云端开发团队，BAT级别的开发者，标准化的服务和交付 码易 智网易联旗下IT软件服务平台，集软件商城、企业应用、电商软件、crm软件、商务服务平台于一体的一站式软件外包开发服务平台 电鸭社区 电鸭社区旨在推动自由工作方式在国内渐进式发展，区别于传统方式的工作职位，倡导「只工作，不上班」的工作心态 Sxsoft 中国最早的外包服务平台，18年口碑服务，20万程序员、100+专业软件开发公司，专注解决各类软件开发需求 实现网 为企业提供BAT等名企背景的、靠谱的开发设计兼职人才和自由职业者，满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求 智城外包网 零佣金开发资源平台，认证担保，全程无忧，专业的软件外包网和项目外包、项目开发、人力外派、短期招聘、人力资源交易平台 更多导航 创造狮导航 创造狮，一个创意工作者的导航，专注分享正版优质设计、前端、产品、运营的书签导航，设计教程、设计规范、颜色搭配、灵感创意、前端框架、开发者工具、互联网新品推荐、运营数据分析、自媒体和工具利器好用的分类导航大全 大数据导航 大数据导航，以大数据产业为主，大数据工具为辅，给用户提供一个更加快速找到大数据相关的工具平台 优设导航 优设网站导航为设计师提供ps教程、UI设计、素材下载、高清图库、配色方案、用户体验、网页设计等全方位设计师网站导航指引 牛导航 实用工具导航 聚BT 聚BT - 聚合最优质的BT、磁力资源 ShareHub ShareHub - 资源和工具的集合 狼牌工作网址导航 工具，资源，方法，All IN ONE的办公工作网址导航 COPYRIGHT 2019 - 2020 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY Chocolate $(document).ready(function () { return $(document).on(\"click\", \".has-sub\", function () { var e = $(this); $(this).hasClass(\"expanded\") ? $(\".has-sub ul\").each(function (s, i) { var t = $(this); e.find(\"ul\")[0] != i && setTimeout(function () { t.attr(\"style\", \"\") }, 300) }) : setTimeout(function () { e.find(\"ul\").attr(\"style\", \"\") }, 300) }), $(\".user-info-menu .hidden-sm\").click(function () { $(\".sidebar-menu\").hasClass(\"collapsed\") ? $(\".has-sub.expanded > ul\").attr(\"style\", \"\") : $(\".has-sub.expanded > ul\").show() }), $(\"#main-menu li ul li\").click(function () { $(this).siblings(\"li\").removeClass(\"active\"), $(this).addClass(\"active\") }), $(\"a.smooth\").click(function (s) { s.preventDefault(), public_vars.$mainMenu.add(public_vars.$sidebarProfile).toggleClass( \"mobile-is-visible\"), ps_destroy(), $(\"html, body\").animate({ scrollTop: $($(this).attr(\"href\")).offset().top - 30 }, { duration: 500, easing: \"swing\" }) }), !1 }); var href = \"\", pos = 0; $(\"a.smooth\").click(function (s) { $(\"#main-menu li\").each(function () { $(this).removeClass(\"active\") }), $(this).parent(\"li\").addClass(\"active\"), s.preventDefault(), href = $(this).attr(\"href\"), pos = $(href).position().top - 30 })"}],"posts":[{"title":"LeetCode-1-线性表","slug":"LeetCode-1-线性表","date":"2021-04-06T13:09:41.000Z","updated":"2021-04-06T16:25:37.727Z","comments":true,"path":"2021/04/06/LeetCode-1-线性表/","link":"","permalink":"https://coincidenceboy.github.io/2021/04/06/LeetCode-1-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"数组Remove Duplicates from Sorted Array Code reference12345678910111213141516171819202122//code-1 与1.2对应class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;=1)return nums.size(); //i为fast指针 , index为slow指针 int index = 1; for(int i=1;i&lt;nums.size();i++)&#123; if(nums[i]!=nums[index-1])&#123; nums[index++]=nums[i]; &#125; &#125; return index; &#125;&#125;;//code-2class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; return distance(nums.begin(),unique(nums.begin(),nums.end())); &#125;&#125;; distance(iterator begin,iterator end) return两个迭代器[begin,end)内元素的个数. unique(iterator begin,iterator end) 对[begin,end)进行去重,return一个iterator-&gt;去重后不重复序列的最后一个元素的下一个元素位置。 unique(iterator begin,iterator end,bool cmp) cmp -&gt; 自定义元素是否相等 123bool cmp(int a,int b)&#123; return a &gt; b;&#125; 注 : unique去重的本质同上述实现(不断的把后面不重复的元素移到前面来) , 即容器原长度不变, 可以与erase函数一起使用来实现真正意义的”删除” 12erase(unique(nums.begin(),nums.end(),num.end());//unique()返回的是 不重复序列的最后一个元素的下一个元素 erase[ ) 刚好可以删除多余的区间. Remove Duplicates from Sorted Array - II code reference1234567891011121314151617//可以类比成 保留 k 位//①由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留//②从第k+1位开始之后的每一位,能够保留的条件是 : 与当前写入的位置(slow)前面的第k位 compare , 不相同可以保留class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;=2)return nums.size(); //i为fast指针 , index为slow指针 int index = 2; for(int i=2;i&lt;nums.size();i++)&#123; if(nums[i]!=nums[index-2])&#123; nums[index++] = nums[i]; &#125; &#125; return index; &#125;&#125;; Search in Rotated Sorted Array 相关 — 二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//binarySearch --- 查找==target的索引,找不到`return` -1public static int binarySearch(int[] nums,int target,int left,int right)&#123; //left=0,right=n-1 while(left&lt;=right)&#123; int mid = left + ((right-left)&gt;&gt;1); // (left+right)/2 可能会溢出 if(nums[mid]==target)&#123; return mid; &#125;else if(nums[mid]&lt;target)&#123; left=mid+1; &#125;else&#123; right=mid-1; &#125; &#125; return -1;//若return left; 表示如果将target按顺序插入时的索引.&#125;//lowerBound --- 查找 &gt;= target的下界,找不到返回-1public static int lowerBound(int[] nums,int target,int left,int right)&#123; int ans=-1; while(left&lt;=right)&#123; int mid = left + ((right-left)&gt;&gt;1); //if(nums[mid]==target)&#123;...&#125;当==时,不能确定mid是否为左边界,所以我们还需要在mid值的左侧继续找寻target. 即 right=mid-1; 此时可以与if(num[mid]&gt;target)合并 if(nums[mid]&gt;=target)&#123; right=mid-1; ans=mid; &#125;else&#123; left=mid+1; &#125; &#125; return ans;&#125;//upperBound --- 查找 &lt;= target的上界,找不到返回-1public static int upperBound(int[] nums,int target,int left,int right)&#123; int ans=-1; while(left&lt;=right)&#123; int mid=left+((right-left)&gt;&gt;1); if(nums[mid]&lt;=target)&#123; left=mid+1; ans=mid; &#125;else&#123; right=mid-1; &#125; &#125; return ans;&#125;//find_first --- 查找 == target的下界,找不到返回-1public static int find_first(int[] nums,int target,int left,int right)&#123; int ans=-1; while(left&lt;=right)&#123; int mid=left+((right-left)&gt;&gt;1); if(nums[mid]==target)&#123; right=mid-1; ans=mid; &#125;else if(nums[mid]&gt;target)&#123; right=mid-1; &#125;else&#123; left=mid+1; &#125; &#125; return ans;&#125;//find_last --- 查找 == target的上界,找不到返回-1public static int find_last(int[] nums,int target,int left,int right)&#123; int ans=-1; while(left&lt;=right)&#123; int mid=left+((right-left)&gt;&gt;1); if(nums[mid]==target)&#123; left=mid+1; ans=mid; &#125;else if(nums[mid]&lt;target)&#123; left=mid+1; &#125;else&#123; right=mid-1; &#125; &#125; return ans;&#125; 先二分 — ①求旋转数组中target的索引,不存在返回-1. 数组从中间分成数组1 , 2的时候,一定有一个数组是有序的. 我们可以通过mid来判断[l,mid]和[mid,r]哪部分是有序的 , 进而再根据有序的那一部分 判断 target在不在这个部分. mid的位置只有两种 ①和left在同一个数组内 (同时在数组1 或者 2) 此时 nums[mid]&gt;=nums[left] ②和left不在同一个数组内 (left在数组1 mid在数组2) 此时 nums[mid]&lt;nums[left] 考虑情况①,target的情况 : 落在mid左边,此时left target mid都在数组1中,只需 right = mid-1; 落在mid右边,此时会出现两种情况, (落在1中)target &gt; nums[mid] || (落在2中)target &lt; nums[left],此时我们让left=mid+1,可以慢慢地将left和right赶到所在的有序数组里面. 考虑情况②,target的情况 : 落在mid右边,此时mid target right都在数组2,只需 left = mid+1; 落在mid左边,此时会出现两种情况,(落在2中)target &lt; nums[mid] || (落在1中) target &gt; nums[right],此时我们让right=mid-1,可以慢慢地将left和right赶到所在的有序数组里面. 1234567891011121314151617181920212223242526272829int search(vector&lt;int&gt;&amp; nums,int target)&#123; int left=0,right=nums.size()-1; while(left&lt;=right)&#123; int mid = left+((right-left)&gt;&gt;1); if (nums[mid] == target) &#123; return mid; &#125; //mid与left落在同一个数组里. if(nums[mid]&gt;=nums[left])&#123; //target 落在 left 和 mid 之间，则移动我们的right，完全有序的一个区间内查找 if (nums[mid] &gt; target &amp;&amp; target &gt;= nums[left]) &#123; right = mid - 1; // target 落在right和 mid 之间，有可能在数组1， 也有可能在数组2 &#125; else if (target &gt; nums[mid] || target &lt; nums[left]) &#123; left = mid + 1; &#125; &#125;else if (nums[mid] &lt; nums[left]) &#123; //有序的一段区间，target 在 mid 和 right 之间 if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; // 两种情况，target 在left 和 mid 之间 &#125; else if (target &lt; nums[mid] || target &gt; nums[right]) &#123; right = mid - 1; &#125; &#125; &#125; return -1;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://coincidenceboy.github.io/categories/LeetCode/"}],"tags":[{"name":"线性表","slug":"线性表","permalink":"https://coincidenceboy.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"java04简易计算器","slug":"java04简易计算器","date":"2021-02-06T04:19:22.000Z","updated":"2021-02-06T04:33:53.310Z","comments":true,"path":"2021/02/06/java04简易计算器/","link":"","permalink":"https://coincidenceboy.github.io/2021/02/06/java04%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/","excerpt":"","text":"基本实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.jay.lesson2;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class Test04SimpleCalculator &#123; public static void main(String[] args) &#123; Calculator calculator = new Calculator(); &#125;&#125;//计算器类class Calculator extends Frame &#123; public Calculator() &#123; //3个文本框 TextField num1 = new TextField(10);//字符数 TextField num2 = new TextField(10);//字符数 TextField num3 = new TextField(20);//字符数 //1个按钮 Button button = new Button(&quot;=&quot;); button.addActionListener(new MyCalculatorListener(num1,num2,num3)); //1个便签 Label label = new Label(&quot;+&quot;); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); pack(); setVisible(true); &#125;&#125;//监听器类class MyCalculatorListener implements ActionListener&#123; //获取三个变量 private TextField num1,num2,num3; public MyCalculatorListener(TextField num1,TextField num2,TextField num3) &#123; this.num1=num1; this.num2=num2; this.num3=num3; &#125; @Override public void actionPerformed(ActionEvent e) &#123; //1.获得 两个加数 //Integer.parseInt(string s) ==&gt; return parseInt(s,10); 10表10进制(radix) int n1 = Integer.parseInt(num1.getText()); int n2 = Integer.parseInt(num2.getText()); //2.将这个值放到第三个框 num3.setText(&quot;&quot;+(n1+n2)); //3.清除前两个框 num1.setText(&quot;&quot;); num2.setText(&quot;&quot;); &#125;&#125; 缺点: 代码像面向过程,显得繁琐 代码改写-面向对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.jay.lesson2;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;//完全改造为 面向对象 代码public class Test05Calculator_plus &#123; public static void main(String[] args) &#123; new Calculator_plus().loadFrame(); &#125;&#125;//计算器类class Calculator_plus extends Frame &#123; //属性 TextField num1,num2,num3; //方法 public void loadFrame()&#123; //3个文本框 num1 = new TextField(10);//字符数 num2 = new TextField(10);//字符数 num3 = new TextField(20);//字符数 //1个按钮 Button button = new Button(&quot;=&quot;); button.addActionListener(new MyCalculatorListener(this)); //1个便签 Label label = new Label(&quot;+&quot;); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); pack(); setVisible(true); &#125;&#125;//监听器类class MyCalculatorListener implements ActionListener &#123; //获得计算器这个对象,在一个类中组合另外一个类 Calculator_plus calculator = null; public MyCalculatorListener(Calculator_plus calculator) &#123; this.calculator = calculator; &#125; @Override public void actionPerformed(ActionEvent e) &#123; int n1 = Integer.parseInt(calculator.num1.getText()); int n2 = Integer.parseInt(calculator.num2.getText()); calculator.num3.setText(&quot;&quot;+(n1+n2)); calculator.num1.setText(&quot;&quot;); calculator.num2.setText(&quot;&quot;); &#125;&#125; 传值 改成 传class 使用内部类进一步封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.jay.lesson2;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;//完全改造为 面向对象 代码public class Test05Calculator_plus &#123; public static void main(String[] args) &#123; new Calculator_plus().loadFrame(); &#125;&#125;//计算器类 内部类写法//内部类最大的好处就是畅通无阻的访问外部的属性和方法class Calculator_plus extends Frame &#123; //属性 TextField num1,num2,num3; //方法 public void loadFrame()&#123; //3个文本框 num1 = new TextField(10);//字符数 num2 = new TextField(10);//字符数 num3 = new TextField(20);//字符数 //1个按钮 Button button = new Button(&quot;=&quot;); button.addActionListener(new MyCalculatorListener()); //1个便签 Label label = new Label(&quot;+&quot;); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); pack(); setVisible(true); &#125; //监听器类 class MyCalculatorListener implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; int n1 = Integer.parseInt(num1.getText()); int n2 = Integer.parseInt(num2.getText()); num3.setText(&quot;&quot;+(n1+n2)); num1.setText(&quot;&quot;); num2.setText(&quot;&quot;); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://coincidenceboy.github.io/categories/java/"}],"tags":[{"name":"GUI","slug":"GUI","permalink":"https://coincidenceboy.github.io/tags/GUI/"}]},{"title":"java基础03","slug":"java基础03","date":"2021-02-03T03:25:26.000Z","updated":"2021-02-03T11:52:48.836Z","comments":true,"path":"2021/02/03/java基础03/","link":"","permalink":"https://coincidenceboy.github.io/2021/02/03/java%E5%9F%BA%E7%A1%8003/","excerpt":"","text":"面向对象编程(OOP) 面向对象编程( Object-Oriented Programming , OOP ) 本质 : 以类(class)的方式组织代码, 以对象的形式封装数据 . 三大特性 封装 继承 多态","categories":[{"name":"java","slug":"java","permalink":"https://coincidenceboy.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://coincidenceboy.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java基础02","slug":"java基础02","date":"2021-02-02T00:38:20.000Z","updated":"2021-02-03T04:02:38.285Z","comments":true,"path":"2021/02/02/java基础02/","link":"","permalink":"https://coincidenceboy.github.io/2021/02/02/java%E5%9F%BA%E7%A1%8002/","excerpt":"","text":"数据类型 命名规范 内存分析 数组 属于引用类型,数组也可以看成对象,数组中每个元素相当于该对象的成员变量. 数组对象本身是在堆中 . java传递参数 结合上述内存分析 , 传参用到的是 栈 来实现的. (栈里保存了基本变量具体数值 和 引用变量的地址.)","categories":[{"name":"java","slug":"java","permalink":"https://coincidenceboy.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://coincidenceboy.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java基础01","slug":"java基础01","date":"2021-02-01T13:12:44.000Z","updated":"2021-02-02T00:39:40.706Z","comments":true,"path":"2021/02/01/java基础01/","link":"","permalink":"https://coincidenceboy.github.io/2021/02/01/java%E5%9F%BA%E7%A1%8001/","excerpt":"","text":"Java课程概括 初识JavaJDK,JRE,JVM ? Java程序运行机制 右侧部分为 jvm 执行内容","categories":[{"name":"java","slug":"java","permalink":"https://coincidenceboy.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://coincidenceboy.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"常用Dos命令","slug":"常用Dos命令","date":"2021-02-01T11:43:29.000Z","updated":"2021-02-01T12:28:07.884Z","comments":true,"path":"2021/02/01/常用Dos命令/","link":"","permalink":"https://coincidenceboy.github.io/2021/02/01/%E5%B8%B8%E7%94%A8Dos%E5%91%BD%E4%BB%A4/","excerpt":"","text":"打开cmd的方式 Win / 所有应用 / W / Windows 系统 / 命令提示符 (右键—&gt;以管理员方式运行) Win+R 输入cmd 任意目录下,按住shift + 鼠标右键 打开powershell 资源管理器地址栏前面加上 cmd空格 常用Dos命令123456789101112131415161718192021222324252627282930#初始状态C:\\Users\\mi&gt;C:\\WINDOWS\\system32&gt;#1.盘符切换C:\\Users\\mi&gt;D:#2.查看当前目录下所有文件 dir#3.切换目录D:\\&gt;cd /d C:\\Users\\mi\\Desktop (跨盘需要加参数/d) cd .. 返回上一级#4.清屏 cls (clear screen)#5.退出终端 exit#6.查看ip ipconfig#7.打开系统工具 calc (calculator) mspaint notepad (新建记事本)#8.ping ping www.bilibili.com#9.新建文件夹C:\\Users\\mi\\Desktop&gt;md test1#10.新建文件C:\\Users\\mi\\Desktop\\test1&gt;cd&gt;a.txt#11.删除文件C:\\Users\\mi\\Desktop\\test1&gt;del a.txt#12.删除目录(目录为空)C:\\Users\\mi\\Desktop&gt;rd test1","categories":[{"name":"win10","slug":"win10","permalink":"https://coincidenceboy.github.io/categories/win10/"}],"tags":[{"name":"Dos命令","slug":"Dos命令","permalink":"https://coincidenceboy.github.io/tags/Dos%E5%91%BD%E4%BB%A4/"}]},{"title":"css浮动布局&盒子模型","slug":"css浮动布局-盒子模型","date":"2021-02-01T02:23:53.000Z","updated":"2021-02-01T03:03:13.463Z","comments":true,"path":"2021/02/01/css浮动布局-盒子模型/","link":"","permalink":"https://coincidenceboy.github.io/2021/02/01/css%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://coincidenceboy.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://coincidenceboy.github.io/tags/css/"}]},{"title":"css基础","slug":"css基础","date":"2021-01-28T10:18:21.000Z","updated":"2021-02-01T02:10:47.247Z","comments":true,"path":"2021/01/28/css基础/","link":"","permalink":"https://coincidenceboy.github.io/2021/01/28/css%E5%9F%BA%E7%A1%80/","excerpt":"","text":"css简介 CSS(Cascading Style Sheets,即层叠样式表),用来为html / xml文档添加样式. 使用css使得结构(html)和表现(css)分离,方便维护. css基本语法 选择器(selector) + 属性(property) + 属性值(value); 1234selector&#123; property: value; ...&#125; css的四种引用方式12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;4种css引入样式&lt;/title&gt; /*&lt;!--3.外部样式,先创建一个css文件,再用link标签引入--&gt;*/ &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style1.css&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; /*&lt;!--4.导入外部样式(先创建一个css文件,在&lt;style&gt;标签中用import导入这个样式)--&gt;*/ @import url(&quot;style2.css&quot;); /*&lt;!--2.内部样式表--&gt;*/ p&#123; background: aqua; font-size: 20px; font-style: italic; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--1.行间样式 直接在标签内 style=&quot; ; &quot;--&gt; &lt;span style=&quot;background:darkred;font-size:30px&quot;&gt;测试行间样式&lt;/span&gt; &lt;p&gt;测试内部样式&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; css-selector通配符selector *{ color:red; } 标签selector p{ color:red; } span{ color:red; } 类selector .class{ color:red; } id selector #id{ color:red; } 派生selector123456&lt;style&gt; /* 指定p标签下的所有span标签颜色为红色 */ p span &#123; color: red; &#125; /* 指定p标签下的子元素span标签颜色为红色 */ p&gt;span &#123; color: red; &#125;&lt;/style&gt; 12345678&lt;style&gt; li+li &#123; color: red; &#125;&lt;/style&gt;&lt;ul&gt; &lt;li&gt;不显示红字1&lt;/li&gt; &lt;li&gt;显示红字2&lt;/li&gt; &lt;li&gt;显示红字3&lt;/li&gt;&lt;/ul&gt; 属性选择器elector[attr] 选择具有attr属性的元素。 elector[attr=”val”] 选择具有attr属性&amp;&amp;attr=”val”的元素。 elector[attr~=”val”] 选择具有attr属性&amp;&amp;属性包含val的元素。 包含 : 多个属性值 其中一个==”val” elector[attr^=”val”] 选择具有attr属性&amp;&amp;属性以val开头的元素。 开头 : 仅以其部分开头即可. elector[attr$=”val”] 选择具有attr属性&amp;&amp;属性以val结尾的元素。 结尾 : 同开头. 123456789101112131415161718192021222324&lt;!--elector[attr]--&gt;&lt;style&gt; div[title] &#123; color: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;div title=&#x27;标题&#x27;&gt;div标签&lt;/div&gt;&lt;/body&gt;&lt;!--elector[attr=val]--&gt;&lt;style&gt; input[type=&quot;text&quot;] &#123; background: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;input type=&quot;text&quot; /&gt;&lt;/body&gt;&lt;!--elector[attr~=val]--&gt;&lt;style&gt; input[class~=&#x27;warning&#x27;] &#123; background: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;input type=&#x27;text&#x27; class=&#x27;input warning&#x27; /&gt;&lt;/body&gt; selector分组 对selector进行分组, 同组的选择器可以共享相同的声明.(逗号隔开) 123&lt;style&gt; h1, h2, h3, h4, h5, h6 &#123; font-size: 12px; &#125;&lt;/style&gt; selector继承 指被包在内部的标签拥有外部标签的样式性质。 继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以用于它的后代。 样式优先级 多重样式：如果外部样式、内部样式和内联样式同时应用于同一个元素，就是使多重样式的情况。 一般情况下，优先级如下：（外部样式）&lt;（内部样式）&lt;（内联样式）。 12345678910111213141516171819&lt;style type=&quot;text/css&quot;&gt; #content div.main_content h2&#123; color:red; &#125; #content .main_content h2&#123; color:blue; &#125;&lt;/style&gt;......&lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;main_content&quot;&gt; &lt;h2&gt;这是一个h2标题&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 第一条样式的权重计算： 100+1+10+1，结果为112； 第二条样式的权重计算： 100+10+1，结果为111； h2标题的最终颜色为red--&gt; css字体样式123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; p&#123; font-size: 28px;/* 80% */ font-family: 汉仪乐喵体简,宋体,&quot;Courier New&quot;,微软雅黑;/* 按优先级排列,字体名称有空格,要用&quot;&quot; */ font-style: normal; font-style: italic; /* 斜体,对于没有斜体变量的字体将应用oblique */ font-style: oblique;/* 斜体 */ font-weight: normal; font-weight: bold; font-weight: bolder; font-weight: lighter; color: red; color: rgb(100,14,200); color: #123456; line-height: normal; line-height: 20px; line-height: 1.5; /*指定normal倍数*/ text-decoration: underline; text-decoration: line-through; text-decoration: overline; text-align: left; /*默认*/ text-align: center; text-align: right; text-transform: capitalize; /*首字母大写*/ text-transform: uppercase; /*转大写*/ text-transform: lowercase; /*转小写*/ text-indent: 24px; text-indent: 2em; /*首行缩进2字符*/ &#125;&lt;/style&gt; css背景样式1234567891011121314151617181920212223&lt;style&gt; div&#123; background-color: transparent;/*默认背景色透明*/ background-color: #123412; /*关于image*/ background-image: url(&quot;./images/pic.png&quot;); background-repeat: repeat;/*默认横向&amp;纵向平铺*/ background-repeat: no-repeat; background-repeat: repeat-x; background-repeat: repeat-y; background-position: 100px 100px; background-position: center center; background-attachment: scroll;/*默认,背景图片跟着页面滚动而滚动*/ background-attachment: fixed; /*背景图片fix不动*/ /*复合属性*/ /*background: color image repeat attachment position*/ background: #fff url(&#x27;../images/pic.png&#x27;) no-repeat fixed center center; &#125;&lt;/style&gt; css伪类selector超链接&lt; a &gt;伪类123456789101112131415&lt;style&gt; /*按照顺序写 love hate*/ a:link&#123;/*未访问的链接样式*/ color:red; &#125; a:visited&#123;/*已访问的链接样式*/ color:green; &#125; a:hover&#123;/*鼠标悬停时的链接样式*/ color:yellow; &#125; a:active&#123;/*鼠标悬停且按下时的链接样式*/ color: blue; &#125;&lt;/style&gt; 表单 : focus123456&lt;style&gt; /*focus表单获得焦点时触发样式。*/ input:focus&#123; background-color: yellow; &#125;&lt;/style&gt; 标签 : nth-child123456789101112&lt;style&gt; /*空格是派生selector,选择所有后代*/ ul li:first-child&#123; color: #ff1299; &#125; ul li:last-child&#123; color: #38ff24; &#125; ul li:nth-child(2)&#123; color: #2c3cff; &#125;&lt;/style&gt; css伪元素selector 伪元素用于向某些选择器设置特殊效果. 12:before/:after/:first-letter/:first-line 1/2个冒号都可::selection/::placeholder/::backdrop 只能是2冒号 :first-letter 向文本的第一个字母添加特殊样式 . 1234&lt;style&gt; p:first-letter &#123; color:red; font-size:30px; &#125;&lt;/style&gt;&lt;p&gt; hello first-letter &lt;/p&gt; :first-line 向文本的首行添加特殊样式 :before 在元素之前添加内容 :after 在元素之后添加内容 关于dom树 CSS伪元素与伪类区别： css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分。 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。 它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 伪元素用于创建一些不在文档树中的元素,并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本, 并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。 伪类允许出现在选择器的任何位置，而一个伪元素只能跟在选择器的最后一个简单选择器后面 伪元素名和伪类名都是大小写不敏感的","categories":[{"name":"前端","slug":"前端","permalink":"https://coincidenceboy.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://coincidenceboy.github.io/tags/css/"}]},{"title":"html表格和表单","slug":"html表格和表单","date":"2021-01-28T09:10:46.000Z","updated":"2021-01-28T10:16:55.255Z","comments":true,"path":"2021/01/28/html表格和表单/","link":"","permalink":"https://coincidenceboy.github.io/2021/01/28/html%E8%A1%A8%E6%A0%BC%E5%92%8C%E8%A1%A8%E5%8D%95/","excerpt":"","text":"&lt; table &gt;&lt; /table &gt;table属性12345border:表格边框width :表格宽度align :表格对齐方式cellspacing(表格间距):单元格间隔cellpadding(表格填充):单元格边沿与内容之间的空白 12345678910111213141516171819202122232425262728293031323334&lt;table align=&quot;center&quot; width=&quot;600px&quot; border=&quot;10px&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4px&quot;&gt; &lt;caption&gt;学生信息表&lt;/caption&gt; &lt;!--表头--&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;住址&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!--表体--&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;内容1&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;内容3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;td&gt;内容3&lt;/td&gt; &lt;td&gt;内容4&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td colspan=&quot;4&quot;&gt;内容1&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!--表脚--&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;注:yds为优秀三好学生&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; &lt; form &gt;&lt; /form &gt; 实现前后端交互的一个重要便签 ! 常用属性123456name:表单名称action:表单数据提交的地方(#表示提交到当前文件)method:前端提交数据到后端的方法,主要有get(默认)和post(提交数据不会暴露在地址栏中)&lt;form name=&quot;test&quot; action=&quot;1.php&quot; method=&quot;get&quot;&gt; &lt;!--表单元素有input,textarea,button,select--&gt;&lt;/form&gt; 表单组件(表单元素) input类,textarea类,select类,button类 input组件1234567891011121314151617181920212223242526272829303132333435name主要是为了传送到后台后,进行区别&lt;form name=&quot;test&quot; action=&quot;1.php&quot; method=&quot;get&quot;&gt; &lt;!--文本输入框:text--&gt; &lt;input type=&quot;text&quot; name=&quot;test&quot; placeholder=&quot;请输入一个数字&quot; value=&quot;1024&quot; disabled&gt; placeholder当未输入的时候的提示字符,如果给一个value初值则placeholder无效 &lt;br&gt; &lt;!--密码输入:password--&gt; &lt;input type=&quot;password&quot; placeholder=&quot;输入密码&quot; minlength=&quot;8&quot; maxlength=&quot;16&quot;&gt; &lt;br&gt; &lt;!--单选钮:radio--&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女 &lt;br&gt; &lt;!--复选框:checkbox--&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;写代码 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;看电影 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;csgo &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;&gt;听音乐 &lt;br&gt; &lt;!--文件上传:file 上传文件到后台--&gt; &lt;input type=&quot;file&quot;&gt; &lt;br&gt; &lt;!--普通按钮:button 通常用其去调用脚本代码--&gt; &lt;input type=&quot;button&quot; value=&quot;登陆&quot;&gt; &lt;br&gt; &lt;!--图片按钮:image 与submit类似 只不是提示信息是图片 不是文字--&gt; &lt;input type=&quot;image&quot; src=&quot;btn.png&quot; title=&quot;刷新&quot;&gt; &lt;br&gt; &lt;!--提交按钮:submit 将表单数据提交到后台--&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;br&gt; &lt;!--重置按钮:reset--&gt; &lt;input type=&quot;reset&quot; value=&quot;reset&quot;&gt; &lt;br&gt;&lt;/form&gt; textarea组件123&lt;form action=&quot;1.php&quot;&gt; &lt;textarea name=&quot;&quot; id=&quot;test1&quot; cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;写下您的评论&quot;&gt;&lt;/textarea&gt;&lt;/form&gt; select组件 通常配合&lt; label &gt;&lt; /label &gt;使用 定义 单选|多选下拉菜单,包含若干个可选项(&lt; option &gt;&lt; /option &gt;) 123456789101112131415&lt;form action=&quot;1.php&quot;&gt; &lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt; &lt;select name=&quot;&quot; id=&quot;sex&quot;&gt; &lt;option value=&quot;male&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;label for=&quot;course&quot;&gt;课程&lt;/label&gt; &lt;select name=&quot;&quot; id=&quot;course&quot; multiple size=&quot;4&quot;&gt; &lt;option value=&quot;Chinese&quot;&gt;语文&lt;/option&gt; &lt;option value=&quot;math&quot;&gt;数学&lt;/option&gt; &lt;option value=&quot;computer&quot;&gt;计算机&lt;/option&gt; &lt;option value=&quot;else&quot;&gt;其他&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; button组件 普通按钮 . 可以不写在form里面单独使用. 如果写在form里面,则用做提交功能. 1234&lt;form action=&quot;1.php&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;info&quot;&gt; &lt;button&gt;提交&lt;/button&gt; &lt;!--这里的button组件功能 与 input组件type=&quot;submit&quot;功能相同--&gt;&lt;/form&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://coincidenceboy.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://coincidenceboy.github.io/tags/html/"}]},{"title":"html标签属性","slug":"html标签属性","date":"2021-01-28T09:09:49.000Z","updated":"2021-01-28T09:23:01.704Z","comments":true,"path":"2021/01/28/html标签属性/","link":"","permalink":"https://coincidenceboy.github.io/2021/01/28/html%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7/","excerpt":"","text":"html属性通用属性 id : 元素唯一的id class : 元素的类名 可以有多个 例如 &lt; p class=”class1 class2”&gt;段落&lt; /p &gt; style : 规定元素的行内样式 title : 鼠标停留在元素上时的提示文本 . 自定义属性 常用于 图片懒加载 html5 规定 自定义属性的格式为 data-* ,例如data-src 12&lt;!--以下代码是实际开发的案例，img标签显示的是缩略图，而data-src的值为点击显示原图的地址--&gt;&lt;img src=&#x27;./img/1.jpg&#x27; data-src=&#x27;./img/big_1.jpg&#x27;&gt; 各便签的自有属性","categories":[{"name":"前端","slug":"前端","permalink":"https://coincidenceboy.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://coincidenceboy.github.io/tags/html/"}]},{"title":"html基本标签","slug":"html常用标签","date":"2021-01-28T06:30:33.000Z","updated":"2021-01-28T09:09:16.785Z","comments":true,"path":"2021/01/28/html常用标签/","link":"","permalink":"https://coincidenceboy.github.io/2021/01/28/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/","excerpt":"","text":"前端引入 ​ 前端开发又称 web前端开发,指的是基于web的网页界面美化及功能开发. 前端开发需要的技术 html5 css3 JavaScript Bootstrap jQuery Ajax HTML简介 HTML(HyperText Mark-up Language)即: 超文本标记语言 . 关于浏览器 五大主流浏览器 IE(Internet Explorer) , 火狐(FireFox) , Chrome(谷歌) , Opera(欧朋) , Safari(苹果). 浏览器内核 Trident内核 : 又称IE内核,是微软开发的一种排版引擎 . (使用Trident渲染引擎的浏览器主要有IE,遨游,qq浏览器) Gecko内核 : 代表产品Mozila FirefoxGecko是一套c++编写的开源排版引擎. (使用Gecko内核的浏览器主要有Firefox,Netscape 6~9) WebKit内核 : 主要用于Mac OS系统代表产品有Safari . (使用WebKit的浏览器主要有Safari和Chrome) Presto内核 : 代表产品OperaPresto是由Opera Software开发的浏览器排版引擎,它是世界上公认最快的渲染速度的引擎. 在13年后,Opera宣布加入谷歌阵营,之后弃用. Blink内核 : 由Google和Opera Software开发的浏览器排版引擎,13年4月发布 . 现在Chrome和Opera内核都是Blink. 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;!--zh-CN表中文--&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--网页编码--&gt; &lt;meta name=&quot;Generator&quot; content=&quot;webstorm&quot;&gt;&lt;!--开发工具--&gt; &lt;meta name=&quot;Author&quot; content=&quot;Jay_Yue&quot;&gt;&lt;!--作者--&gt; &lt;meta name=&quot;Keywords&quot; content=&quot;HTML5,CSS3,jQuery&quot;&gt;&lt;!--关键字--&gt; &lt;meta name=&quot;Description&quot; content=&quot;是但求其爱&quot;&gt;&lt;!--描述--&gt; &lt;title&gt;HTML标签及规范&lt;/title&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;&lt;!--小图标link:favicon--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; type=&quot;text/css&quot;&gt;&lt;!--引入外部样式--&gt; &lt;style type=&quot;text/css&quot;&gt; /*放css3代码*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--主体部分--&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;index.js&quot;&gt; /*放js脚本*/&lt;/script&gt;&lt;/html&gt; 123456789&lt;html&gt;&lt;/html&gt;称为根元素,包裹所有网页元素;&lt;head&gt;&lt;/head&gt;文档头部, 头部元素包含&lt;meta&gt; , &lt;title&gt; , &lt;link&gt; , &lt;style&gt;&lt;/style&gt; 1.&lt;meta&gt;标签提供关于html文档的元数据.元数据不会显示在页面上,但是对于机器是可读的. 元数据可用于浏览器(如何显示内容或者重新加载页面),搜索引擎(关键词),或其他web服务. 2.&lt;title&gt;定义网页的标题 3.&lt;link&gt;引入外部样式 4.&lt;style&gt;为html定义样式信息 5.&lt;script&gt;定义页面的脚本内容.&lt;body&gt;&lt;/body&gt; 网页显示的主要内容 html标签常见双标签&lt; h1-h6 &gt;&lt; /h1-h6 &gt; 标题,会自动加粗 &lt; div &gt;&lt; /div &gt; 主要用于文档布局 , 取代了使用表格布局的老式方法. 用于组合其他html元素的容器. &lt; p &gt;&lt; /p &gt; 定义段落. &lt; a &gt;&lt; /a &gt;12345&lt;a href=&quot;链接的目标url&quot; target=&quot;文档重定向&quot;&gt;文字或者图片(img)跳转&lt;/a&gt;target=&quot;_blank&quot; 新打开窗口载入 =&quot;_self&quot; 默认 =&quot;_parent&quot; =&quot;_top&quot; &lt; span &gt;&lt; /span &gt; 用来组合文档中的 行内元素 , 可用作文本的容器. &lt; span &gt;没有 固定的格式表现,当对其应用样式时,才会产生视觉上的变化. &lt; address &gt;&lt; /address &gt; 地址信息 &lt; q &gt;&lt; /q &gt; 短文本引用 (文本不用加引号,浏览器渲染时会自动加上引号) &lt; caption &gt;&lt; /caption &gt; 为表格(table)添加标题和摘要 &lt; ul &gt;&lt; /ul &gt;123456//无序列表 unordered list&lt;ul&gt; &lt;li&gt;list1&lt;/li&gt; &lt;li&gt;list2&lt;/li&gt; &lt;li&gt;list3&lt;/li&gt;&lt;/ul&gt; &lt; ol &gt;&lt; /ol &gt;123456//有序列表 ordered list&lt;ol&gt; &lt;li&gt;list1&lt;/li&gt; &lt;li&gt;list2&lt;/li&gt; &lt;li&gt;list3&lt;/li&gt;&lt;/ol&gt; 常见单标签&lt; br &gt; 换行 &lt; hr &gt; 分割线 &lt; img &gt;1&lt;img src=&quot;图像的url&quot; alt=&quot;代替文本(图像加载不出来时)&quot; title=&quot;鼠标移动到图片时的提示文字&quot;&gt; 文本格式化标签&lt; b &gt;&lt; /b &gt; 加粗 &lt; strong &gt;&lt; /strong &gt; 加粗且强调 &lt; i &gt;&lt; /i &gt; 倾斜 &lt; em &gt;&lt; /em &gt; 倾斜且强调 &lt; pre &gt;&lt; /pre &gt; 预格式化文本 , 即:包裹在pre标签里面的文本 会保留空格和换行符,文本也会呈现等宽字体. &lt; small &gt;&lt; /small &gt; 小号字体 &lt; sub &gt;&lt; /sub &gt; 下标 &lt; sup &gt;&lt; /sup &gt; 上标 实体转义符1234567&amp;lt; &lt;!-- &lt; --&gt;&amp;gt; &lt;!-- &gt; --&gt;&amp;amp; &lt;!-- &amp; --&gt;&amp;nbsp; &lt;!-- 空格 --&gt;&amp;copy; &lt;!-- 版权号© --&gt;&amp;times; &lt;!-- 乘法× --&gt;&amp;divide; &lt;!-- 除法÷ --&gt; html块级元素和行级元素 根据css规范,每一个网页元素都有一个display属性,用于确定该元素的类型. 每个元素都有一个默认的display属性值,如div : display=”block” , 即块级元素 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而span : display=”inline” , 即行级元素. 块级(block)元素:独占一行,可以设置 width,height等属性(宽度没有设置时,默认为100%) 用来搭建网络构架,布局,承载内容等 行级(inline)元素(内联元素):不独占一行,相邻的行内元素会排列在同一行里,直到一行排不下才会换行, 设置width,height等无效. 一般用在网站内容的某处细节,用来”强调,区分样式,上标,下标等” 块元素可以包含 内联元素&amp;某些块元素, 但内联元素只能包含内联元素; (部分特殊的块级元素只能包含内联元素,如h1-h6) 块级元素与块级元素并列、内嵌元素与内嵌元素并列。","categories":[{"name":"前端","slug":"前端","permalink":"https://coincidenceboy.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://coincidenceboy.github.io/tags/html/"}]},{"title":"动态规划2-背包问题","slug":"动态规划2-背包问题","date":"2021-01-24T12:42:15.000Z","updated":"2021-01-27T09:04:15.830Z","comments":true,"path":"2021/01/24/动态规划2-背包问题/","link":"","permalink":"https://coincidenceboy.github.io/2021/01/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://coincidenceboy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"动态规划1-引入","slug":"动态规划1-引入","date":"2021-01-24T12:41:25.000Z","updated":"2021-01-27T09:02:09.927Z","comments":true,"path":"2021/01/24/动态规划1-引入/","link":"","permalink":"https://coincidenceboy.github.io/2021/01/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921-%E5%BC%95%E5%85%A5/","excerpt":"","text":"例1-爬楼梯 12345678910111213141516//动态规划int f[N];//表示走到n阶时的方案数.//初始化f[1]=1,f[2]=2;for(int i=3;i&lt;=n;i++) f[i]=f[i-1]+f[i-2];ans=f[n];//记忆化递归(带备忘的自顶向下法)int solve(int n)&#123; if(f[n]) return f[n]; if(n==1) return f[1]=1; if(n==2) return f[2]=1; return f[n]=solve(n-1)+solve(n-2);&#125; 例2-爬楼梯(进阶) 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;int f[N],n,k,m;bool vis[N];int main()&#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; for(int i=1;i&lt;=m;i++)//记录不能落脚的阶梯 &#123; int tmp;cin&gt;&gt;tmp; vis[tmp]=1; &#125; f[0]=1; for(int i=1;i&lt;=n;i++) &#123; if(vis[i]) continue; for(int j=max(0,i-k);j&lt;=i-1;j++) f[i]+=f[j]; &#125; cout&lt;&lt;f[n]&lt;&lt;endl; return 0;&#125; 关于该题的一些思考 例3-覆盖墙壁 123456789//找规律f[1]=1;f[2]=2;f[3]=5;f[4]=11;f[5]=24;不妨猜想:f[i]=2*f[i-1]+f[i-3];实际验证f[13]=13465 基本确定这个等式是成立的 问题是 该等式怎么求?","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://coincidenceboy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"dfs总结","slug":"dfs总结","date":"2021-01-19T12:42:39.000Z","updated":"2021-01-28T01:17:08.356Z","comments":true,"path":"2021/01/19/dfs总结/","link":"","permalink":"https://coincidenceboy.github.io/2021/01/19/dfs%E6%80%BB%E7%BB%93/","excerpt":"","text":"经典问题从n个数中选k个 ∑=sum (回溯)12345678910111213141516171819202122232425262728293031323334353637//递归(回溯)#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5;int n,k,sum,a[N];vector&lt;int&gt; v;int s,ans;void dfs(int cnt,int i)//cnt选几个 进行到i数组第几位&#123; if(s&gt;sum) return; if(cnt==k) &#123; if(s==sum) &#123; for(int j=0;j&lt;k;j++) cout&lt;&lt;v[j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; ans++; &#125; return; &#125; for(i;i&lt;=n;i++) &#123; v.push_back(a[i]); s += a[i]; dfs(cnt+1,i+1); v.pop_back(); s -= a[i];//回溯 &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;sum; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; dfs(0,1); cout&lt;&lt;&quot;ans:&quot;&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 从n个数中选任意个 ∑=sum (递归 / 01背包)递归123456789101112131415161718192021222324252627//递归(无回溯)#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5;int n, sum, a[N];int ans;void dfs(int i, int s)&#123; if (s &gt; sum) return;//if a[i]&gt;0 if (i &gt; n) &#123; if (s == sum) ans++; return; &#125; dfs(i + 1, s + a[i]); dfs(i + 1, s);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; sum; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 01背包1234567891011121314151617181920212223242526272829303132333435//01背包#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3+5,SUM=1e4+5;int n,sum,a[N];int dp[N][SUM];int main()&#123; cin&gt;&gt;n&gt;&gt;sum; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; //dp[i][j] 表示仅考虑前i个数,∑为j的方案数 //初始化 for (int i = 0; i &lt;= n; i++) dp[i][0] = 1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=sum;j++) &#123; dp[i][j]+=dp[i-1][j]; if(j-a[i]&gt;=0) dp[i][j]+=dp[i-1][j-a[i]]; &#125; &#125; cout&lt;&lt;dp[n][sum]&lt;&lt;endl; /* 滚动数组 dp[0]=1; for(int i=1;i&lt;=n;i++) for(int j=m;j&gt;=a[i];j--)//逆序 防止覆盖 dp[j]+=dp[j-a[i]]; //无须dp[i][j]+=dp[i-1][j]; 因为每一重i相当于上一重的继承 cout&lt;&lt;dp[sum]&lt;&lt;endl; */ return 0;&#125; 全排列~permutation 123456789101112131415161718192021222324252627282930//递归(回溯)#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5;int n, a[N];void permutation(int k,int m)&#123; if (k == m) &#123; for (int i = 1; i &lt;= m; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return; &#125; for(int i=k;i&lt;=m;i++) &#123;//每次循环都是 从第k个开始与后面包括自己的每个位swap swap(a[i],a[k]); permutation(k+1,m); swap(a[i],a[k]); &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a+1,a+1+n); permutation(1,n); return 0;&#125; 记忆化递归 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 25;int n;long long f[N][N];long long dfs(int i, int j)&#123;//i表示操作队列还有几个数,j表示栈中有多少数 if (f[i][j]) return f[i][j]; if (i == 0) return 1; if (j &gt; 0) f[i][j] += dfs(i, j - 1); f[i][j] += dfs(i - 1, j + 1); return f[i][j];&#125;int main()&#123; ios::sync_with_stdio(0); cin &gt;&gt; n; cout &lt;&lt; dfs(n, 0) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://coincidenceboy.github.io/tags/DFS/"}]},{"title":"全排列next_permutation","slug":"全排列next-permutation","date":"2021-01-19T09:31:29.000Z","updated":"2021-01-20T08:12:55.577Z","comments":true,"path":"2021/01/19/全排列next-permutation/","link":"","permalink":"https://coincidenceboy.github.io/2021/01/19/%E5%85%A8%E6%8E%92%E5%88%97next-permutation/","excerpt":"","text":"next_permutationint型全排列1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a[5] = &#123; 0,4,2,3,1 &#125;; sort(a + 1, a + 1 + 4); do &#123; for (int i = 1; i &lt;= 4; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; while (next_permutation(a + 1, a + 1 + 4)); return 0;&#125; 字符串全排列123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; cin &gt;&gt; s; sort(s.begin(), s.end()); do &#123; for (int i = 0; i &lt;= s.size(); i++) cout &lt;&lt; s[i]; cout &lt;&lt; endl; &#125; while (next_permutation(s.begin(), s.end())); return 0;&#125; 参考博客 — 火星人-变进制数 123456789101112131415161718192021222324252627282930313233343536373839a[7]=&#123;1,2,3,4,5,6,7&#125;组成的序列可以看成一个变进制数进制从高到低 依次为 7-&gt;6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1 //1进制只有0 对应的权重 依次为 6! 5! 4! 3! 2! 1! 0//****************************************************************#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4+5; int a[N];bool vis[N]; int m,n;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; int x=a[i]; for(int j=1;j&lt;=a[i];j++) x-=vis[j]; vis[a[i]]=1; a[i]=x-1; &#125; a[n]+=m; for(int i=n;i&gt;0;i--) &#123; a[i-1]+=a[i]/(n-i+1); a[i]%=n-i+1; &#125; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;=a[i];j++) if(vis[j]) a[i]++; cout&lt;&lt;a[i]+1&lt;&lt;&quot; &quot;; vis[a[i]]=1; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://coincidenceboy.github.io/tags/STL/"}]},{"title":"算法导论","slug":"算法导论","date":"2020-12-29T12:07:03.000Z","updated":"2020-12-29T13:37:09.927Z","comments":true,"path":"2020/12/29/算法导论/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"CH23 最小生成树Prim算法 Prim算法的关键在于 : 维护一个点集 A 并且集合A的边总是构成一棵树(这棵树从任意节点 r 开始一直长大到覆盖V中所有节点为止) 算法的每一步在连接集合A和V-A的节点的所有的边中,选择一条轻量级边加入A中. 根据推论23.2,这条规则加入的边都是对A安全的边. 伪码实现 MST-Prim(G,w,r)123456789101112131415161718for each u∈G.V u.key=∞ u.π=NULr.key=0Q=G.Vwhile Q≠∅ u=extract-min(Q) for each v∈G.Adj[u] if v∈Q and w(u,v) &lt; v.key v.π=u v.key=w(u,v)******************************其实注意到队列Q也是每个节点只弹出一次,也就是说 节点被弹出一次后 后续再将该节点入队/更新等操作都没有关系所以上述伪代码第9行可以去掉条件v∈Q 只保留 if w(u,v) &lt; v.key 这样的话 跟Dijstra伪码是一致的//注意算法第5行之后,我们不会再向队列Q中insert节点,即每个节点加入队列和被抽取的次数均1次.//但是具体实现的时候,去更新已经入队的元素的关键字不易,我们可以在每次更新的时候都插入一次(相当于更新操作),//但是只从队列中抽取一次. CH24 单源最短路Dijkstra算法 Dijkstra算法的关键在于 : 维护一个点集 S 点集S : 从源点s到该点集中任意节点之间的最短路径已经找到 . 同样de , 点集 V-S 中任意一点u dis[u]也表示s到u的最短路径 (但该最短路径仅经过集合S中的点) 算法重复从节点集 V-S 中选择最短路径估计最小的节点u加入集合S , 并且对所有从u出发的边进行松弛操作. 1234567891011initialize-single-source(G,s)for each vertex v∈G,V v.d=∞ v.π=NILs.d=0*****************************relax(u,v,w)if v.d&gt;u.d+w v.d=u.d+w v.π=u***************************** 伪码实现1234567891011initialize-single-source(G,s)S=∅Q=G.Vwhile Q≠∅ u=extract-min(Q) //从堆Q中删除最小关键字的元素(每个节点的关键字为其d值 S=S∪&#123;u&#125; for each vertex v∈G.Adj[u] relax(u,v,w) //relax的时候优先队列Q里的关键字相应的改变//注意算法第3行之后,我们不会再向队列Q中insert节点,即每个节点加入队列和被抽取的次数均1次.//但是具体实现的时候,去更新已经入队的元素的关键字不易,我们可以在每次更新的时候都插入一次(相当于更新操作),//但是只从队列中抽取一次. 证明","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"https://coincidenceboy.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}]},{"title":"强连通分量Kosaraju","slug":"强连通分量Kosaraju","date":"2020-12-27T04:36:59.000Z","updated":"2020-12-27T14:11:31.937Z","comments":true,"path":"2020/12/27/强连通分量Kosaraju/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/27/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FKosaraju/","excerpt":"","text":"DFS后序12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 5;const int M = 1e5 + 5;bool vis[N];int d[N], f[N], dcnt, fcnt;void dfs(int u)&#123; vis[u] = true; //原本d[u]=++time;记录的是发现时间 d[++dcnt] = u; for (int i = head[u]; ~i; i = e[i].next) &#123; int v = e[i].v; if (!vis[v]) dfs(v); &#125; //原本f[u]=++time;记录的是完成时间 f[++fcnt] = u;//dfs后序,相当于是按完成时间小--&gt;大依次存储&#125;int main()&#123; //省略点,边的声明 for (int i = 1; i &lt;= n; i++) if (!vis[i]) dfs(i); return 0;&#125; 强连通分量(SCC) 相关概念: 强连通:有向图G中任意两点u–&gt;v v–&gt;u都可达. 强连通分量(scc):极大的强连通子图 Kosaraju板子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//所有数组的下标均从1开始#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 5;const int M = 1e5 + 5;int n, m;//链式前向星struct edge&#123; int v, next;&#125;e1[M], e2[M];int cnt1, cnt2, head1[N], head2[N];void add1(int u, int v)&#123; cnt1++; e1[cnt1].v = v, e1[cnt1].next = head1[u]; head1[u] = cnt1;&#125;void add2(int u, int v)&#123; cnt2++; e2[cnt2].v = v, e2[cnt2].next = head2[u]; head2[u] = cnt2;&#125;//kosaraju-dfsbool vis[N];int f[N], fcnt;void dfs1(int u)&#123; vis[u] = true; for (int i = head1[u]; ~i; i = e1[i].next) &#123; int v = e1[i].v; if (!vis[v]) dfs1(v); &#125; f[++fcnt] = u;//dfs后序&#125;int snum[N];//snum[i]记录:节点i 所在的scc的序号int scc[N], scnt;//scnt--&gt;scc计数器 scc[i]--&gt;第i个scc里包含节点数void dfs2(int u)&#123; snum[u] = scnt; scc[scnt]++; for (int i = head2[u]; ~i; i = e2[i].next) &#123; int v = e2[i].v; if (!snum[v]) dfs2(v); &#125;&#125;void kosaraju()&#123; //第一遍dfs---&gt;生成dfs后序 for (int i = 1; i &lt;= n; i++) if (!vis[i]) dfs1(i); //第二遍dfs---&gt;在反图中按dfs逆后序 遍历构成SCC //逆后序起到了类似 拓扑序 的作用 for (int i = n; i &gt;= 1; i--) if (!snum[f[i]]) scnt++, dfs2(f[i]);&#125;void init()&#123; //链式前向星-初始化 cnt1 = 0, cnt2 = 0; memset(head1, -1, sizeof head1); memset(head2, -1, sizeof head2); //kosaraju--dfs-初始化 fcnt = 0, scnt = 0; memset(vis, 0, sizeof vis); memset(scc, 0, sizeof scc);&#125; 例题–班长竞选 思路 有向图通常考虑SCC并缩点,即将互相可达 与 单向可达 分开考虑. 缩点后,不难发现对于 属于第i个SCC的点来说 , 票数的构成分为两部分(令SCC[i]表示第i个SCC中点的个数) 当前SCC中的点, ans += SCC[I] - 1;(去掉自己) 其他SCC中的点, ans += sum(SCC[j]) 其中 j—&gt;i 可达 稍加思考可以发现,缩点后变成一个DAG(有向无环图),最后答案一定出现在 出度为0 的 SCC中,因为具有传递性, 所以 如果出度不为0,你指向的SCC会继承你之前的票数并加上你本身 对于ans如何求取比较方便? 缩点之后,将图反向 (或者 直接在反图中缩点) 原本答案出现在 出度为0 的SCC们 变成了 入度为0 的SCC们 , 用dfs搜一遍 并且记录 个数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 5005;const int M = 50005;int n, m;//链式前向星struct edge&#123; int v, next;&#125;e1[M], e2[M], e[M];int cnt1, cnt2, head1[N], head2[N];void add1(int u, int v)&#123; cnt1++; e1[cnt1].v = v, e1[cnt1].next = head1[u]; head1[u] = cnt1;&#125;void add2(int u, int v)&#123; cnt2++; e2[cnt2].v = v, e2[cnt2].next = head2[u]; head2[u] = cnt2;&#125;//kosaraju-dfsbool vis[N];int f[N], fcnt;void dfs1(int u)&#123; vis[u] = true; for (int i = head1[u]; ~i; i = e1[i].next) &#123; int v = e1[i].v; if (!vis[v]) dfs1(v); &#125; f[++fcnt] = u;//f[1到fcnt]记录dfs后序&#125;int snum[N];//snum[i]记录:节点i 所在的scc的序号int scc[N], scnt;//scnt--&gt;scc计数器 scc[i]--&gt;第i个scc里包含节点数void dfs2(int u)&#123; snum[u] = scnt; scc[scnt]++; for (int i = head2[u]; ~i; i = e2[i].next) &#123; int v = e2[i].v; if (!snum[v]) dfs2(v); &#125;&#125;void kosaraju()&#123; //第一遍dfs---&gt;生成dfs后序 for (int i = 1; i &lt;= n; i++) if (!vis[i]) dfs1(i); //第二遍dfs---&gt;在反图中按dfs逆后序 遍历构成SCC for (int i = n; i &gt;= 1; i--) if (!snum[f[i]]) scnt++, dfs2(f[i]);&#125;int cnt, head[N], in_deg[N];//缩点void add(int u, int v)&#123; cnt++; e[cnt].v = v, e[cnt].next = head[u]; head[u] = cnt; in_deg[v]++;&#125;void shrink()&#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = head2[i]; ~j; j = e2[j].next) &#123; int v = e2[j].v; if (snum[i] == snum[v]) continue; add(snum[i], snum[v]); &#125; &#125;&#125;//dfs计算票数int temp, ans[N];bool flag[N];//用于dfs搜索bool maxscc[N];//用于标记scc 是不是最多票数void dfs(int u)&#123; temp += scc[u]; flag[u] = true; for (int i = head[u]; ~i; i = e[i].next) &#123; int v = e[i].v; if (!flag[v]) dfs(v); &#125;&#125;void init()&#123; //链式前向星-初始化 cnt1 = 0, cnt2 = 0; memset(head1, -1, sizeof head1); memset(head2, -1, sizeof head2); //缩点建新图-初始化 cnt = 0; memset(head, -1, sizeof head); memset(in_deg, 0, sizeof in_deg); //kosaraju dfs-初始化 fcnt = 0, scnt = 0; memset(vis, 0, sizeof vis); memset(scc, 0, sizeof scc); memset(snum, 0, sizeof snum); //计算票数 temp = 0; memset(flag, 0, sizeof flag); memset(ans, 0, sizeof ans); memset(maxscc, 0, sizeof maxscc);&#125;int main()&#123; ios::sync_with_stdio(false); int t; cin &gt;&gt; t; int case_num = 1; while (t--) &#123; init(); cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; u++, v++;//将节点0到n-1 转化为 1到n add1(u, v); add2(v, u); &#125; kosaraju(); //此时snum[i]记录:节点i 所在的scc的序号 //scnt--&gt;scc计数器 scc[i]--&gt;第i个scc里包含节点数 shrink();//在反图中缩点 //此时节点从1-n变为1-scnt 边数(cnt)仅包含 不同scc之间的边(节点1到节点scnt之间相连) //in_deg[1-scnt] 记录了新图节点的入度 int maxans = 0; for (int i = 1; i &lt;= scnt; i++) &#123; if (in_deg[i] == 0) &#123; temp = 0; memset(flag, 0, sizeof flag); dfs(i); ans[i] = (temp - 1); maxans = max(ans[i], maxans); &#125; &#125; for (int i = 1; i &lt;= scnt; i++) &#123; if (ans[i] == maxans) maxscc[i] = true; &#125; cout &lt;&lt; &quot;Case &quot; &lt;&lt; case_num++ &lt;&lt; &quot;: &quot; &lt;&lt; maxans &lt;&lt; endl; bool space = 0; for (int i = 1; i &lt;= n; i++) &#123; if (maxscc[snum[i]]) &#123; if (!space) space = true, cout &lt;&lt; i - 1; else cout &lt;&lt; &quot; &quot; &lt;&lt; i - 1; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://coincidenceboy.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"强连通分量","slug":"强连通分量","permalink":"https://coincidenceboy.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}]},{"title":"B样条","slug":"B样条","date":"2020-12-23T09:32:04.000Z","updated":"2020-12-23T10:14:49.559Z","comments":true,"path":"2020/12/23/B样条/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/23/B%E6%A0%B7%E6%9D%A1/","excerpt":"","text":"B样条原理讲解 代码实现main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&quot;struct.h&quot;using namespace std;int site_left = 1020;int site_top = 100;int WinW = 500;int WinH = 450;vector&lt;point&gt; input;int nowid; //用于鼠标移动int k=3; //定义阶数k=3阶 k-1次bool check(int i, int tx, int ty)&#123; int num = 15; int x = input[i].x, y = input[i].y; if (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num) &#123; return true; &#125; return false;&#125;void display()&#123; glClearColor(200.0 / 255, 200.0 / 255, 169.0 / 255, 0.0); //设定清理颜色 glClear(GL_COLOR_BUFFER_BIT); //清理缓冲区 glFlush();&#125;void drawOnePoint(int x, int y)&#123; glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glPointSize(4); glBegin(GL_POINTS); glVertex2d(x, y); glEnd(); glFlush();&#125;void drawLine(int x1, int y1, int x2, int y2)&#123; glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glEnable(GL_LINE_SMOOTH); glLineWidth(1); glBegin(GL_LINES); glVertex2i(x1, y1); glVertex2i(x2, y2); glEnd(); glFlush();&#125;void redraw()&#123; //缓冲区重绘 glClearColor(200.0 / 255, 200.0 / 255, 169.0 / 255, 0.0); //设定清理颜色 glClear(GL_COLOR_BUFFER_BIT); //控制点重绘 glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glPointSize(4); glBegin(GL_POINTS); for (int i = 0; i &lt;= input.size() - 1; i++) glVertex2d(input[i].x, input[i].y); glEnd(); //特征多边形重绘 glLineWidth(1); glBegin(GL_LINES); for (int i = 1; i &lt;= input.size() - 1; i++) drawLine(input[i - 1].x, input[i - 1].y, input[i].x, input[i].y); glEnd(); glFlush();&#125;extern void de_Boor();extern void de_Boor_id(int id);void mouseClick(int button, int state, int nowx, int nowy) //x,y均是以窗口左上角为（0,0）的像素表示&#123; int x, y; x = nowx, y = WinH - nowy; int id = -1; for (int i = 0; i &lt; input.size(); i++) &#123; if (check(i, x, y)) &#123; id = i; break; &#125; &#125; //insert if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) &#123; if (id == -1) &#123; drawOnePoint(x, y); input.push_back(point(x, y)); nowid = input.size() - 1; if (nowid &gt;= 1) &#123; drawLine(input[nowid - 1].x, input[nowid - 1].y, input[nowid].x, input[nowid].y); &#125; if (input.size() &gt;= k) de_Boor(); &#125; else nowid = id; &#125; //画出B样条 else if (button == GLUT_MIDDLE_BUTTON &amp;&amp; state == GLUT_DOWN) &#123; redraw(); if (input.size() &gt;= k) de_Boor(); &#125; // delete else if (button == GLUT_RIGHT_BUTTON &amp;&amp; state == GLUT_DOWN) &#123; if (id != -1) &#123; nowid = id; input.erase(input.begin() + nowid); redraw(); if (input.size() &gt;= k) de_Boor(); &#125; &#125;&#125;void mouseMotion(int nowx, int nowy)&#123; int x = nowx, y = WinH - nowy; input[nowid].x = x, input[nowid].y = y; if (input.size() &gt;= k) &#123; redraw(); de_Boor(); de_Boor_id(nowid); &#125;&#125;void keyBoards(unsigned char key, int x, int y)&#123; if (key == 107||key == 75) //k || K &#123; cout &lt;&lt; &quot;请输入k值:&quot; &lt;&lt; endl; cin &gt;&gt; k; if (input.size() &gt;= k) &#123; cout &lt;&lt; &quot;B样条已重绘&quot; &lt;&lt; endl; redraw(); de_Boor(); &#125; &#125;&#125;int main()&#123; glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); //显示窗口的缓存和颜色模型 glutInitWindowPosition(site_left, site_top); glutInitWindowSize(WinW, WinH); glutCreateWindow(&quot;交互贝塞尔曲线-Bezier&quot;); //创建带标题的窗口 gluOrtho2D(0, WinW, 0, WinH); // 区域大小定义 窗口的左下角是（0，0） cout &lt;&lt; &quot; 鼠标左键点击 -----&gt; 绘制特征多边形&quot; &lt;&lt; endl; cout &lt;&lt; &quot; 鼠标中键 -----&gt; 画出B样条曲线&quot; &lt;&lt; endl; cout &lt;&lt; &quot; 鼠标右键 -----&gt; 删除指向特征点&quot; &lt;&lt; endl; cout &lt;&lt; &quot; 鼠标左键拖拽 -----&gt; 重绘B样条曲线&quot; &lt;&lt; endl; cout &lt;&lt; &quot;键盘输入k或者K -----&gt; 指定k值并重绘&quot; &lt;&lt; endl; glutDisplayFunc(&amp;display); //事件1：显示函数 glutMouseFunc(mouseClick); //事件2：鼠标点击 glutMotionFunc(mouseMotion); //事件3：鼠标移动 glutKeyboardFunc(&amp;keyBoards); //事件4：监听键盘 glutMainLoop(); //让事件保持循环 return 0;&#125; struct.h1234567891011121314151617181920#pragma once#include&lt;gl/glut.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;struct point&#123; double x, y; point() &#123; x = -1, y = -1; &#125; point(double x1, double y1) &#123; x = x1, y = y1; &#125; point operator * (double t) &#123; return point(t * x, t * y); &#125; point operator + (point p) &#123; return point(x + p.x, y + p.y); &#125;&#125;; B样条.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&quot;struct.h&quot;extern int k;extern vector&lt;point&gt;input;vector&lt;double&gt; T;vector&lt;point&gt; P;vector&lt;point&gt; ans;void draw_Bline(vector&lt;point&gt; out)&#123; glColor3f(252.0 / 255, 157.0 / 255, 154.0 / 255); glPointSize(1); glBegin(GL_POINTS); for (int i = 0; i &lt; out.size(); i++) glVertex2d(out[i].x, out[i].y); glEnd(); glFlush();&#125;void de_Boor()&#123; vector&lt;point&gt; next; T.clear(); ans.clear(); P.clear(); point tmp; int n = input.size()-1; //所以控制点数为 n+1 //区间均匀B样条 for (int i = 0; i &lt;= n + k; i++) T.push_back(i); for (int j = k - 1; j &lt;= n; j++)//枚举区间j &#123; for (double t = T[j]; t &lt; T[j + 1]; t += 0.001) //先把t固定在区间[t j,t j+1]上 &#123; //r=0时,0次Pi(t) = p[i] 并且 i= j - k + 1; i &lt;= j for (int i = j - k + 1; i &lt;= j; i++) &#123; P.push_back(input[i]); &#125; //r= 1 到 k-1 时,即r次Pi(t) for (int r = 1; r &lt;= k - 1; r++) &#123; for (int i = j - k + r + 1; i &lt;= j; i++) &#123; tmp = P[i - (j - k + r + 1) + 1] * ((t - T[i]) / (T[i + k - r] - T[i])) + P[i - (j - k + r + 1)] * ((T[i + k - r] - t) / (T[i + k - r] - T[i])); //* (p[i + 1][r - 1]); next.push_back(tmp); &#125; P = next; next.clear(); &#125; //最后为r次P ans.push_back(P[0]); P.clear(); &#125; &#125; draw_Bline(ans); return;&#125;void de_Boor_id(int id)&#123; vector&lt;point&gt; next; ans.clear(); point tmp; int n = input.size() - 1; //所以控制点数为 n+1 int a = max(id, k - 1), b = min(id + k - 1, n); //会影响到的区间数目 for (int j = a; j &lt;= b; j++) &#123; for (double t = T[j]; t &lt; T[j + 1]; t += 0.001) &#123; for (int i = j - k + 1; i &lt;= j; i++) &#123; P.push_back(input[i]); &#125; for (int r = 1; r &lt;= k - 1; r++) &#123; for (int i = j - k + r + 1; i &lt;= j; i++) &#123; tmp = P[i - (j - k + r + 1) + 1] * ((t - T[i]) / (T[i + k - r] - T[i])) + P[i - (j - k + r + 1)] * ((T[i + k - r] - t) / (T[i + k - r] - T[i])); //* (p[i + 1][r - 1]); next.push_back(tmp); &#125; P = next; next.clear(); &#125; ans.push_back(P[0]); P.clear(); &#125; &#125; draw_Bline(ans); return;&#125;","categories":[{"name":"opengl图形学","slug":"opengl图形学","permalink":"https://coincidenceboy.github.io/categories/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"B样条","slug":"B样条","permalink":"https://coincidenceboy.github.io/tags/B%E6%A0%B7%E6%9D%A1/"}]},{"title":"Bezier曲线","slug":"Bezier曲线","date":"2020-12-23T09:31:52.000Z","updated":"2020-12-23T10:13:37.856Z","comments":true,"path":"2020/12/23/Bezier曲线/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/23/Bezier%E6%9B%B2%E7%BA%BF/","excerpt":"","text":"Bezier曲线原理讲解 代码实现main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&quot;struct.h&quot;using namespace std;int site_left = 550;int site_top = 300;int WinW = 500;int WinH = 450;vector&lt;point&gt; input;int nowid;//用于鼠标移动bool check(int i, int tx, int ty)&#123; int num = 15; int x = input[i].x, y = input[i].y; if (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num) &#123; return true; &#125; return false;&#125;void display()&#123; glClearColor(200.0 / 255, 200.0 / 255, 169.0 / 255, 0.0); //设定清理颜色 glClear(GL_COLOR_BUFFER_BIT); //清理缓冲区 glFlush();&#125;void drawOnePoint(int x, int y)&#123; glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glPointSize(4); glBegin(GL_POINTS); glVertex2d(x, y); glEnd(); glFlush();&#125;void drawLine(int x1, int y1,int x2,int y2)&#123; glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glEnable(GL_LINE_SMOOTH); glLineWidth(1); glBegin(GL_LINES); glVertex2i(x1, y1); glVertex2i(x2, y2); glEnd(); glFlush();&#125;void redraw()&#123; //缓冲区重绘 glClearColor(200.0 / 255, 200.0 / 255, 169.0 / 255, 0.0); //设定清理颜色 glClear(GL_COLOR_BUFFER_BIT); //控制点重绘 glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glPointSize(4); glBegin(GL_POINTS); for (int i = 0; i &lt;= input.size() - 1; i++) glVertex2d(input[i].x, input[i].y); glEnd(); //特征多边形重绘 glLineWidth(1); glBegin(GL_LINES); for (int i = 1; i &lt;= input.size() - 1; i++) drawLine(input[i - 1].x, input[i - 1].y, input[i].x, input[i].y); glEnd(); glFlush();&#125;extern void Bezier();void mouseClick(int button, int state, int nowx, int nowy) //x,y均是以窗口左上角为（0,0）的像素表示&#123; int x, y; x = nowx, y = WinH - nowy; int id = -1; for (int i = 0; i &lt; input.size(); i++) &#123; if (check(i, x, y)) &#123; id = i; break; &#125; &#125; //insert if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) &#123; if (id == -1) &#123; drawOnePoint(x, y); input.push_back(point(x, y)); nowid = input.size() - 1; if (nowid &gt;= 1) &#123; drawLine(input[nowid - 1].x, input[nowid - 1].y, input[nowid].x, input[nowid].y); &#125; &#125; else nowid = id; &#125; //画出Bezier else if (button == GLUT_MIDDLE_BUTTON &amp;&amp; state == GLUT_DOWN) &#123; redraw(); Bezier(); &#125; // delete else if (button == GLUT_RIGHT_BUTTON &amp;&amp; state == GLUT_DOWN) &#123; if (id != -1) &#123; nowid = id; input.erase(input.begin() + nowid); redraw(); Bezier(); &#125; &#125;&#125;void mouseMotion(int nowx, int nowy)&#123; int x = nowx, y = WinH - nowy; input[nowid].x = x, input[nowid].y = y; redraw(); Bezier();&#125;int main()&#123; glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); //显示窗口的缓存和颜色模型 glutInitWindowPosition(site_left, site_top); glutInitWindowSize(WinW, WinH); glutCreateWindow(&quot;交互贝塞尔曲线-Bezier&quot;); //创建带标题的窗口 gluOrtho2D(0, WinW, 0, WinH); // 区域大小定义 窗口的左下角是（0，0） cout &lt;&lt; &quot;鼠标左键点击 -----&gt; 绘制特征多边形&quot; &lt;&lt; endl; cout &lt;&lt; &quot; 鼠标中键 -----&gt; 画出Bezier曲线&quot; &lt;&lt; endl; cout &lt;&lt; &quot; 鼠标右键 -----&gt; 删除指向特征点&quot; &lt;&lt; endl; cout &lt;&lt; &quot;鼠标左键拖拽 -----&gt; 重绘Bezier曲线&quot; &lt;&lt; endl; glutDisplayFunc(&amp;display); //事件1：显示函数 glutMouseFunc(mouseClick); //事件2：鼠标点击 glutMotionFunc(mouseMotion); //事件3：鼠标移动 glutMainLoop(); //让事件保持循环 return 0;&#125; struct.h123456789101112#pragma once#include&lt;gl/glut.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;struct point&#123; double x, y; point() &#123; x = -1, y = -1; &#125; point(double x1, double y1) &#123; x = x1, y = y1; &#125;&#125;; Bezier.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&quot;struct.h&quot;const int maxn = 105;point p[maxn][maxn];extern vector&lt;point&gt;input;point De_Casteljau(double t)&#123;//递推公式 p[i][0] = input[i](控制点) k=0// p[i][k] = (1-t)*p[i][k-1] + t*p[i+1][k-1] k&gt;0 int n = input.size() - 1; //input n+1个控制点 for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; if(j==0) p[i][0].x = input[i].x, p[i][0].y = input[i].y; //初始化p[i][0] else p[i][j].x = 0, p[i][j].y = 0; &#125; &#125; //n次Bezier 即： p[0][n] 关于t的表达式 多次传入参数t即可绘制Bezier曲线 for (int k = 1; k &lt;= n; k++) &#123; for (int i = 0; i &lt;= n; i++) &#123; p[i][k].x = (1 - t) * p[i][k - 1].x + t * p[i + 1][k - 1].x; p[i][k].y = (1 - t) * p[i][k - 1].y + t * p[i + 1][k - 1].y; &#125; &#125; return p[0][n];&#125;void Bezier()&#123; glColor3f(252.0 / 255, 157.0 / 255, 154.0 / 255); glPointSize(2); glBegin(GL_POINTS); for (double t = 0; t &lt;= 1.0; t += 0.001) &#123; double x = De_Casteljau(t).x; double y = De_Casteljau(t).y; glVertex2d(x, y); &#125; glEnd(); glFlush();&#125;","categories":[{"name":"opengl图形学","slug":"opengl图形学","permalink":"https://coincidenceboy.github.io/categories/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Bezier曲线","slug":"Bezier曲线","permalink":"https://coincidenceboy.github.io/tags/Bezier%E6%9B%B2%E7%BA%BF/"}]},{"title":"扫描线填充多边形算法","slug":"扫描线填充多边形算法","date":"2020-12-23T09:31:22.000Z","updated":"2020-12-23T10:12:11.661Z","comments":true,"path":"2020/12/23/扫描线填充多边形算法/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/23/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%A1%AB%E5%85%85%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%AE%97%E6%B3%95/","excerpt":"","text":"扫描线填充多边形算法原理讲解 代码实现main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&quot;struct.h&quot;int site_left = 550, site_top = 300;int WinW = 500, WinH = 450;//画 多边形边界vector&lt;point&gt;input; //鼠标键入的多边形各点int nowid;bool already = false;//封闭之后屏蔽鼠标操作//ScanLine要用到NET(新边表)AET(活动边表)vector&lt;node&gt;NET[1005];vector&lt;node&gt;AET;vector&lt;line&gt;l; //多边形各边界void display()&#123; glClearColor(200.0 / 255, 200.0 / 255, 169.0 / 255, 0.0); //设定清理颜色 glClear(GL_COLOR_BUFFER_BIT); //清理缓冲区 glFlush();&#125;void drawLine(int x0, int y0, int x1, int y1)//画多边形边界&#123; glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255);//边界线段颜色 glEnable(GL_LINE_SMOOTH); glLineWidth(3); glBegin(GL_LINES); glVertex2d(x0, y0); glVertex2d(x1, y1); glEnd(); glFlush();&#125;bool check(int i, int tx, int ty)&#123; int num = 15; int x = input[i].x, y = input[i].y; if (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num) &#123; return true; &#125; return false;&#125;extern void ScanLine();int minyy=0, maxyy=WinH;//记录特征多边形的y_min和y_maxvoid mouseClick(int button, int state, int nowx, int nowy)&#123; int x, y; x = nowx, y = WinH - nowy; int id = -1;//是否封闭，即回到起始点 for (int i = 0; i &lt; input.size(); i++) &#123; if (check(i, x, y)) &#123; id = i; break; &#125; &#125; if (button == GLUT_LEFT &amp;&amp; state == GLUT_DOWN) &#123; if (id == -1 &amp;&amp; !already) &#123; input.push_back(point(x, y)); minyy = min(minyy, y); maxyy = max(maxyy, y); nowid = input.size() - 1; if (nowid &gt;= 1) &#123; drawLine(input[nowid - 1].x, input[nowid - 1].y, input[nowid].x, input[nowid].y); l.push_back(line(input[nowid - 1].x, input[nowid - 1].y, input[nowid].x, input[nowid].y)); &#125; &#125; else if (id != -1 &amp;&amp; !already) &#123; already = true; nowid = input.size() - 1; drawLine(input[nowid].x, input[nowid].y, input[id].x, input[id].y); l.push_back(line(input[id].x, input[id].y, input[nowid].x, input[nowid].y)); ScanLine(); &#125; &#125;&#125;int main()&#123; glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); //显示窗口的缓存和颜色模型 glutInitWindowPosition(site_left, site_top); glutInitWindowSize(WinW, WinH); glutCreateWindow(&quot;扫描线填充算法&quot;); //创建带标题的窗口 gluOrtho2D(0, WinW, 0, WinH); // 区域大小定义 窗口的左下角是（0，0） glutDisplayFunc(&amp;display); //事件1：显示函数 glutMouseFunc(mouseClick); //事件2：鼠标点击 //glutMotionFunc(mouseMotion); //事件3：鼠标移动 glutMainLoop(); //让事件保持循环 return 0;&#125; struct.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#pragma once#include&lt;gl/glut.h&gt;#include&lt;iostream&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct point&#123; int x, y; point() &#123; x = -1, y = -1; &#125; point(int x1, int y1) &#123; x = x1, y = y1; &#125;&#125;;struct node&#123;//AET和NET所用的节点 double xi; double dx; int ymax; node(double _xi, double _dx, int _ymax) :xi(_xi), dx(_dx), ymax(_ymax) &#123;&#125; bool operator &lt;(const node x) &#123; return xi &lt; x.xi; &#125;&#125;;struct line&#123; point a, b; bool is_flat = false; //多边形边界是否是直线 line() &#123;&#125;; line(point x, point y) &#123; a = x, b = y; if (a.y != b.y) is_flat = false; else is_flat = true; &#125; line(int x1, int y1, int x2, int y2) &#123; a.x = x1, a.y = y1, b.x = x2, b.y = y2; if (a.y != b.y) is_flat = false; else is_flat = true; &#125; int miny() &#123; if (a.y &lt; b.y) return a.y; return b.y; &#125; int maxy() &#123; if (a.y &gt; b.y) return a.y; return b.y; &#125; int get_xi(int _y) &#123; if (_y == a.y) return a.x; return b.x; &#125; double dx() &#123; if (is_flat) return 0; double k = double((b.y - a.y) * 1.0 / (b.x - a.x)); return 1.0 / k; &#125;&#125;; 扫描线填充算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&quot;struct.h&quot;void draw(double x1, double x2, double y)&#123; glColor3f(252.0 / 255, 157.0 / 255, 154.0 / 255);//扫描填充线段颜色 glEnable(GL_LINE_SMOOTH); glLineWidth(1.0); //扫描线 glBegin(GL_LINES); glVertex2d(x1, y); glVertex2d(x2, y); glEnd(); glFlush();&#125;extern vector&lt;node&gt;NET[455];extern vector&lt;node&gt;AET;extern vector&lt;line&gt;l;extern int WinH;extern int minyy, maxyy;void ScanLine()&#123; //初始化NET for (int nowy = minyy; nowy &lt;= maxyy; nowy++) &#123; for (int i = 0; i &lt; l.size(); i++) &#123; if (l[i].miny() == nowy) &#123; if (l[i].is_flat) continue;//如果特征多边形的边与扫描线重合，即边界是平的,则跳过该边界 double xi = l[i].get_xi(nowy); double dx = l[i].dx(); int ymax = l[i].maxy(); NET[nowy].push_back(node(xi, dx, ymax)); &#125; &#125; &#125; for (int nowy = minyy; nowy &lt;= maxyy; nowy++) &#123; for (int i = 0; i &lt; NET[nowy].size(); i++) &#123; AET.push_back(NET[nowy][i]); &#125; sort(AET.begin(), AET.end()); //根据活性表 画 y=nowy 的填充线 for (int i = 0; i &lt; AET.size(); i += 2) &#123; double x1 = AET[i].xi, x2 = AET[i + 1].xi; draw(x1, x2, nowy); &#125; //为下一条扫描线更新AET for (int i = 0; i &lt; AET.size(); i++) &#123; //检查是否需要删除node if (AET[i].ymax == nowy + 1) &#123; AET.erase(AET.begin() + i); i--; &#125; //该节点不需要删除的话 则更新node(x,dx,ymax)----&gt;node(x+dx,dx,ymax) else if (AET[i].ymax &gt; nowy) &#123; AET[i].xi += AET[i].dx; &#125; &#125; &#125;&#125;","categories":[{"name":"opengl图形学","slug":"opengl图形学","permalink":"https://coincidenceboy.github.io/categories/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"扫描线填充多边形算法","slug":"扫描线填充多边形算法","permalink":"https://coincidenceboy.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%A1%AB%E5%85%85%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%AE%97%E6%B3%95/"}]},{"title":"Southerland-Hodgeman 多边形裁剪","slug":"Southerland-Hodgeman-多边形裁剪","date":"2020-12-23T09:30:54.000Z","updated":"2020-12-23T10:09:47.562Z","comments":true,"path":"2020/12/23/Southerland-Hodgeman-多边形裁剪/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/23/Southerland-Hodgeman-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A3%81%E5%89%AA/","excerpt":"","text":"Southerland-Hodgeman多边形裁剪原理讲解 代码实现main.cpp (vis改进,可以裁剪所有凹多边形)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&quot;struct.h&quot;int site_left = 550;int site_top = 300;const int WinW = 500;const int WinH = 450;int vis[WinW][WinH] = &#123; 0 &#125;;void display()&#123; glClearColor(200.0 / 255, 200.0 / 255, 169.0 / 255, 0.0); //设定清理颜色 glClear(GL_COLOR_BUFFER_BIT); //清理缓冲区 glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glRectf(100, 80, 400, 360); //左下 右上（横、纵左边） glFlush();&#125;extern vector&lt;point&gt;now;extern vector&lt;point&gt;out;extern vector&lt;line&gt;ans;extern void Polygon_clipping();bool already = false;//特征多边形绘制结束之后，屏蔽鼠标操作int x, y;int cnt, nowid;bool check(int i, int tx, int ty)&#123; int num = 15; int x = now[i].x, y = now[i].y; if (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num) &#123; return true; &#125; return false;&#125;void drawLine(double x0, double y0, double x1, double y1)&#123; glColor3f(252.0 / 255, 157.0 / 255, 154.0 / 255); glLineWidth(2); glEnable(GL_LINE_SMOOTH); glBegin(GL_LINES); glVertex2d(x0, y0); glVertex2d(x1, y1); glEnd(); glFlush();&#125;void mouseClick(int button, int state, int nowx, int nowy) //x,y均是以窗口左上角为（0,0）的像素表示&#123; x = nowx, y = WinH - nowy; int id = -1; //是否封闭，即回到起始点 for (int i = 0; i &lt; int(now.size()); i++) &#123; if (check(i, x, y)) &#123; id = i; break; &#125; &#125; //already 用来 特征多边形绘制结束之后，屏蔽鼠标操作 if (button == GLUT_LEFT &amp;&amp; state == GLUT_DOWN) &#123; if (id == -1 &amp;&amp; !already) &#123; cnt++; now.push_back(point(x, y)); nowid = now.size() - 1; if (nowid &gt;= 1) drawLine(now[nowid - 1].x, now[nowid - 1].y, now[nowid].x, now[nowid].y); &#125; else if (id != -1 &amp;&amp; !already) &#123; already = true; nowid = now.size() - 1; drawLine(now[nowid].x, now[nowid].y, now[id].x, now[id].y); Polygon_clipping(); &#125; &#125;&#125;int main()&#123; glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); //显示窗口的缓存和颜色模型 glutInitWindowPosition(site_left, site_top); glutInitWindowSize(WinW, WinH); glutCreateWindow(&quot;Southerland多边形裁剪算法&quot;); //创建带标题的窗口 gluOrtho2D(0, WinW, 0, WinH); // 区域大小定义 窗口的左下角是（0，0） glutDisplayFunc(&amp;display); //事件1：显示函数 glutMouseFunc(mouseClick); //事件2：鼠标点击 //glutMotionFunc(mouseMotion); //事件3：鼠标移动 glutMainLoop(); //让事件保持循环 return 0;&#125; struct.h123456789101112131415161718192021#pragma once#include&lt;gl/glut.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;struct point&#123; int x, y; point() &#123; x = -1, y = -1; &#125; point(int x1, int y1) &#123; x = x1, y = y1; &#125;&#125;;struct line&#123; point a, b; string name; line() &#123;&#125;; line(point x, point y) &#123; a = x, b = y; &#125; line(int x1, int y1, int x2, int y2,string s) &#123; a.x = x1, a.y = y1, b.x = x2, b.y = y2,name=s; &#125;&#125;; Southerland.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&quot;struct.h&quot;vector&lt;point&gt;now;vector&lt;point&gt;out;vector&lt;line&gt;ans;line left_line(100, 80, 100, 360,&quot;left&quot;);line right_line(400, 80, 400, 360,&quot;right&quot;);line top_line(100, 360, 400, 360,&quot;top&quot;);line bottom_line(100, 80, 400, 80,&quot;bottom&quot;);extern const int WinW = 500;extern const int WinH = 450;extern int vis[WinW][WinH];//Bresenham画线算法void drawpixel(int x, int y)&#123; //glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); vis[x][y]++; glColor3f(249.0 / 255, 205.0 / 255, 173.0 / 255); glPointSize(3); glEnable(GL_POINT_SMOOTH); glBegin(GL_POINTS); glVertex2i(x, y); glEnd(); glFlush();&#125;void Bresenham(int x0, int y0, int x1, int y1)&#123; if (x0 &gt; x1 &amp;&amp; y0 &gt; y1) swap(x0, x1), swap(y0, y1); if (x1 &gt; x0 &amp;&amp; y1 &lt; y0) swap(x0, x1), swap(y0, y1); int nowx, nowy, dx, dy, e; double k; if (x1 != x0) k = double((y1 - y0) * 1.0 / (x1 - x0)); else k = -1.0; if (k == -1.0) &#123; for (int i = min(y0, y1); i &lt;= max(y0, y1); i++) drawpixel(x0, i); &#125; else if (k == 0) &#123; for (int i = min(x0, x1); i &lt;= max(x0, x1); i++) drawpixel(i, y0); &#125; else if (k &gt; 0 &amp;&amp; k &lt;= 1) &#123; dx = x1 - x0, dy = y1 - y0, e = -dx; nowx = x0, nowy = y0; for (int i = 0; i &lt;= dx; i++) &#123; drawpixel(nowx, nowy); nowx++, e += 2 * dy; if (e &gt;= 0) nowy++, e -= 2 * dx; &#125; &#125; else if (k &gt; 1) &#123; swap(x0, y0), swap(x1, y1);//swap dx = x1 - x0, dy = y1 - y0, e = -dx; nowx = x0, nowy = y0; for (int i = 0; i &lt;= dx; i++) &#123; drawpixel(nowy, nowx);//(nowy,nowx) nowx++, e += 2 * dy; if (e &gt;= 0) nowy++, e -= 2 * dx; &#125; &#125; else if (k &lt; 0 &amp;&amp; k &gt;= -1) &#123; dx = x1 - x0, dy = y1 - y0, e = -dx; nowx = x0, nowy = y0; for (int i = 0; i &lt;= -dx; i++) //-dx &#123; drawpixel(nowx, nowy); nowx--, e += 2 * dy; //nowx-- if (e &gt;= 0) nowy++, e -= 2 * (-dx); &#125; &#125; else if (k &lt; -1) &#123; swap(x0, y0), swap(x1, y1);//swap dx = x1 - x0, dy = y1 - y0, e = -dx; nowx = x0, nowy = y0; for (int i = 0; i &lt;= dx; i++) &#123; drawpixel(nowy, nowx); //(nowy,nowx) nowx++, e -= 2 * dy; //-= if (e &gt;= 0) nowy--, e -= 2 * dx;//nowy-- &#125; &#125;&#125;void redraw(int x1, int y1, int x2, int y2)&#123; /*glColor3f(249.0 / 255, 205.0 / 255, 173.0 / 255);//区域线段颜色 glLineWidth(3); glEnable(GL_LINE_SMOOTH); glBegin(GL_LINES); glVertex2d(x1, y1); glVertex2d(x2, y2); glEnd();*/ Bresenham(x1, y1, x2, y2); glFlush();&#125;point focus(point S, point P, line wall) &#123;//求s--p与边界的交点 point p; if (wall.a.x == wall.b.x) &#123; p.x = wall.a.x; p.y = S.y + (wall.a.x - S.x) * (P.y - S.y) / (P.x - S.x); &#125; else &#123; p.y = wall.a.y; p.x = S.x + (wall.a.y - S.y) * (P.x - S.x) / (P.y - S.y); &#125; return p;&#125;bool Inside(point x, line wall)&#123; if (wall.name == &quot;left&quot; &amp;&amp; x.x &gt; wall.a.x) return true; if (wall.name == &quot;right&quot; &amp;&amp; x.x &lt; wall.b.x) return true; if (wall.name == &quot;top&quot; &amp;&amp; x.y &lt; wall.a.y) return true; if (wall.name == &quot;bottom&quot; &amp;&amp; x.y &gt; wall.a.y) return true; return false;&#125;void Sutherland_Hodgman(line wall)&#123; out.clear(); point S, P; S = now[now.size() - 1]; for (int i = 0; i &lt; now.size(); i++) &#123; P = now[i]; if (Inside(S, wall)) &#123; if (Inside(P, wall)) &#123; //①S 内 P 内 out.push_back(P); &#125; else &#123;//②S 内 P外 out.push_back(focus(S, P, wall)); // SP &#125; &#125; else if (Inside(P, wall)) &#123; //③ P 内 S 外 out.push_back(focus(S, P, wall)); out.push_back(P); &#125; //④ S 外 P 外 不输出 S = P; &#125;&#125;void Polygon_clipping()&#123; Sutherland_Hodgman(left_line); now = out; Sutherland_Hodgman(right_line); now = out; Sutherland_Hodgman(top_line); now = out; Sutherland_Hodgman(bottom_line); //用Bresenham算法画线 并且记录vis【】【】数组 for (int i = 0; i &lt; out.size() - 1; i++) &#123; redraw(out[i].x, out[i].y, out[i + 1].x, out[i + 1].y); &#125; if (out.size() &gt; 2) redraw(out[0].x, out[0].y, out[out.size() - 1].x, out[out.size() - 1].y); //通过vis数组 用边界颜色 覆盖多余的边 for(int i=0;i&lt;WinW;i++) for (int j = 0; j &lt; WinH; j++) &#123; if (vis[i][j] % 2 == 0 &amp;&amp; vis[i][j] != 0) &#123; glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glPointSize(3); glEnable(GL_POINT_SMOOTH); glBegin(GL_POINTS); glVertex2i(i, j); glEnd(); glFlush(); &#125; &#125; //描 端点 for (int i = 0; i &lt; out.size(); i++) &#123; glColor3f(249.0 / 255, 205.0 / 255, 173.0 / 255); glPointSize(4); glEnable(GL_POINT_SMOOTH); glBegin(GL_POINTS); glVertex2i(out[i].x, out[i].y); glEnd(); glFlush(); &#125;&#125;","categories":[{"name":"opengl图形学","slug":"opengl图形学","permalink":"https://coincidenceboy.github.io/categories/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Southerland-Hodgeman 多边形裁剪","slug":"Southerland-Hodgeman-多边形裁剪","permalink":"https://coincidenceboy.github.io/tags/Southerland-Hodgeman-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A3%81%E5%89%AA/"}]},{"title":"liang-barsky裁剪算法","slug":"liang-barsky裁剪算法","date":"2020-12-23T09:30:32.000Z","updated":"2020-12-23T10:08:23.750Z","comments":true,"path":"2020/12/23/liang-barsky裁剪算法/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/23/liang-barsky%E8%A3%81%E5%89%AA%E7%AE%97%E6%B3%95/","excerpt":"","text":"liang-barsky裁剪算法原理讲解 代码实现main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;gl/glut.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&quot;liang-barsky.h&quot;using namespace std;int site_left = 550;int site_top = 300;int WinW = 500;int WinH = 450;struct point&#123; int x, y; point() &#123; x = -1, y = -1; &#125; point(int x1, int y1) &#123; x = x1, y = y1; &#125;&#125;;void display()&#123; glClearColor(200.0 / 255, 200.0 / 255, 169.0 / 255, 0.0); //设定清理颜色 glClear(GL_COLOR_BUFFER_BIT); //清理缓冲区 //绘制矩形裁剪框 glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glRectf(100, 80, 400, 360); //相对于窗口正中心 四变量依次：左下 右上（横、纵左边） glFlush();&#125;vector&lt;point&gt;v;int x, y;int cnt, nowid;bool check(int i, int tx, int ty)&#123; int num = 15; int x = v[i].x, y = v[i].y; if (tx &gt;= x - num &amp;&amp; tx &lt;= x + num &amp;&amp; ty &gt;= y - num &amp;&amp; ty &lt;= y + num) &#123; return true; &#125; return false;&#125;void drawline(int x)&#123; glColor3f(252.0 / 255, 157.0 / 255, 154.0 / 255); glLineWidth(2); glEnable(GL_LINE_SMOOTH); glBegin(GL_LINES); glVertex2i(v[x - 1].x, v[x - 1].y); glVertex2i(v[x].x, v[x].y); glEnd(); glFlush();&#125;void mouseClick(int button, int state, int nowx, int nowy) //x,y均是以窗口左上角为（0,0）的像素表示&#123; x = nowx, y = WinH - nowy; int id = -1; for (int i = 0; i &lt; v.size(); i++) &#123; if (check(i, x, y)) &#123; id = i; break; &#125; &#125; if (button == GLUT_LEFT &amp;&amp; state == GLUT_DOWN) &#123; if (id == -1) &#123; cnt++; v.push_back(point(x, y)); nowid = v.size() - 1; if (cnt % 2 ==0) &#123; drawline(nowid); liang_barsky(v[nowid - 1].x, v[nowid - 1].y, v[nowid].x, v[nowid].y, 360, 80, 100, 400); &#125; &#125; else &#123; nowid = id; &#125; &#125;&#125;void mouseMotion(int nowx, int nowy)&#123; if (cnt &lt;= 1) return; v[nowid].x = nowx, v[nowid].y = 450.0 - nowy;//找到重绘时产生变化的那条线段 //全部重新绘制 display(); for (int i = 1; i &lt;= v.size() - 1; i += 2) drawline(i), liang_barsky(v[i - 1].x, v[i - 1].y, v[i].x, v[i].y, 360, 80, 100, 400);&#125;int main()&#123; glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); //显示窗口的缓存和颜色模型 glutInitWindowPosition(site_left, site_top); glutInitWindowSize(WinW, WinH); glutCreateWindow(&quot;liang-barsky直线裁剪算法&quot;); //创建带标题的窗口 gluOrtho2D(0, WinW, 0, WinH); // 区域大小定义 窗口的左下角是（0，0） glutDisplayFunc(&amp;display); //事件1：显示函数 glutMouseFunc(mouseClick); //事件2：鼠标点击 glutMotionFunc(mouseMotion); //事件3：鼠标移动 glutMainLoop(); //让事件保持循环 return 0;&#125; liang-barsky.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#pragma once#include&lt;GL/glut.h&gt;using namespace std;void draw(double x1, double y1, double x2, double y2)&#123; glColor3f(249.0 / 255, 205.0 / 255, 173.0 / 255);//区域线段颜色 glLineWidth(2); glEnable(GL_LINE_SMOOTH); glBegin(GL_LINES); glVertex2i(x1, y1); glVertex2i(x2, y2); glEnd(); glFlush();&#125;void liang_barsky(double x1, double y1, double x2, double y2, double YT, double YB, double XL, double XR)&#123;//①参数方程的思想//②把直线段看成一条有方向的线段。（假定方向是从x_min ---&gt; x_max）。//裁剪即求 起点和终点的参数μ值 μ1 = max(0,μ入边1,μ入边2) μ2 = min(1,μ出边1,μ出边2)//问题转换为---只需要判断//--a.那两个边是 入边 ，哪两个边是 出边。//--b.直线和窗口边界的 四个交点 的参数值如何求？ double u1 = 0, u2 = 1, dx = x2 - x1, dy = y2 - y1; double p[5], q[5]; //裁剪问题转换为 判断 点 是否在窗口内的问题。 //X_left ≤ x1+μ*dx ≤ X_right //Y_btom ≤ y1+μ*dy ≤ Y_top p[1] = -dx; q[1] = x1 - XL; p[2] = dx; q[2] = XR - x1; p[3] = -dy; q[3] = y1 - YB; p[4] = dy; q[4] = YT - y1; //有μ*p[k] ≤ q[k] 不等式取 = 对应与边界的四个交点参数 //p[k] &lt; 0 对应两条入边 //p[k] &lt; 0 对应两条出边 for (int i = 1; i &lt;= 4; i++) &#123; if (p[i] &lt; 0) &#123; u1 = max(u1, q[i] / p[i]); &#125; else if (p[i] &gt; 0) &#123; u2 = min(u2, q[i] / p[i]); &#125; else if (p[i] == 0 &amp;&amp; q[i] &lt; 0) return; if (u1 &gt; u2) return; &#125; draw(x1 + u1 * dx, y1 + u1 * dy, x1 + u2 * dx, y1 + u2 * dy);&#125;","categories":[{"name":"opengl图形学","slug":"opengl图形学","permalink":"https://coincidenceboy.github.io/categories/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"liang-barsky裁剪","slug":"liang-barsky裁剪","permalink":"https://coincidenceboy.github.io/tags/liang-barsky%E8%A3%81%E5%89%AA/"}]},{"title":"Bresenham画线算法","slug":"Bresenham画线算法","date":"2020-12-23T09:30:08.000Z","updated":"2020-12-23T10:06:00.197Z","comments":true,"path":"2020/12/23/Bresenham画线算法/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/23/Bresenham%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/","excerpt":"","text":"Bresenham画线算法原理讲解 代码实现Bresenham.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;gl/glut.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int site_left = 550;int site_top = 300;int WinW = 500;int WinH = 450;struct point&#123; int x, y;&#125;v[2];int tot = 0;void display()&#123; glClearColor(249.0 / 255, 205.0 / 255, 173.0 / 255, 0.0); //设定清理颜色 glClear(GL_COLOR_BUFFER_BIT); //清理缓冲区 glFlush();&#125;void drawpixel(int x, int y)&#123; glColor3f(131.0 / 255, 175.0 / 255, 155.0 / 255); glBegin(GL_POINTS); glVertex2i(x, y); glEnd(); glFlush();&#125;void redraw()&#123; glClearColor(249.0 / 255, 205.0 / 255, 173.0 / 255, 0.0); //设定清理颜色 glClear(GL_COLOR_BUFFER_BIT); //清理缓冲区 glColor3f(249.0 / 255, 205.0 / 255, 173.0 / 255); glRectf(0, 0, 1, 1); glFlush();&#125;void Bresenham(int x0, int y0, int x1, int y1)&#123;//只需要检查一个误差项的符号，就可以确定每一列所选的像素。 if (x0 &gt; x1 &amp;&amp; y0 &gt; y1) swap(x0, x1), swap(y0, y1); if (x1 &gt; x0 &amp;&amp; y1 &lt; y0) swap(x0, x1), swap(y0, y1); int nowx, nowy, dx, dy, e; double k; if (x1 != x0) k = double((y1 - y0) * 1.0 / (x1 - x0)); else k = -1.0; if (k == -1.0) &#123; for (int i = min(y0,y1); i &lt;= max(y0,y1); i++) drawpixel(x0, i); &#125; else if (k == 0) &#123; for (int i = min(x0, x1); i &lt;= max(x0, x1); i++) drawpixel(i, y0); &#125; else if (k &gt; 0 &amp;&amp; k &lt;= 1) &#123; dx = x1 - x0, dy = y1 - y0, e = -dx; nowx = x0, nowy = y0; for (int i = 0; i &lt;= dx; i++) &#123; drawpixel(nowx, nowy); nowx++, e += 2 * dy; if (e &gt;= 0) nowy++, e -= 2 * dx; &#125; &#125; else if (k &gt; 1) &#123; swap(x0, y0), swap(x1, y1);//swap dx = x1 - x0, dy = y1 - y0, e = -dx; nowx = x0, nowy = y0; for (int i = 0; i &lt;= dx; i++) &#123; drawpixel(nowy, nowx);//(nowy,nowx) nowx++, e += 2 * dy; if (e &gt;= 0) nowy++, e -= 2 * dx; &#125; &#125; else if (k &lt; 0 &amp;&amp; k &gt;= -1) &#123; dx = x1 - x0, dy = y1 - y0, e = -dx; nowx = x0, nowy = y0; for (int i = 0; i &lt;= -dx; i++) //-dx &#123; drawpixel(nowx, nowy); nowx--, e += 2 * dy; //nowx-- if (e &gt;= 0) nowy++, e -= 2 * (-dx); &#125; &#125; else if (k &lt; -1) &#123; swap(x0, y0), swap(x1, y1);//swap dx = x1 - x0, dy = y1 - y0, e = -dx; nowx = x0, nowy = y0; for (int i = 0; i &lt;= dx; i++) &#123; drawpixel(nowy, nowx); //(nowy,nowx) nowx++, e -= 2 * dy; //-= if (e &gt;= 0) nowy--, e -= 2 * dx;//nowy-- &#125; &#125; &#125;void mouseClick(int button, int state, int x, int y) //x,y均是以窗口左上角为（0,0）的像素表示&#123; int nowx = x, nowy = WinH - y; if (button == GLUT_LEFT &amp;&amp; state == GLUT_DOWN) &#123; //cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; if (tot &lt;= 1) &#123; v[tot].x = nowx; v[tot++].y = nowy; if (tot == 2) Bresenham(v[0].x, v[0].y, v[1].x, v[1].y); &#125; &#125; if (button == GLUT_MIDDLE_BUTTON &amp;&amp; state == GLUT_DOWN) &#123; tot = 0; redraw(); &#125;&#125;int main()&#123; glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); //显示窗口的缓存和颜色模型 glutInitWindowPosition(site_left, site_top); glutInitWindowSize(WinW, WinH); glutCreateWindow(&quot;Bresenham算法画直线&quot;); //创建带标题的窗口 gluOrtho2D(0, WinW, 0, WinH); // 区域大小定义 窗口的左下角是（0，0） glutDisplayFunc(&amp;display); //事件1：显示函数 glutMouseFunc(mouseClick); //事件2：鼠标点击 //glutMotionFunc(mouseMotion); //事件3：鼠标移动 glutMainLoop(); //让事件保持循环 return 0;&#125;","categories":[{"name":"opengl图形学","slug":"opengl图形学","permalink":"https://coincidenceboy.github.io/categories/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Bresenham画线算法","slug":"Bresenham画线算法","permalink":"https://coincidenceboy.github.io/tags/Bresenham%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"}]},{"title":"高精加法乘法","slug":"高精加法乘法","date":"2020-12-23T09:02:25.000Z","updated":"2020-12-28T06:49:30.621Z","comments":true,"path":"2020/12/23/高精加法乘法/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/23/%E9%AB%98%E7%B2%BE%E5%8A%A0%E6%B3%95%E4%B9%98%E6%B3%95/","excerpt":"","text":"高精度加法 过程 见 高精乘法 图例. 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000;int a[N], b[N], ans[N];//下标均从1开始int main()&#123; //读入并且将两个数a,b放入a[1-len_a],b[1-len_b] string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; int len_a = s1.size(), len_b = s2.size(); for (int i = 1; i &lt;= len_a; i++) a[i] = s1[len_a - i] - &#x27;0&#x27;; for (int i = 1; i &lt;= len_b; i++) b[i] = s2[len_b - i] - &#x27;0&#x27;; //模拟手算 for (int i = 1; i &lt;= max(len_a, len_b); i++) ans[i] = a[i] + b[i]; int len = max(len_a, len_b) + 1; //进位 for (int i = 1; i &lt;= len; i++) &#123; if (ans[i] &gt; 9) ans[i + 1] += ans[i] / 10, ans[i] %= 10; &#125; //去除前导0 while (ans[len] == 0 &amp;&amp; len &gt; 1) len--; for (int i = len; i &gt;= 1; i--) cout &lt;&lt; ans[i]; return 0;&#125; 高精度乘法 模拟手算乘法 先将读入的两个字符串”2934”,”3489”,分别倒序存入数组a[]和b[]中. ( a[1,4]={4,3,9,2} b[1.4]={9,8,4,3} ) 手算过程 : 枚举 b[i] 去乘 a[1~4] 并且每次都记录进位 (进位可以最后综合到一起,如下图右侧) 最后处理一下 进位和前导0即可. 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5000;int a[N], b[N], ans[N];//下标均从1开始int main()&#123; //读入并且将两个数a,b放入a[1-len_a],b[1-len_b] string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; int len_a = s1.size(), len_b = s2.size(); for (int i = 1; i &lt;= len_a; i++) a[i] = s1[len_a - i] - &#x27;0&#x27;; for (int i = 1; i &lt;= len_b; i++) b[i] = s2[len_b - i] - &#x27;0&#x27;; //模拟手算 for(int i=1;i&lt;=len_b;i++) for (int j = 1; j &lt;= len_a; j++) &#123; ans[i + j - 1] += b[i] * a[j]; &#125; int len = len_a + len_b; //进位 for (int i = 1; i &lt;= len; i++) &#123; if (ans[i] &gt; 9) ans[i + 1] += ans[i] / 10, ans[i] %= 10; &#125; //去除前导0 while (ans[len] == 0 &amp;&amp; len &gt; 1) len--; for (int i = len; i &gt;= 1; i--) cout &lt;&lt; ans[i]; return 0;&#125; 阶乘之和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int N = 100000;int a[N], b[N], ans[N];//下标均从1开始string str[1005];const int dx[4] = &#123; 1000,100,10,1 &#125;;string multi(int s1, string s2)&#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); memset(ans, 0, sizeof(ans)); int len_a = 0, len_b = s2.size(); int tmp = s1; b[1] = -1; for (int i = 0; i &lt; 4; i++) &#123; if (tmp &lt; dx[i]) &#123; if (b[1] != -1) b[++len_a] = 0; continue; &#125; if (tmp &gt;= dx[i]) &#123; b[++len_a] = tmp / dx[i]; tmp = tmp % dx[i]; &#125; &#125; int l = 0; for (int i = len_a; i &gt;= 1; i--) a[++l] = b[i]; for (int i = 1; i &lt;= len_b; i++) b[i] = s2[len_b - i] - &#x27;0&#x27;; //模拟手算 for (int i = 1; i &lt;= len_b; i++) for (int j = 1; j &lt;= len_a; j++) &#123; ans[i + j - 1] += b[i] * a[j]; &#125; int len = len_a + len_b; //进位 for (int i = 1; i &lt;= len; i++) &#123; if (ans[i] &gt; 9) ans[i + 1] += ans[i] / 10, ans[i] %= 10; &#125; //去除前导0 while (ans[len] == 0 &amp;&amp; len &gt; 1) len--; string s; for (int i = len; i &gt;= 1; i--) s += ans[i] + &#x27;0&#x27;; return s;&#125;string add(string s1, string s2)&#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); memset(ans, 0, sizeof(ans)); int len_a = s1.size(), len_b = s2.size(); for (int i = 1; i &lt;= len_a; i++) a[i] = s1[len_a - i] - &#x27;0&#x27;; for (int i = 1; i &lt;= len_b; i++) b[i] = s2[len_b - i] - &#x27;0&#x27;; //模拟手算 for (int i = 1; i &lt;= max(len_a, len_b); i++) ans[i] = a[i] + b[i]; int len = max(len_a, len_b) + 1; //进位 for (int i = 1; i &lt;= len; i++) &#123; if (ans[i] &gt; 9) ans[i + 1] += ans[i] / 10, ans[i] %= 10; &#125; //去除前导0 while (ans[len] == 0 &amp;&amp; len &gt; 1) len--; string s; for (int i = len; i &gt;= 1; i--) s += ans[i] + &#x27;0&#x27;; return s;&#125;int main()&#123; int n; cin &gt;&gt; n; str[1] = &quot;1&quot;; for (int i = 2; i &lt;= n; i++) &#123; str[i] = multi(i, str[i - 1]);//单精度×高精度 &#125; for (int i = 2; i &lt;= n; i++) &#123; str[i] = add(str[i], str[i - 1]); &#125; cout &lt;&lt; str[n] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"高精","slug":"高精","permalink":"https://coincidenceboy.github.io/tags/%E9%AB%98%E7%B2%BE/"}]},{"title":"拓扑排序","slug":"拓扑排序","date":"2020-12-21T02:02:14.000Z","updated":"2020-12-27T14:11:37.189Z","comments":true,"path":"2020/12/21/拓扑排序/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/21/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"","text":"拓扑排序(仅DAG)dfs逆后序 即 拓扑序 首先明确 dfs后序 即 各点完成时间的序列 逆后序—&gt;完成时间从大到小进行排序 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 5;//dfsbool vis[N];int d[N], f[N], dcnt, fcnt;void dfs(int u)&#123; vis[u] = true; //原本d[u]=++time;记录的是发现时间 d[++dcnt] = u; for (int i = head[u]; ~i; i = e[i].next) &#123; int v = e[i].v; if (!vis[v]) dfs(v); &#125; //原本f[u]=++time;记录的是完成时间 f[fcnt++] = u;//dfs后序 相当于是按完成时间小--&gt;大依次存储&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); &#125; for (int i = 1; i &lt;= n; i++) if (!vis[i]) dfs(i); //反向输出 dfs后序 for (int i = n; i &lt;= i; i++) cout &lt;&lt; f[i] &lt;&lt; &quot; &quot;; return 0;&#125; 一层一层的拓扑序123456789101112131415161718192021222324252627282930313233343536373839vector&lt;int&gt; ans;void toposort()&#123; ans.clear(); priority_queue&lt;int&gt; q; int count=0; for(int i=1;i&lt;=n;i++) //点从1开始到n 如果从0开始 改成 for(int i=0;i&lt;n;i++) &#123; if(in_deg[i]==0&amp;&amp;!vis[i]) &#123; q.push(-i); vis[i]=1; count++; &#125; &#125; while(q.size()) &#123; int now = q.top(); q.pop(); count--; ans.push_back(-now); for(int i=head[-now];~i;i=edge[i].next) &#123; int v = edge[i].to; in_deg[v]--; &#125; if(count==0) &#123; for(int i=1;i&lt;=n;i++) //点从1开始到n &#123; if(in_deg[i]==0&amp;&amp;!vis[i]) &#123; q.push(-i); count++; vis[i]=1; &#125; &#125; &#125; &#125;&#125; 只关注相邻序列的拓扑序(Kahn算法)123456789101112131415161718192021222324252627//仅 使得前面节点 不依赖于 后面的节点(联想 选课.vector&lt;int&gt; ans;void toposort()//输出字典序最小的toposort&#123; ans.clear(); priority_queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) &#123; if(in_deg[i]==0) &#123; q.push(-i); &#125; &#125; while(q.size()) &#123; int now = q.top(); q.pop(); ans.push_back(-now); for(int i=head[-now];~i;i=edge[i].next) &#123; int v = edge[i].to; if(--in_deg[v]==0) &#123; q.push(-v); &#125; &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://coincidenceboy.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://coincidenceboy.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"最短路","slug":"图中最短路","date":"2020-12-20T01:36:22.000Z","updated":"2021-01-02T13:54:28.522Z","comments":true,"path":"2020/12/20/图中最短路/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/20/%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"Floyd Floyd—&gt;求图中任意两点之间的距离. Floyd怎么来的? 动态规划的思想 1234567① 首先定义一个三维数组 f[k][x][y] 表示只允许经过节点1到k,节点x到节点y的最短路长度② 所以f[n][x][y],即节点x到节点y的最短路长度③ f[k][x][y]=min(f[k-1][x][y],f[k-1][x][k] + f[k-1][k][y]);改进:不难发现我们可以把第一维优化掉(因为在阶段k时,f[x][k]和f[k][y]不会被更新) 即 f[x][y]=min(f[x][y],f[x][k]+f[k][y]) Floyd代码实现1234567891011//Floydconst int N = 1e2+5;const int inf = 1e9;int dis[N][N];//dis初始化为inf,dis[i][j]表点i到点j的最短距离.void Floyd(int n,int **dis)&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);&#125; Floyd应用 (复杂度:O(n^3)) 多源最短路 图上的传递闭包,任意两点的连通关系. 传递闭包例题 N≤500,可以看出复杂度要求是O(n^3). (但是500^3=125,000,000 容易卡常数,详情见下面第三重循环剪枝) 由于胜负关系具有传递性,则可以用Floyd求出任意两点的胜负关系(传递闭包). 可以定义关系(初始化dis[] []为0) dis[a] [b]==1 表示a赢了b dis[a] [b]==0并且dis[b] [a]==0 表示a与b胜负关系无法预知. 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 505;int n, m, a, b,dis[N][N];int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; memset(dis, 0, sizeof(dis)); for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; dis[a][b] = 1; &#125; for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) &#123; if (dis[i][k])//第三层剪枝 因为只有dis[i][k]=1,第三重循环才是有意义的 &#123; for (int j = 1; j &lt;= n; j++) dis[i][j] = max(dis[i][j], dis[i][k] &amp; dis[k][j]);//i赢k,k赢j---&gt;i赢k &#125; &#125; int ans = 0; for(int i=1;i&lt;=n;i++) for (int j = i+1; j &lt;= n; j++) if (dis[i][j] == 0 &amp;&amp; dis[j][i] == 0) ans++; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Dijkstra(迪杰特斯拉) 该算法主要用来解决 图中没有负边的单源最短路 问题(因为dj算法判断负环比较困难) 复杂度O((n+m)logn) 即 mlogn 算法实现的大致流程 设置s为源点,dis[a]表示源点s到点a的最短距离,初始化dis[s]=0,dis[i]=inf,将s加入最小堆 每次从堆中取出一个点x(肯定是新加入的点影响到原结果),遍历x的所有邻接边edge(x y w),比较dis[y]与dis[x]+w的大小 ——即松弛操作 已收录的点,即被最小堆弹出过的点, 对任一未收录的顶点v,dis[v]表示从s到v的最短路径,但是该最短路径 仅经过所有被收录的顶点. Dijkstra模板代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 1e9, N = 1e5, M = 1e6;//链式前向星int head[N], cnt = 0, n, m;struct Edge&#123; int v, w, next;&#125;edge[M];void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u]; head[u] = cnt++;&#125;//Dijkstraint vis[N], dis[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;//默认是最大堆,最大堆丢负数--&gt;最小堆//用最小堆 是为了确定 哪个是下一个点 基本思想就是 不断地从未收录的点集中收录顶点(依据是dis值)void dijkstra(int s)&#123; while (q.size()) q.pop(); //初始化 for (int i = 1; i &lt;= n; i++) vis[i] = 0, dis[i] = inf; dis[s] = 0; q.push(make_pair(0, s)); //pair排序是按照pair.first进行排序的 所以第一个存距离，第二个存点 //主要部分 while (q.size()) &#123; int now = q.top().second;//堆中dis最小值的点 q.pop(); //即已收录的点集合 到 未收录点集合距离最小的点 if (vis[now]) continue; vis[now] = true; //松弛 for (int i = head[now]; ~i; i = edge[i].next) &#123; int u = now, v = edge[i].v, w = edge[i].w;// u(now) v w if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(make_pair(-dis[v], v)); //最大堆丢负数 变最小堆 &#125; &#125; &#125;&#125; 例题–一条商业线的最短路问题 问题思路 思路1 以 起点 为源点 跑 单源最短路,得到dis1数组; 以 终点 为源点 跑 单源最短路,得到dis2数组; 枚举每条商业线edge(u,v,w),ans=min{ans , dis1[u]+dis2[v]+w , dis1[v]+dis2[u]+w}; 最后再 ans=min(ans,不走商业线的最短距离); 思路2(分层图最短路) 跑一次单源最短路(变形版),记录答案dis[u] [0/1] dis[u] [0]表示从起点到节点u没有经过商业线时的最短路,松弛时可以选择商业线或者经济线 dis[u] [1]表示从起点到节点u经过商业线后的最短路,在松弛的时候只能选择经济线. 代码实现思路1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 1e9, N = 1e5, M = 1e6;//链式前向星int head[N], cnt = 0, n, m, k;int s, e;//起点,终点struct Edge&#123; int v, w, next;&#125;edge[M];void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u]; head[u] = cnt++;&#125;//Dijkstraint vis[N], dis1[N], dis2[N], path1[N], path2[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;//默认是最大堆,最大堆丢负数--&gt;最小堆//用最小堆 是为了确定 哪个是下一个点void dijkstra(int s,int* dis,int* path)&#123; while (q.size()) q.pop(); //初始化 for (int i = 1; i &lt;= n; i++) vis[i] = 0, dis[i] = inf, path[i] = -1; dis[s] = 0; q.push(make_pair(0, s)); //pair排序是按照pair.first进行排序的 所以第一个存距离，第二个存点 //主要部分 while (q.size()) &#123; int now = q.top().second;//堆中dis最小值的点 q.pop(); //即已收录的点集合 到 未收录点集合距离最小的点 if (vis[now]) continue; vis[now] = true; //松弛 for (int i = head[now]; ~i; i = edge[i].next) &#123; int u = now, v = edge[i].v, w = edge[i].w;// u(now) v w if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(make_pair(-dis[v], v)); //最大堆丢负数 变最小堆 path[v] = u; &#125; &#125; &#125;&#125;void output(int ss)&#123; if (ss == s) &#123; cout &lt;&lt; ss; return; &#125; output(path1[ss]); cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; ss;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; s &gt;&gt; e; int mindis = inf; //经济线 cin &gt;&gt; m; init(); while (m--) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); add(v, u, w); &#125; dijkstra(s, dis1, path1); dijkstra(e, dis2, path2); //商业线 cin &gt;&gt; k; int L = -1, R = -1, id = -1;//记录一下从哪一站乘坐商业线 以及商业线的左右节点 while (k--) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; //mindis = min(mindis, dis1[u] + dis2[v] + w,dis1[v] + dis2[u] + w); if (mindis &gt; dis1[u] + dis2[v] + w) &#123; L = u, R = v, id = u; mindis = dis1[u] + dis2[v] + w; &#125; if (mindis &gt; dis1[v] + dis2[u] + w) &#123; L = v, R = u, id = v; mindis = dis1[v] + dis2[u] + w; &#125; &#125; if (mindis &gt; dis1[e])//最短距离是 不使用商业票的时候 &#123; cout &lt;&lt; &quot;路线依次:&quot;;//输出路线 output(e); cout &lt;&lt; endl &lt;&lt; &quot;Ticket Not Used&quot; &lt;&lt; endl &lt;&lt; dis1[e] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;路线依次:&quot;;//输出路线 //使用商业线时,路线应该为 e--&gt;L--&gt;R--&gt;s output(L);//递归反向输出第一段 e--&gt;L cout &lt;&lt;&quot;-&gt;&quot;; int tmp = R; while (tmp != -1)//递推正向输出第二段R--&gt;s &#123; if (path2[tmp] != -1) cout &lt;&lt; tmp &lt;&lt; &quot;-&gt;&quot;; else cout &lt;&lt; tmp; tmp = path2[tmp]; &#125; //输出商业线车站号 和 总时间 cout &lt;&lt; endl &lt;&lt;&quot;商业线车站号:&quot;&lt;&lt;id &lt;&lt; endl &lt;&lt;&quot;最短时间:&quot;&lt;&lt; mindis; &#125; return 0;&#125; 注意: 输出路径时,从起点输出时递归输出(因为记录的是上一个位置,对应反向查找的过程,从终点输出时直接递推正序输出即可 思路2—分层图12//待补充// Bellman-ford算法及其队列优化(SPFA)Bellman-ford Bellman-ford算法可以给出源点s至图中其他所有点的最短路 以及 对应的前驱子图. Bellman-ford算法的正确性基于以下事实: 最短路经过的路径条数 ＜ 图中点的个数.(若 ≥ 点的个数,则意味着某点被重复经过) 当松弛边(u,v)时,如果dis[u]已经是最短路,并且在v的最短路径上(给定图,最短路径一定是确定的,只是现在还没有找到)u是v的前驱点,则松弛之后dis[v]也是最短路(相当于往外扩展了一层),并且以后其dis值不会改变. 12345678910111213141516171819202122232425//Bellman-fordfor(int i=1;i&lt;=n;i++)&#123; dis[i]=inf;//初始化所有点的dis值都是inf pre[i]=0;&#125;dis[s]=0;for(int k=1;k&lt;n;k++)//一层一层 松弛n-1次 for(int i=1;i&lt;=m;i++)//每轮松弛所有的边 &#123; int u=edge[i].u , v=edge[i].v , w=edge[i].w; if(dis[v] &gt; dis[u]+w) &#123; dis[v]=dis[u]+w; pre[v]=u; &#125; &#125;//判负环--如果第n次还可以松弛的话for(int i=1;i&lt;=m;i++)&#123; int u=edge[i].u , v=edge[i].v , w=edge[i].w; if(dis[v] &gt; dis[u]+w) cout&lt;&lt;&quot;存在负环&quot;&lt;&lt;endl; &#125;时间复杂度为O(nm) Bellman-ford算法完美解决了负权边的问题,但是它的复杂度过高,堪比复杂度为O(n^3)的Floyd算法,让人无法接受. (m最大值可以为(n*(n-1))/2,也就是说m可以达到n^2.) 仔细观察Bellman-ford算法的松弛过程 在第一轮松弛的过程中,最短路 边数为1 的点被确定了. 在第二轮松弛的过程中,最短路 边数为2 的点被确定了. …… 在第n-1轮松弛的过程中,最短路 边数为n-1的点被确定了. 在Bellman-ford算法中,每一轮都有很多无效的松弛操作,怎样可以避免呢? —&gt; 解决了这个问题就得到了 Bellman-ford的队列优化算法—SPFA SPFA(Shortest Path Faster Algorithm) 在之前观察Bellman-ford算法的松弛过程中,可以看出,松弛操作仅仅发生在最短路径 前导节点中 已经成功松弛过的节点上. 第一轮,与s邻接的点被松弛—&gt;最短路 边数为1 的点被确定 与第一轮被松弛的点 相邻接的点被松弛 —&gt;最短路 边数为2 的点被确定 … 一直到最短路 边数为n-1的点被确定 算法结束 为了每次都只做有效的松弛 建立一个队列 队列中储存被成功松弛的点 每次从队首取点并松弛其邻接点 如果邻接点松弛成功则将其放入队列 需要注意的point: 因为队列中存储的是 每一层的点,如何避免重复入队? —-&gt; 用数组记录一下是否已经在队列中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 1e9, N = 1e5, M = 1e6;//链式前向星int head[N], cnt = 0, n, m;struct Edge&#123; int v, w, next;&#125;edge[M];void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u]; head[u] = cnt++;&#125;//bfs判负环bool flag[maxn];void bfs(int s)&#123; queue&lt;int&gt; Q; while(Q.size()) Q.pop(); Q.push(s); flag[s] = 1; while(Q.size()) &#123; int now = Q.front(); Q.pop(); for(int i=head[now];~i;i=edge[i].next) &#123; int u = now,v = edge[i].to; if(!flag[v]) &#123; flag[v] = 1; Q.push(v); &#125; &#125; &#125;&#125;//spfa(Shortest Path Faster algorithm)int vis[N],cnt[N],dis[N],pre[N];//①vis - 点在不在队列中 ②cnt[x]表示点x最短路的边数(即第几层) ③dis - 距离 ④pre - 前驱//如果cnt[x]&gt;=n,则表明出现了负环queue&lt;int&gt; q;void spfa(int s)&#123; while(q.size()) q.pop(); //初始化 for(int i=1;i&lt;=n;i++) vis[i]=cnt[i]=pre[i]=0,dis[i]=inf; //队列中加入初始点 vis[s]=1,dis[s]=0; q.push(s); //主要部分 while(q.size()) &#123; int x = q.front(); q.pop(); vis[x]=0;//vis[]记录的是点在不在当前队列中,此时x出了队列 //松弛操作 for(int i=head[x];~i;i=edge[i].next) &#123; int u=x,v=edge[i].v,w=edge[i].w; if(dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; pre[v] = u; //cnt[u] 表点x最短路的边数(即第几层) //cnt[v] 相当于从x走(x,y)这条边到达了y cnt[v] = cnt[x] + 1; if(cnt[v]&gt;=n) bfs(v);//可以跑一下bfs/dfs 然后用flag数组标记一下所有负环的点 if(!vis[v]&amp;&amp;!flag[v])//当前点v没有在队列中，并且不是负环的一部分 &#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;时间复杂度平均是O(km)k是一个小于n的小常数(大多情况下都很小),但是在特殊情况下k可能会很大 (即spfa在特殊情况下时间复杂度会退化成O(nm)) 思考: 最短路存在吗? —–①当有负环的时候,最短路不存在 ②S不可达 即dis[s]==inf spfa例题—喵星收税关于最长路 在spfa中,只需要将 **①dis初始值 改成 -inf ②松弛条件由 dis[v] &gt; dis[u] + w —&gt;dis[v] &lt; dis[u] + w即可** 123456789101112131415161718192021222324252627282930313233//Dijkstra 跑 最长路int vis[N], dis[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void dijkstra(int s)&#123; while (q.size()) q.pop(); for (int i = 1; i &lt;= n; i++) vis[i] = 0, dis[i] = -inf;//原本:dis[i] = inf dis[s] = 0; q.push(make_pair(0, s)); while (q.size()) &#123; int now = q.top().second,v = q.top().first; q.pop(); //if (vis[now]) continue; //这句话原本表明 一个点一旦从最小堆中弹出,则这个点的dis到达了最小值 //但如果是最长路 一个点一旦从最大堆中弹出,则这个点的dis到达了最大值??? 可惜结论是不对的 我们不太需要判断vis可以将所有vis[]变量删除即可 取出v = q.top().first即距离取出来 if(v &lt; dis[now]) continue; vis[now] = true; for (int i = head[now]; ~i; i = edge[i].next) &#123; int u = now, v = edge[i].v, w = edge[i].w; if (dis[v] &lt; dis[u] + w)//原本:dis[v] &gt; dis[u] + w &#123; dis[v] = dis[u] + w; q.push(make_pair(dis[v], v)); //原本:最大堆里面丢负数当最小堆,但是现在要用最大堆 所以去掉负号 &#125; &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://coincidenceboy.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://coincidenceboy.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2020-12-19T10:26:03.000Z","updated":"2020-12-27T14:11:42.322Z","comments":true,"path":"2020/12/19/最小生成树/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"一般来说是无向图,有向图没太大意义. Kruskal(克鲁斯卡尔) 基于边的贪心算法 一句话—&gt;”每次贪心地将图中最小的非树边标记为树边,非法则跳过.” 将边按照权值小–&gt;大排序 按顺序考虑每条边,只要这条边和我们已经选择的边不构成回路,就保留该边,否则放弃这条边. 成功选择(n-1)条边后,则构成最小生成树; 如果无法选择出(n-1)条边,这说明原图不连通 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//kruskal算法 记录图的拓扑 可以简单用struct Edge来实现. 因为该算法不需要遍历点(点的出边等)//而且不需要考虑边的方向性. 每条边保存一次即可const int N = 1e4+5;const int M = 1e5+5;struct Edge&#123; int u,v,w; bool operator &lt; (const Edge&amp; p)const &#123;return w &lt; p.w;&#125;&#125;edge[M];int num;//边数//并查集int par[N],cnt[N];void init(int n)&#123; for(int i=1;i&lt;=n;i++) par[i]=i,cnt[i]=1;&#125;int find(int x)&#123; if(par[x]==x) return x; return par[x] = find(par[x]);//①路径压缩&#125;bool unite(int x,int y)&#123; x = find(x),y=find(y); if(x==y) return false; if(cnt[x]&gt;cnt[y]) swap(x,y);//小树挂在大树上.②启发式合并 par[x]=y; cnt[y]+=cnt[x]; return true;&#125;//kruskalint kruskal(int n)&#123; init(n); sort(edge,edge+num); int sum=0,ans=0; for(int i=0;i&lt;num;i++) &#123; if(unite(edge[i].u,edge[i].v)) &#123; ans+=edge[i].w; sum++; if(sum==n-1)//n个点求MST return ans; &#125; &#125; return -1;&#125; Prim(普里姆) 基于点的贪心算法 一句话—&gt;”维护一个连通的点集 , 每次都从不在该点集内的点选出一个加入该连通点集的代价最小的点.” 堆优化prim(代码同Dijkstra)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 1e9, N = 1e5, M = 1e6;//链式前向星int head[N], cnt = 0, n, m;struct Edge&#123; int v, w, next;&#125;edge[M];void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u]; head[u] = cnt++;&#125;//prim 代码基本上同dijint vis[N],min_cost[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q; //默认是最大堆,最大堆丢负数--&gt;最小堆//用最小堆 是为了确定 哪个是下一个点 基本思想就是 不断地从未收录的点集中收录顶点(依据是min_cost值)int prim()&#123; while (q.size()) q.pop(); //初始化 int ans = 0; for (int i = 1; i &lt;= n; i++) vis[i] = 0, min_cost[i] = inf; min_cost[1]=0; q.push(make_pair(0,1));//不妨以节点1为起始 //主要部分 while (q.size()) &#123; int now = q.top().second, tmp_ans = -q.top().first; q.pop(); if (vis[now]) continue; vis[now] = true; ans += tmp_ans; //松弛 for (int i = head[now]; ~i; i = edge[i].next) &#123; int u = now, v = edge[i].v, w = edge[i].w; if (min_cost[v] &gt; w) &#123; min_cost[v] = w; q.push(make_pair(-w, v)); &#125; &#125; &#125; return ans;&#125;int main()&#123; init(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); add(v, u, w); &#125; cout &lt;&lt; prim() &lt;&lt; endl; return 0;&#125; 朴素的prim代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5,inf=1e9+5;int n,m, min_cost[N], g[N][N] = &#123;&#125;;//邻接矩阵存图bool vis[N];int prim()//点集从1到n&#123; int ans = 0, tot = 1; vis[1] = true; //连通点集不妨从点1开始 for (int i = 1; i &lt;= n; i++) min_cost[i] = g[1][i]; while (true) &#123; int v = 0; //选出一个!vis 并且 到点集距离最小的点 for (int i = 1; i &lt;= n; i++) if (!vis[i] &amp;&amp; (!v || min_cost[v] &gt; min_cost[i])) v = i; //if (!v) break; if (min_cost[v] == inf || !v) break; //没有可以选的点 tot++; ans += min_cost[v]; vis[v] = true; //必定是新加入的点影响了其他未加入的点 到点集的距离 //以这个新点为边点,更新所有未加入点到该点集的距离 for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; min_cost[i] &gt; g[v][i]) min_cost[i] = g[v][i]; &#125; &#125; if (tot != n) return -1;//n个点是否连通 return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) g[i][j] = inf; //初始化g[N][N]为inf int u, v, w; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u][v] = w; g[v][u] = w; &#125; cout &lt;&lt; prim()&lt;&lt;endl; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://coincidenceboy.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"https://coincidenceboy.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"并查集","slug":"并查集","date":"2020-12-19T10:25:39.000Z","updated":"2020-12-27T14:11:24.165Z","comments":true,"path":"2020/12/19/并查集/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集123456789101112131415161718192021222324const int N = 1e5+5;int par[N],cnt[N];void init(int n)&#123; for(int i=1;i&lt;=n;i++) par[i]=i,cnt[i]=1;&#125;int find(int x)&#123; if(par[x]==x) return x; return par[x] = find(par[x]);//①路径压缩&#125;bool unite(int x,int y)&#123; x = find(x),y=find(y); if(x==y) return false; if(cnt[x]&gt;cnt[y]) swap(x,y);//小树挂在大树上.②启发式合并 par[x]=y; cnt[y]+=cnt[x]; return true;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://coincidenceboy.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://coincidenceboy.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"图的存储和遍历","slug":"图的存储和遍历","date":"2020-12-19T07:51:43.000Z","updated":"2020-12-27T14:11:50.755Z","comments":true,"path":"2020/12/19/图的存储和遍历/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/19/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/","excerpt":"","text":"图的存储邻接矩阵12345678邻接矩阵: 是一个N*N的二维数组 e[N][N]//无向图---&gt;存两条单向边即可.e[u][v]=w;e[v][u]=w;//无权图---&gt;可以令e[u][v]=1表示u-v之间有一条边,e[u][v]=0表无边e[u][v]=1;//有向带权图e[u][v]=w; 优点:查询速度快,可以直接找到两点之间的关系. 空间负责度为O(n^2),对于稀疏图来说浪费内存. 邻接表1234567891011121314151617181920212223邻接表: 存每一个点的出边可以利用vector&lt;int&gt; G[N]来记录//如果需要记录边权等边上信息,把int--&gt;structG[u]表示点u的 邻接数组,遍历这个vector即可得到 u 可到达的每一个点//无权有向图有一条边 u--&gt;v G[u].push_back(v);//无权无向图有一条边 u--&gt;v G[u].push_back(v); G[v].push_back(u);//有权图如果是vector&lt;int&gt; G[N],例如遍历G[u],只能知道u里面有哪些点,没有更多的信息(例如边权)const int N = 1e4+5;struct edge&#123; int v,w; edge()&#123;v=-1,w=0;&#125; edge(int _v,int _w)&#123;v=_v,w=_w;&#125;&#125;;vector&lt;edge&gt; G[N];void addEdge(int u,int v,int w)&#123; G[u].push_back(edge(v,w)); //G[v].push_back(edge(u,w)); //无向边&#125; 优点:只记录了邻接点的信息,空间复杂度仅为O(m),m为边数 缺点:查询u,v两点关系的时候,需要遍历u的邻接数组,相比较慢. 链式前向星 1234567891011121314151617181920212223242526const int N = 1e4+5;const int M = 1e5+5;struct Edge&#123; int v,w,next; //next记录的同head[]也是边的索引id&#125;edge[M];int head[N],cnt;//head[u]表 一条u射出的边的索引id. edge[head[u]]表第一条边 之后靠struct里面的next连接所有出边//cnt 当前边的个数void init()&#123; cnt = 0; memset(head, -1, sizeof head);&#125;void add(int u,int v,int w)&#123;//插入位置为head[]所指链表的头部; edge[cnt].v=v , edge[cnt].w=w , edge[cnt].next=head[u]; head[u]=cnt; cnt++; //edge[]从0开始&#125;遍历时:for (int i=head[now]; ~i; i=edge[i].next) //因为初始化 head[N]=&#123;-1&#125;,-1的补码是全1 ~按位取反 ~（-1）= 0 即条件为假 用数组来模拟链表. 相比较邻接链表而言,边在 链式前向星中存储的相对顺序与输入顺序相反,其他差异不大. 图的遍历 BFS 或者 DFS 例题:树的直径 首先明确 : 树的直径一定是某两个叶子之间的距离. 从树中任选一个点开始遍历这棵树,找到一个距离这个点最远的叶子1,然后再从这个叶子1开始遍历,找到离这个叶子1最远的另一个叶子2,叶子1—叶子2就是树的直径. 两次遍历即可求树的直径.(遍历可以用dfs也可以用bfs,找到距离起点最远的叶子节点即可.) (因为最远距离一定在叶子出现,所以虽然边权值不一定为1,但是可以不用dj等求两点之间最短/长距离,可以用dfs或者bfs) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 5;//链式前向星struct Edge&#123; int v, w, next;&#125;edge[2*N];int head[N],cnt;void init()&#123; cnt = 0; memset(head, -1, sizeof head);&#125;void add(int u, int v, int w)&#123; edge[cnt].v = v, edge[cnt].w = w, edge[cnt].next = head[u]; head[u] = cnt++;&#125;//bfsqueue&lt;int&gt; q;bool vis[N];int dis[N];int bfs(int begin)&#123; while (q.size()) q.pop(); memset(dis, 0, sizeof(dis)); memset(vis, 0, sizeof(vis)); vis[begin] = true; q.push(begin); int node = begin, mx_len = 0; while (q.size()) &#123; int now = q.front(); q.pop(); for (int i = head[now]; ~i; i = edge[i].next) &#123; if (!vis[edge[i].v]) &#123; vis[edge[i].v] = 1; dis[edge[i].v] = dis[now] + edge[i].w; if (mx_len &lt; dis[edge[i].v]) &#123; mx_len = dis[edge[i].v]; node = edge[i].v; &#125; q.push(edge[i].v); &#125; &#125; &#125; return node;//返回距离该点最远的点id //return mx_len;&#125;int main()&#123; ios::sync_with_stdio(false); init(); int n, v, w; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; v &gt;&gt; w; add(i, v, w); add(v, i, w); &#125; int a = bfs(1); //直径左端点 int b = bfs(a); //直径右端点 int dis_a[N]; for (int i = 1; i &lt;= n; i++) dis_a[i] = dis[i]; bfs(b); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; max(dis_a[i], dis[i]) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://coincidenceboy.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"图的存储和遍历","slug":"图的存储和遍历","permalink":"https://coincidenceboy.github.io/tags/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"}]},{"title":"前缀和&差分","slug":"前缀和&差分","date":"2020-12-19T03:02:08.000Z","updated":"2020-12-19T03:56:35.167Z","comments":true,"path":"2020/12/19/前缀和&差分/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/19/%E5%89%8D%E7%BC%80%E5%92%8C&%E5%B7%AE%E5%88%86/","excerpt":"","text":"前缀和 1234567891011121314151617181920212223//一维前缀和 初始化int a[N]=&#123;0&#125;,dp[N]=&#123;0&#125;;for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; dp[i]=s[i-1]+a[i];&#125;//性质dp[i] = dp[i-1] + a[i];dp[L,R] = dp[R] - dp[L-1];//二维前缀和 初始化int a[N][M]=&#123;0&#125;,dp[N][M]=&#123;0&#125;;for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;a[i][j]; dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[x-1][y-1]+a[i][j]; &#125;&#125;//性质dp[a,b][c,d]=dp[c][d]-dp[a][d]-dp[c][b]+sum[a][b]; 差分 123456789101112//一维差分 初始化int a[N]=&#123;0&#125;,dp[N]=&#123;0&#125;;for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; dp[i]=a[i]-a[i-1];&#125;//差分数组前缀和 = a[]元素值dp[1]+dp[2]+...+dp[i]=a[i];//差分数组单点修改 = a[]区间整体+- dp[L] += c,dp[R+1] -= c;等价于a[L]+=c,a[L+1]+=c,...,a[R]+=c; 例题 分析: 暴力做法O(q*n),超时 将原数组A—&gt;差分数组B,将区间操作—&gt;单点修改 B数组前缀和即为A数组最终数值.0(n+q) 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2*1e5+5;long long n,q,a[N],b[N];//防止q次操作导致int溢出int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;q; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; b[i]=a[i]-a[i-1]; &#125; int l,r,c; while(q--) &#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; b[l]+=c; b[r+1]-=c; &#125; long long tmp=0; for(int i=1;i&lt;=n;i++) &#123; if(i==1) tmp=b[i],cout&lt;&lt;tmp; if(i&gt;1) tmp+=b[i],cout&lt;&lt;&quot; &quot;&lt;&lt;tmp; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"前缀和&差分","slug":"前缀和-差分","permalink":"https://coincidenceboy.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/"}]},{"title":"尺取法","slug":"尺取法","date":"2020-12-17T07:27:12.000Z","updated":"2020-12-17T12:41:41.852Z","comments":true,"path":"2020/12/17/尺取法/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/17/%E5%B0%BA%E5%8F%96%E6%B3%95/","excerpt":"","text":"经典例题-求长度最小的连续区间 使之 sum&gt;=给定整数S 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1005;int n, s, a[N];int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int l = 1, r = 1, sum = 0; int ans = n+1; while (1) &#123; while (r &lt;= n &amp;&amp; sum &lt; s) &#123; sum += a[r++]; &#125; if (sum &lt; s) break; ans = min(ans, r - l); sum -= a[l++]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 平衡字符串问题 why用 尺取法? 所求答案为一个连续的区间. 区间左右端点移动有着明确的方向.—&gt;当前[L,R]满足要求,则L++.当前[L,R]不满足要求,则R++. 给定[L,R],如何判断是否满足要求呢? 用sum1,sum2,sum3,sum4分别记录不包括区间[L,R]这一段时,字符’A’’B’’C’’D’ 先通过替换使4类字符数量一致,再判断剩余空闲位置是否是4的倍数. 123MAX = max(sum1,sum2,sum3,sum4);free = 区间元素个数-[(MAX-sum1)+(MAX-sum2)+(MAX-sum3)+(MAX-sum4)]//若free&gt;=0且为4的倍数,则满足要求;否则不满足. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int ans = 100000, sum1, sum2, sum3, sum4;string s;int main()&#123; cin &gt;&gt; s; int n = s.size(); for (int i = 0; i &lt; n; i++) &#123; if (s[i] == &#x27;Q&#x27;) sum1++; if (s[i] == &#x27;W&#x27;) sum2++; if (s[i] == &#x27;E&#x27;) sum3++; if (s[i] == &#x27;R&#x27;) sum4++; &#125; if (sum1 == sum2 &amp;&amp; sum2 == sum3 &amp;&amp; sum3 == sum4) &#123; cout &lt;&lt; 0 &lt;&lt;endl; return 0; &#125; int l = 0, r = 0, sum = 0; int maxx = max(max(sum1, sum2), max(sum3, sum4)); int free = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4); while (1) &#123; while (r &lt; n &amp;&amp; !(free &gt;= 0 &amp;&amp; free % 4 == 0)) &#123; // [l,r] 不符合条件 - r++ if (s[r] == &#x27;Q&#x27;) sum1--; if (s[r] == &#x27;W&#x27;) sum2--; if (s[r] == &#x27;E&#x27;) sum3--; if (s[r] == &#x27;R&#x27;) sum4--; r++; maxx = max(max(sum1, sum2), max(sum3, sum4)); free = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4); &#125; if (!(free &gt;= 0 &amp;&amp; free % 4 == 0)) break; ans = min(ans, r-l); // [l,r] 符合条件 - l++ if (s[l] == &#x27;Q&#x27;) sum1++; if (s[l] == &#x27;W&#x27;) sum2++; if (s[l] == &#x27;E&#x27;) sum3++; if (s[l] == &#x27;R&#x27;) sum4++; l++; maxx = max(max(sum1, sum2), max(sum3, sum4)); free = (r-l) - (maxx - sum1) - (maxx - sum2) - (maxx - sum3) - (maxx - sum4); &#125; cout &lt;&lt; ans &lt;&lt;endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"线性数据结构","slug":"线性数据结构","permalink":"https://coincidenceboy.github.io/tags/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"单调栈和单调队列","slug":"单调栈和单调队列","date":"2020-12-17T01:08:15.161Z","updated":"2020-12-17T07:19:47.621Z","comments":true,"path":"2020/12/17/单调栈和单调队列/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/17/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"","text":"简单分析 伪码实现 单增栈 1234567891011121314//栈顶---&gt;栈底,单调增 (只维护一端:栈顶)stack&lt;int&gt; st;int a[n+1];//a[1]~a[n]源数据a[n+1]=INT_MAX; //为了将栈内元素全部弹出//for(int i=1;i&lt;=n+1;i++)&#123; while(st.size()&gt;0&amp;&amp;a[i]&gt;st.top()) &#123;//谁的加入(即a[i])把你弹出去了,谁就是你往→第一个比你 big 的数 !!! 即while循环里 a[i]就是st.top() 往→第一个big的数 st.pop(); &#125; st.push(a[i]);&#125; 单增队列 1234567891011121314151617181920212223//队首---&gt;队尾,单调增 (维护两端:队首和队尾)deque&lt;int&gt; q;int a[n+1];//a[1]~a[n]源数据int k=3;//窗口大小//初始化队列大小为k-1for(int i=1;i&lt;=k-1;i++)&#123; while(q.size()&gt;0&amp;&amp;a[i]&lt;q.back()) q.pop_back(); q.push_back(a[i]);&#125;//窗口从k开始向右移动,维护一个单增队列for(int i=k;i&lt;=n;i++)&#123; //维护单调性 while(q.size()&gt;0&amp;&amp;a[i]&lt;q.back()) q.pop_back(); q.push_back(a[i]); //再维护窗口大小,保证队列元素都落在窗口内 while(q.size()&gt;0&amp;&amp;(i-队首q.front的元素下标)&gt;=k) q.pop_front(); !!! 此时窗口small值就是q.front();&#125; 经典例题单调栈:直方图求最大矩形面积 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int n, a[N];int a_l[N], a_r[N];//必须存数组下标,因为面积计算公式要用到 区间长度stack&lt;int&gt; st;//需配合a_l和a_r 也必须存数组下标int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; // → a[n + 1] = -1;//保证数组中每个元素 都被 弹出一次 for (int i = 1; i &lt;= n+1; i++) &#123; while (st.size() &gt; 0 &amp;&amp; a[i] &lt; a[st.top()]) &#123; a_r[st.top()] = i; st.pop(); &#125; st.push(i); &#125; // ← while (st.size()) st.pop(); a[0] = -1;//保证数组中每个元素 都被 弹出一次 for (int i = n; i &gt;=0 ; i--) &#123; while (st.size() &gt; 0 &amp;&amp; a[i] &lt; a[st.top()]) &#123; a_l[st.top()] = i; st.pop(); &#125; st.push(i); &#125; long long ans = -1; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans,(a_r[i]-a_l[i]-1)*a[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 单调队列:滑动窗口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;int n,k;int a[N];int a_min[N], a_max[N];//里面存数组下标(直接存值亦可)deque&lt;int&gt; q;//必须存数组下标int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; // min for (int i = 1; i &lt;= n; i++) &#123;//维护单调性 while (q.size() &gt; 0 &amp;&amp; a[i] &lt; a[q.back()]) q.pop_back(); q.push_back(i); //再维护窗口大小,保证队列元素都落在窗口内 while (q.size() &gt; 0 &amp;&amp; (i - q.front()) &gt;= k) q.pop_front(); if (i &gt;= k) a_min[i] = q.front(); &#125; // max q.clear(); for (int i = 1; i &lt;= n; i++) &#123;//维护单调性 while (q.size() &gt; 0 &amp;&amp; a[i] &gt; a[q.back()]) q.pop_back(); q.push_back(i); //再维护窗口大小,保证队列元素都落在窗口内 while (q.size() &gt; 0 &amp;&amp; (i - q.front()) &gt;= k) q.pop_front(); if (i &gt;= k) a_max[i] = q.front(); &#125; for (int i = k; i &lt;= n; i++) cout &lt;&lt; a[a_min[i]] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int i = k; i &lt;= n; i++) cout &lt;&lt; a[a_max[i]] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"线性数据结构","slug":"线性数据结构","permalink":"https://coincidenceboy.github.io/tags/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"vs2019添加c++万能头文件","slug":"vs2019添加c++万能头文件","date":"2020-12-16T07:52:53.000Z","updated":"2020-12-16T09:08:38.000Z","comments":true,"path":"2020/12/16/vs2019添加c++万能头文件/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/16/vs2019%E6%B7%BB%E5%8A%A0c++%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/","excerpt":"","text":"VS2019安装路径下找到VC文件依次进入Tools/MSVC/14.24.28314/include。然后在include内创建一个名称为bits的文件(图示为默认安装路径) 在bits文件夹创建一个stdc++.h并将下面代码复制进去即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// C++ includes used for precompiling -*- C++ -*- // Copyright (C) 2003-2015 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library. This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version. // This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details. // Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation. // You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively. If not, see// &lt;http://www.gnu.org/licenses/&gt;. /** @file stdc++.h * This is an implementation file for a precompiled header. */ // 17.4.1.2 Headers // C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt; #if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif // C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt; #if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"c++万能头","slug":"c-万能头","permalink":"https://coincidenceboy.github.io/tags/c-%E4%B8%87%E8%83%BD%E5%A4%B4/"}]},{"title":"解决win10蓝牙设备连接不上","slug":"关于win10蓝牙设备连接不上","date":"2020-12-16T06:45:44.000Z","updated":"2020-12-16T09:09:54.273Z","comments":true,"path":"2020/12/16/关于win10蓝牙设备连接不上/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/16/%E5%85%B3%E4%BA%8Ewin10%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/","excerpt":"","text":"已配对蓝牙无法连接并且搜索不到 123456789101112131415161718192021222324252627282930313233343536373839404142434445$Source = @&quot; [DllImport(&quot;BluetoothAPIs.dll&quot;, SetLastError = true, CallingConvention = CallingConvention.StdCall)] [return: MarshalAs(UnmanagedType.U4)] static extern UInt32 BluetoothRemoveDevice(IntPtr pAddress); public static UInt32 Unpair(UInt64 BTAddress) &#123; GCHandle pinnedAddr = GCHandle.Alloc(BTAddress, GCHandleType.Pinned); IntPtr pAddress = pinnedAddr.AddrOfPinnedObject(); UInt32 result = BluetoothRemoveDevice(pAddress); pinnedAddr.Free(); return result; &#125;&quot;@Function Get-BTDevice &#123; Get-PnpDevice -class Bluetooth | ?&#123;$_.HardwareID -match &#x27;DEV_&#x27;&#125; | select Status, Class, FriendlyName, HardwareID, # Extract device address from HardwareID @&#123;N=&#x27;Address&#x27;;E=&#123;[uInt64](&#x27;0x&#123;0&#125;&#x27; -f $_.HardwareID[0].Substring(12))&#125;&#125;&#125;################## Execution Begins Here ################$BTR = Add-Type -MemberDefinition $Source -Name &quot;BTRemover&quot; -Namespace &quot;BStuff&quot; -PassThru$BTDevices = @(Get-BTDevice) # Force array if null or single itemDo &#123; If ($BTDevices.Count) &#123; &quot;`n******** Bluetooth Devices ********`n&quot; | Write-Host For ($i=0; $i -lt $BTDevices.Count; $i++) &#123; (&#x27;&#123;0,5&#125; - &#123;1&#125;&#x27; -f ($i+1), $BTDevices[$i].FriendlyName) | Write-Host &#125; $selected = Read-Host &quot;`nSelect a device to remove (0 to Exit)&quot; If ([int]$selected -in 1..$BTDevices.Count) &#123; &#x27;Removing device: &#123;0&#125;&#x27; -f $BTDevices[$Selected-1].FriendlyName | Write-Host $Result = $BTR::Unpair($BTDevices[$Selected-1].Address) If (!$Result) &#123;&quot;Device removed successfully.&quot; | Write-Host&#125; Else &#123;&quot;Sorry, an error occured.&quot; | Write-Host&#125; &#125; &#125; Else &#123; &quot;`n********* No devices foundd ********&quot; | Write-Host &#125;&#125; While (($BTDevices = @(Get-BTDevice)) -and [int]$selected) 将上述代码直接复制粘贴到 Windows PowerShell 里,然后删除出问题的设备,重新搜索蓝牙设备即可.","categories":[{"name":"win10","slug":"win10","permalink":"https://coincidenceboy.github.io/categories/win10/"}],"tags":[{"name":"蓝牙","slug":"蓝牙","permalink":"https://coincidenceboy.github.io/tags/%E8%93%9D%E7%89%99/"}]},{"title":"csp12-13收获","slug":"csp12-13收获","date":"2020-12-13T12:59:01.000Z","updated":"2020-12-17T14:20:44.606Z","comments":true,"path":"2020/12/13/csp12-13收获/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/13/csp12-13%E6%94%B6%E8%8E%B7/","excerpt":"","text":"二分找到&gt;=k的第一个位置1234567891011121314151617//下标从1开始,找不到返回-1int lower_bound(int k)&#123; int l=1,r=n,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&gt;=k) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; return ans;&#125; 找到&lt;=k的最后一个位置12345678910111213141516int reverse_lower_bound(int k)&#123; int l = 1, r = n, ans = -1; while (l&lt;=r) &#123; int mid = (l + r) &gt;&gt; 1; if (a[mid] &lt;= k) &#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; return ans;&#125; 找到==k的第一个位置123456789101112131415161718//下标从1开始,找不到返回-1int find_first(int k)&#123; int l=1,r=n,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(a[mid]==k) &#123; ans = mid; r = mid - 1; &#125; else if(a[mid] &lt; k) l = mid + 1; else r = mid - 1; &#125; return ans;&#125; 找到==k的最后一个位置123456789101112131415161718//下标从1开始,找不到返回-1int find_last(int k)&#123; int l=1,r=n,ans=-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(a[mid]==k) &#123; ans = mid; l = mid + 1; &#125; else if(a[mid] &gt; k) r = mid - 1; else l = mid + 1; &#125; return ans;&#125; 例题(整数二分):四个数列和为0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//首先四重枚举肯定超时,所以要减少枚举的次数.//先枚举a和b数组,然后将枚举结果放到一个新的数组ab,//再枚举c和d数组,然后枚举的时候计算它的相反数在ab中出现几次(有序数组last位置-first位置)#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 4005;int n,a[N], b[N], c[N], d[N],ab[N*N];//下标从1开始,找不到返回-1int find_first(int x)&#123; int l = 1, r = n*n, ans = -1; while (r &gt;= l) &#123; int mid = (l + r) &gt;&gt; 1; if (ab[mid] == x) &#123; ans = mid; r = mid - 1; &#125; else if (ab[mid] &lt; x) l = mid + 1; else r = mid - 1; &#125; return ans;&#125;//下标从1开始,找不到返回-1int find_last(int x)&#123; int l = 1, r = n*n, ans = -1; while (r &gt;= l) &#123; int mid = (l + r) &gt;&gt; 1; if (ab[mid] == x) &#123; ans = mid; l = mid + 1; &#125; else if (ab[mid] &gt; x) r = mid - 1; else l = mid + 1; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i] &gt;&gt; d[i]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; ab[(i-1) * n + j] = a[i] + b[j]; &#125; sort(ab + 1, ab + 1 + n * n); int ans = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123; int key = -(c[i] + d[j]); int l = find_first(key), r = find_last(key); if (r != -1) ans += r - l + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 例题(浮点二分) 求方程 f(x)=x^6+x-2014 在(0,+∞)的一个解,要求小数点后精确5位 1234567891011121314151617181920212223242526272829//先估算一个区间 f(1)&lt;0 f(10)&gt;0 不妨l=1.0,r=10.0#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-5;double f(double x)&#123; return pow(x, 6) + x - 2014;&#125;double find()&#123; double l = 1, r = 10; while (abs(r - l) &gt; eps) &#123; double mid = (l + r) / 2; if (f(mid) * f(r) &lt;= 0) &#123; l = mid; &#125; else r = mid; &#125; return l;&#125;int main()&#123; ios::sync_with_stdio(false); printf(&quot;%.5lf&quot;, find()); return 0;&#125; 二分答案 二分思想:只要是单调的,都可以二分!!! 问题分析暴力枚举 i,j 将数列B计算出来,然后取它的中位数.时间和空间复杂度均0(n^2),无法接受—&gt;转换思路 如果给定一个数p,如何判断它是不是中位数? —-&gt;计算p在数列中的排名(假定从小到大)即可 如果p名次比中位数小,则说明 p比中位数小 如果p名次比中位数大,则说明 p比中位数大 如果p名次等于中位数,则说明 p是中位数 可以看出 满足单调性,可以对p进行二分.(二分答案!!!) 如何计算p的名次? 对于数组B={|Ai-Aj|,任意 1&lt;=i &lt; j&lt;=n} 将A数组从小到大排序,则可以去掉绝对值.即B={ Aj-Ai ,任意 1&lt;=i &lt; j&lt;=n} 那么计算Aj - Ai &lt;= p的个数即可. 移项有 Aj&lt;=p+Ai , 其中 i&lt;j 即对于每个P,枚举下标 i 然后计算满足条件的下标 j 的个数(整数二分!!!) 具体实现 首先确定答案区间(即p的范围),p就是新数组B中元素可能的取值,可以看出 0=&lt;Bi&lt;=A.max()-A.min() 然后就是对于每一个p,计算满足不等式(Aj&lt;=p+Ai )的个数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int n,a[N];//找到&lt;=k的最后一个位置int re_lower_bound(int l,int r,int k)&#123; int ans = -1; while (r &gt;= l) &#123; int mid = (l + r) &gt;&gt; 1; if (a[mid] &lt;= k) &#123; ans = mid; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; return ans;&#125;int rnk(int p)&#123;//计算满足 Aj&lt;=p+Ai , 其中 i&lt;j 的个数 //对于每个p,枚举下标i,然后二分计算满足的j的个数. j的范围[i+1,n]; int ans = 0; for (int i = 1; i &lt; n; i++) &#123; int cnt = re_lower_bound(i + 1, n, p + a[i]); if(cnt!=-1) ans += cnt - i; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; sort(a + 1, a + n + 1); int len = (1 + n * (n - 1)) / 2; //新数组的长度 int ans = -1, middle = (len + 1) / 2; //middle为中位数位置,下面实现 找到名次 &gt;=middle 的第一个p //思考为什么不是找 ==middle 的第一个p??? int p_min = 0, p_max = a[n] - a[1]; while (p_min &lt;= p_max) &#123; int p_mid = (p_min + p_max) / 2; int cnt = rnk(p_mid); if (cnt &gt;= middle) &#123; ans = p_mid; p_max = p_mid - 1; &#125; else p_min = p_mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; middle为中位数位置,下面实现 找到名次 &gt;=middle 的第一个p 关于为什么不是找 ==middle 的第一个p? ===&gt; 在计算rak的时候 用到的不等式为: Aj&lt;=p+Ai ​ 例如初始化B=1 3 3 3 5 答案p∈[1,5] p_mid=3 然后返回的cnt=4&gt;middle=3 , 如果判 ==middle,p∈[1,2] ,就会接着找p_mid=1,返回的cnt=1,然后p∈[2,2],p_mid=2,返回cnt=1,然后p∈[3,2],就退出了","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"csp","slug":"csp","permalink":"https://coincidenceboy.github.io/tags/csp/"}]},{"title":"sort,map,set","slug":"STL排序和map","date":"2020-12-09T05:52:13.000Z","updated":"2021-01-18T02:02:36.343Z","comments":true,"path":"2020/12/09/STL排序和map/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/09/STL%E6%8E%92%E5%BA%8F%E5%92%8Cmap/","excerpt":"","text":"sort基本用法—对类型为T的数组 默认从小到大排序 1sort(a,a+n); 从大到小排序 1sort(a,a+n,greater&lt;int&gt;()); 对struct类型数组进行排序123456789101112struct rank&#123; string name; int score = 0; bool operator &lt; (const rank1 &amp; s) const &#123; if (score!=s.score) return score &gt; s.score; //首先 按score从大--&gt;小 return name &lt; s.name;//其次 按name字典序从小--&gt;大 &#125;&#125;;rank r[1000];sort(r,r+count); struct配合map自定义排序顺序(给元素添加一个val值,按val进行排序)12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;map&lt;char,int&gt; hua_val;map&lt;char,int&gt; name_val;struct card&#123; char hua;//卡牌的花色 char name;//卡牌的牌面 bool operator &lt; (const card &amp; s) const &#123; if (hua!=s.hua) return hua_val[hua] &lt; hua_val[s.hua]; else return name_val[name] &lt; name_val[s.name]; &#125;&#125;;int main()&#123; hua_val[&#x27;C&#x27;] = 1; hua_val[&#x27;D&#x27;] = 2; hua_val[&#x27;S&#x27;] = 3; hua_val[&#x27;H&#x27;] = 4; //用C,D,S,H分别表示梅花，方片，黑桃，红桃，即其单词首字母 //规定花色（梅花）&lt;（方片）&lt;（黑桃）&lt;（红桃） name_val[&#x27;2&#x27;] = 1; name_val[&#x27;3&#x27;] = 2; name_val[&#x27;4&#x27;] = 3; name_val[&#x27;5&#x27;] = 4; name_val[&#x27;6&#x27;] = 5; name_val[&#x27;7&#x27;] = 6; name_val[&#x27;8&#x27;] = 7; name_val[&#x27;9&#x27;] = 8; name_val[&#x27;T&#x27;] = 9; name_val[&#x27;J&#x27;] = 10; name_val[&#x27;Q&#x27;] = 11; name_val[&#x27;K&#x27;] = 12; name_val[&#x27;A&#x27;] = 13; //规定2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; T &lt; J &lt; Q &lt; K &lt; A card puke [13]; sort(puke,puke+13);&#125; 123456789101112131415161718192021//常量map声明,而不是声明一个空的map随后再赋值map&lt;char,int&gt; hua_val(&#123; &#123;&#x27;C&#x27;,1&#125;, &#123;&#x27;D&#x27;,2&#125;, &#123;&#x27;S&#x27;,3&#125;, &#123;&#x27;H&#x27;,4&#125;&#125;);//或者自编写一个change函数int change(char c)&#123; if(c==&#x27;C&#x27;) return 1; else if(c==&#x27;D&#x27;) return 2; else if(c==&#x27;S&#x27;) return 3; else if(c==&#x27;H&#x27;) return 4;&#125;bool operator &lt; (const card &amp; s) const&#123; if (hua!=s.hua) return change_hua(hua) &lt; change_hua(s.hua); else return change_val(name) &lt; change_val(s.name);&#125; 如果涉及到大量的insert数据,erase数据,find数据,考虑用stl中的平衡二叉树数据结构会很方便. 上述操作都能在 log(n)复杂度完成. 体现在stl中有4种容器 : multiset set multimap map 都会自动维持有序性 set和multiset1234567891011121314151617set&lt;int&gt; st;multiset&lt;int&gt; st;//缺省排序规则 表达式&quot;a&lt;b&quot;为ture,则a排在b前面//可用 st.insert() st.erase() st.find() 复杂度均log(n)//赋值st.insert(1);//查找if(st.find(1)!=s.end()) printf(&quot;the element is in set&quot;);//遍历for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++) printf(&quot;%d &quot;,*it);for(auto &amp;x : s)//c++11 新特性 printf(&quot;%d &quot;,x);//清空s.erase(val);s.clear(); map和multimap map中使用结构体需要重写比较方法 &lt; ,因为要维持其有序性.","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://coincidenceboy.github.io/tags/STL/"}]},{"title":"bfs及其应用","slug":"bfs及其应用","date":"2020-12-08T07:31:04.409Z","updated":"2020-12-14T09:49:20.182Z","comments":true,"path":"2020/12/08/bfs及其应用/","link":"","permalink":"https://coincidenceboy.github.io/2020/12/08/bfs%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","excerpt":"","text":"BFS 篇幅问题 只给出核心代码 省略一些不必要的声明和main() BFS板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//以输出路径的5×5迷宫为例struct point&#123;//省略重载point(x,y)和== int x, y;&#125;;const int dx[4] = &#123; 0,0,-1,1 &#125;;const int dy[4] = &#123; -1,1,0,0 &#125;;int dis[5][5];//-1表可以走,-2表不能走point path[5][5];void output(point a, point b)&#123; if (b == a) &#123; printf(&quot;(%d,%d)\\n&quot;, b.x, b.y); return; &#125; output(a, path[b.x][b.y]); printf(&quot;(%d,%d)\\n&quot;, b.x, b.y);&#125;int bfs(point a,point b)&#123; queue&lt;point&gt; q; point now = a; dis[now.x][now.y] = 0; q.push(now); while (q.size()) &#123; now = q.front(); q.pop(); if (now == b) &#123; output(a, b); return dis[now.x][now.y]; &#125; for (int i = 0; i &lt; 4; i++) &#123; int new_x = now.x + dx[i],new_y = now.y + dy[i]; if (new_x&gt;=0&amp;&amp;new_x&lt;=4 &amp;&amp; new_y&gt;=0&amp;&amp;new_y&lt;=4 &amp;&amp; dis[new_x][new_y]==-1) &#123; q.push(point(new_x, new_y)); dis[new_x][new_y] = dis[now.x][now.y] + 1; path[new_x][new_y] = now; &#125; &#125; &#125; return -1;&#125; 倒水问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int A, B, C;//map中使用struct需要重载 &lt; 进行排序struct state&#123; int a, b;//省略重载state(a,b) bool operator &lt; (const state&amp; p) const &#123; if (a != p.a)return a &lt; p.a; return b &lt; p.b; &#125;&#125;;map&lt;state, state&gt; from; map&lt;state, string&gt; step;void output(state now)&#123; if (now.a == 0 &amp;&amp; now.b == 0) &#123; //printf(&quot;&lt;%d,%d&gt;\\n&quot;, now.a, now.b); return; &#125; output(from[now]); //printf(&quot;-&gt;&lt;%d,%d&gt;&quot;, now.a, now.b); cout &lt;&lt; step[now] &lt;&lt; endl;&#125;void bfs()&#123; queue&lt;state&gt; q; state now(0,0); q.push(now); while (q.size()) &#123; now = q.front(); q.pop(); if (now.a == C || now.b == C) &#123; output(now); return true; &#125; //如何记录之前状态是否已经存在了呢? 类似迷宫 已经走过 //map&lt;state, state&gt; from; if (now.a &lt; A)//①fill A &#123; state after(A, now.b); if (from.find(after) == from.end()) &#123; q.push(after); from[after] = now; step[after] = &quot;fill A&quot;; &#125; &#125; //省略②empty A if (now.a &gt; 0)//③pour A B B满orA空 &#123; state after; if (now.a + now.b &lt;= B) after.a = 0, after.b = now.a + now.b; else after.a = now.a + now.b - B, after.b = B; if (from.find(after) == from.end()) &#123; q.push(after); from[after] = now; step[after] = &quot;pour A B&quot;; &#125; &#125; //省略关于B的相同操作 &#125;&#125;int main()&#123; while (cin &gt;&gt; A &gt;&gt; B &gt;&gt; C) &#123; from.clear(); step.clear(); bfs(); cout &lt;&lt; &quot;success&quot; &lt;&lt; endl; &#125; return 0;&#125; 超级源点问题 csp 201409-4 “最佳配餐” 123456789101112131415161718192021222324252627282930313233343536//初始化queue的时候将所有分店都push进去,bfs结束条件改为cnt==n*n 即网格中除了障碍物全部都遍历到.//然后每个网格点都有了最小的dis,与记录的客户数目相乘算得结果即可.//注:①ans要用long long储存②由图可知下标从1~n queue&lt;point&gt; q;void bfs()&#123; while (q.size()) q.pop(); point now; int cnt = d; for (int i = 0; i &lt; v.size(); i++) &#123;//读入的时候 vector v 记录一下分店的数目 now = v[i]; dis[now.x][now.y] = 0; q.push(now); cnt++; &#125; while (q.size()) &#123; now = q.front(); q.pop(); if (cnt == n * n) &#123; return; &#125; for (int i = 0; i &lt; 4; i++) &#123; int new_x = now.x + dx[i],new_y = now.y + dy[i]; if (new_x&gt;=1&amp;&amp;new_x&lt;=n &amp;&amp; new_y&gt;=1&amp;&amp;new_y&lt;=n &amp;&amp; dis[new_x][new_y]==-1) &#123; q.push(point(new_x, new_y)); dis[new_x][new_y] = dis[now.x][now.y] + 1; cnt++; &#125; &#125; &#125;&#125; 有特殊点的bfs csp 201403-4 “无线网络” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int N = 205;int n, m, k;long long r;struct Node&#123; long long x, y; int dis, k; Node() &#123; x = -1, y = -1, dis = 0, k = 0; &#125; Node(long long _x, long long _y, int _s, int _k) &#123; x = _x, y = _y, dis = _s, k = _k; &#125;&#125;node[N];bool vis[N];queue&lt;Node&gt; q;int bfs(int begin, int end)&#123; while (q.size()) q.pop(); Node now = node[1]; vis[begin] = 1; q.push(now); while (q.size()) &#123; now = q.front(); q.pop(); if (now.x == node[end].x&amp;&amp;now.y == node[end].y) return now.dis - 1; //中转个数=距离-1 int len;// 下一跳可以选择node下标范围 if (now.k == k) len = n;//通过下一跳的范围限制 增设的路由器至多k个 else len = n + m; for (int i = 1; i &lt;= len; i++) &#123; if (!vis[i] &amp;&amp; ((now.x - node[i].x) * (now.x - node[i].x) + (now.y - node[i].y) * (now.y - node[i].y) &lt;= r * r)) &#123; int tmp_k; if (i &gt; n) tmp_k = now.k + 1; else tmp_k = now.k; vis[i] = 1; q.push(Node(node[i].x, node[i].y, now.dis + 1, tmp_k)); &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; r; for (int i = 1; i &lt;= n + m; i++) cin &gt;&gt; node[i].x &gt;&gt; node[i].y; cout &lt;&lt; bfs(1, 2) &lt;&lt; endl; return 0;&#125; 本题明确了有n个点,显然用一维数组struct node[N]保存更为方便. 回忆之前 dis[] []二维数据 vis是隐藏在了dis[] []的数值里面,即== -1 的时候认为!vis . 故本例中增加了vis[N]数组用来记录是否访问过. len的界限 是解决本题的关键.","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"https://coincidenceboy.github.io/tags/bfs/"}]},{"title":"sstream+getline","slug":"sstream+getline","date":"2020-11-24T02:22:04.591Z","updated":"2021-01-27T07:06:55.449Z","comments":true,"path":"2020/11/24/sstream+getline/","link":"","permalink":"https://coincidenceboy.github.io/2020/11/24/sstream+getline/","excerpt":"","text":"字符串分割神器—sstream+getline一些string常用的字符串处理12345678string s;s.substr(pos,n);//截取s中从pos开始（包括0，左边是闭区间）的n个字符的子串，并返回字符串s.erase(pos,n); //删除s中从pos开始（包括0，左边是闭区间）的n个字符的子串s.insert(pos,string tmp);//在位置pos处插入字符串tmps.insert(pos,n,string tmp);//在位置pos处插入n次字符串tmp 注:pos可以用迭代器s.begin() s.end()s.find(str s1); //查找s中第一次出现s1的位置,并返回(包括0) 例题—外星密码 解法1-利用string的自带函数erase,insert12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5;int n1,a[N];int main()&#123; string s; cin &gt;&gt; s; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;[&#x27;) a[++n1] = i; &#125; for (int i = n1; i &gt;= 1; i--) &#123; int num = 0, end = 2; string tmp,now; for (int j = a[i]+1; s[j]!=&#x27;]&#x27;; j++)//注意for的结束条件 &#123; if (s[j] &gt;= &#x27;0&#x27; &amp;&amp; s[j] &lt;= &#x27;9&#x27;) num = num * 10 + s[j] - &#x27;0&#x27;; else tmp += s[j]; end++; &#125; for (int k = 1; k &lt;= num; k++) now += tmp; s.erase(a[i], end); s.insert(a[i], now); &#125; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 解法2-递归1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;string read()&#123; string s,str; char c; while (cin &gt;&gt; c) &#123; if (c == &#x27;[&#x27;) &#123; int n; cin &gt;&gt; n; str = read(); while (n--) s += str; &#125; else if (c == &#x27;]&#x27;) &#123; return s; &#125; else s += c; &#125;&#125;int main()&#123; cout &lt;&lt; read() &lt;&lt; endl; return 0;&#125; sstream+getline1234#include&lt;sstream&gt; //头文件//stringstream的特点是，你读入了前面的一部分字符串，对应的字符串流中就会减去那一部分//(配合getline截断字符使用的话，字符流中也会减去截断字符)，//所以可以使用while来一直循环读入. eg. Sample input : 1/../d///c eg. Sample output : 123..dc 在插入vector的过程中,要判断当前小字符串(stemp)是否为空 ; 否则会出现很多空字符 , 如下: 123456..dc 关于—getline() 在c++中本质有两种 getline 函数 12345//在头文件&lt;iostream&gt;中 , 是iostream类的成员函数 .istream&amp; getline (char* s,streamsize n);//从istream中读取至多n个字符(包括结束标记符)保存在s对应的数组中.istream&amp; getline (char* s,streamsize n,char delim);//即使还没读够n个字符，如果遇到delim 或 字数达到限制，则读取终止 . delim不会被保存进s对应的数组中 12345//在头文件&lt;string&gt;中，是普通函数.istream&amp; getline(istream&amp; is,string&amp; str);//从输入流is中(如 cin),读一行到str里面.istream&amp; getline(istream&amp; is,string&amp; str,char delim);//从输入流is中,按照截断字符delim读到str中 关于—流和EOF(win下是ctrl+Z) 就while(getline(cin,line))分析一下 这个while语句真实的判断对象是 cin 的状态,也就是当前是否存在有效的输入流.而输入流是对象,返回的是输入流的状态.正常情况下,你是怎么输入都跳不出循环的. (如果认为输入 回车 就可以跳出,则是将 while的判断对象看成了 line(即判断line是否为空) 实际上,回车和设置的delim都是仅终止getline()的读取操作). EOF是C语言中为了区分有效数据和输入结束符的。windows下是ctrl+z,linux/unix下是ctrl+d。","categories":[{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"}],"tags":[{"name":"字符串处理","slug":"字符串处理","permalink":"https://coincidenceboy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"}]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://coincidenceboy.github.io/categories/LeetCode/"},{"name":"java","slug":"java","permalink":"https://coincidenceboy.github.io/categories/java/"},{"name":"win10","slug":"win10","permalink":"https://coincidenceboy.github.io/categories/win10/"},{"name":"前端","slug":"前端","permalink":"https://coincidenceboy.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"C++","slug":"C","permalink":"https://coincidenceboy.github.io/categories/C/"},{"name":"图论","slug":"图论","permalink":"https://coincidenceboy.github.io/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"opengl图形学","slug":"opengl图形学","permalink":"https://coincidenceboy.github.io/categories/opengl%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"线性表","slug":"线性表","permalink":"https://coincidenceboy.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"GUI","slug":"GUI","permalink":"https://coincidenceboy.github.io/tags/GUI/"},{"name":"java基础","slug":"java基础","permalink":"https://coincidenceboy.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"Dos命令","slug":"Dos命令","permalink":"https://coincidenceboy.github.io/tags/Dos%E5%91%BD%E4%BB%A4/"},{"name":"css","slug":"css","permalink":"https://coincidenceboy.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://coincidenceboy.github.io/tags/html/"},{"name":"动态规划","slug":"动态规划","permalink":"https://coincidenceboy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DFS","slug":"DFS","permalink":"https://coincidenceboy.github.io/tags/DFS/"},{"name":"STL","slug":"STL","permalink":"https://coincidenceboy.github.io/tags/STL/"},{"name":"算法导论","slug":"算法导论","permalink":"https://coincidenceboy.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://coincidenceboy.github.io/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"B样条","slug":"B样条","permalink":"https://coincidenceboy.github.io/tags/B%E6%A0%B7%E6%9D%A1/"},{"name":"Bezier曲线","slug":"Bezier曲线","permalink":"https://coincidenceboy.github.io/tags/Bezier%E6%9B%B2%E7%BA%BF/"},{"name":"扫描线填充多边形算法","slug":"扫描线填充多边形算法","permalink":"https://coincidenceboy.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%A1%AB%E5%85%85%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%AE%97%E6%B3%95/"},{"name":"Southerland-Hodgeman 多边形裁剪","slug":"Southerland-Hodgeman-多边形裁剪","permalink":"https://coincidenceboy.github.io/tags/Southerland-Hodgeman-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%A3%81%E5%89%AA/"},{"name":"liang-barsky裁剪","slug":"liang-barsky裁剪","permalink":"https://coincidenceboy.github.io/tags/liang-barsky%E8%A3%81%E5%89%AA/"},{"name":"Bresenham画线算法","slug":"Bresenham画线算法","permalink":"https://coincidenceboy.github.io/tags/Bresenham%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"},{"name":"高精","slug":"高精","permalink":"https://coincidenceboy.github.io/tags/%E9%AB%98%E7%B2%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://coincidenceboy.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"最短路","slug":"最短路","permalink":"https://coincidenceboy.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://coincidenceboy.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"并查集","slug":"并查集","permalink":"https://coincidenceboy.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"图的存储和遍历","slug":"图的存储和遍历","permalink":"https://coincidenceboy.github.io/tags/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86/"},{"name":"前缀和&差分","slug":"前缀和-差分","permalink":"https://coincidenceboy.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/"},{"name":"线性数据结构","slug":"线性数据结构","permalink":"https://coincidenceboy.github.io/tags/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c++万能头","slug":"c-万能头","permalink":"https://coincidenceboy.github.io/tags/c-%E4%B8%87%E8%83%BD%E5%A4%B4/"},{"name":"蓝牙","slug":"蓝牙","permalink":"https://coincidenceboy.github.io/tags/%E8%93%9D%E7%89%99/"},{"name":"csp","slug":"csp","permalink":"https://coincidenceboy.github.io/tags/csp/"},{"name":"bfs","slug":"bfs","permalink":"https://coincidenceboy.github.io/tags/bfs/"},{"name":"字符串处理","slug":"字符串处理","permalink":"https://coincidenceboy.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"}]}